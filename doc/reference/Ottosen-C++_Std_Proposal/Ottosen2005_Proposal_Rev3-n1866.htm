<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0066)http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html -->
<HTML xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><HEAD><META http-equiv="Content-Type" content="text/html; charset=UTF-8">

<META name="generator" content="Docutils 0.3.9: http://docutils.sourceforge.net/">
<TITLE>Proposal to add Contract Programming to C++ (revision 3)</TITLE>
<META name="author" content="Lawrence Crowl and Thorsten Ottosen">
<META name="organization" content="Sun Microsystems and Dezide Aps">
<META name="date" content="2005-08-24">
<STYLE type="text/css">

/*
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:date: $Date: 2004/01/12 02:49:54 $
:version: $Revision: 1.2 $
:copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.
*/

.first {
  margin-top: 0 }

.last {
  margin-bottom: 0 }

a.toc-backref {
  text-decoration: none ;
  color: black }

dd {
  margin-bottom: 0.5em }

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.attention, div.caution, div.danger, div.error, div.hint,
div.important, div.note, div.tip, div.warning, div.admonition {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

div.hint p.admonition-title, div.important p.admonition-title,
div.note p.admonition-title, div.tip p.admonition-title,
div.admonition p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em }

div.footer, div.header {
  font-size: smaller }

div.sidebar {
  margin-left: 1em ;
  border: medium outset ;
  padding: 0em 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr {
  width: 75% }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.line-block {
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;
  background-color: #eeeeee }

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.option-argument {
  font-style: italic }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

table {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.citation {
  border-left: solid thin gray ;
  padding-left: 0.5ex }

table.docinfo {
  margin: 2em 4em }

table.footnote {
  border-left: solid thin black ;
  padding-left: 0.5ex }

td, th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

th.docinfo-name, th.field-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap }

h1 tt, h2 tt, h3 tt, h4 tt, h5 tt, h6 tt {
  font-size: 100% }

tt {
  background-color: #eeeeee }

ul.auto-toc {
  list-style-type: none }
  
pre{
  BORDER-RIGHT: gray 1pt solid;
  PADDING-RIGHT: 2pt;
  BORDER-TOP: gray 1pt solid;
  DISPLAY: block;
  PADDING-LEFT: 2pt;
  PADDING-BOTTOM: 2pt;
  BORDER-LEFT: gray 1pt solid;
  MARGIN-RIGHT: 32pt;
  PADDING-TOP: 2pt;
  BORDER-BOTTOM: gray 1pt solid;
  FONT-FAMILY: "Courier New", Courier, mono; 
  background-color: #EEEEEE; 
}


.keyword{color: #0000FF;}
.identifier{}
.comment{font-style: italic; color: #008000;}
.special{color: #800040;}
.preprocessor{color: #3F007F;}
.string{font-style: italic; color: #666666;}
.literal{/*font-style: italic;*/ color: #000000;}

</STYLE>
<TITLE> </TITLE><TITLE> </TITLE><TITLE> </TITLE></HEAD><BODY>
<DIV class="document" id="proposal-to-add-contract-programming-to-c-revision-3">
<H1 class="title">Proposal to add Contract Programming to C++ (revision 3)</H1>
<TABLE class="docinfo" frame="void" rules="none">
<COL class="docinfo-name">
<COL class="docinfo-content">
<TBODY valign="top">
<TR><TH class="docinfo-name">Author:</TH>
<TD>Lawrence Crowl and Thorsten Ottosen</TD></TR>
<TR><TH class="docinfo-name">Contact:</TH>
<TD><A class="first reference" href="mailto:lawrence.crowl@sun.com">lawrence.crowl@sun.com</A> and <A class="last reference" href="mailto:nesotto@cs.aau.dk">nesotto@cs.aau.dk</A></TD></TR>
<TR><TH class="docinfo-name">Organization:</TH>
<TD>Sun Microsystems and Dezide Aps</TD></TR>
<TR><TH class="docinfo-name">Date:</TH>
<TD>2005-08-24</TD></TR>
<TR class="field"><TH class="docinfo-name">Number:</TH><TD class="field-body">WG21/N1866 and J16/05-0126. This proposal is a
revision of paper <A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html">n1773</A>.</TD>
</TR>
<TR class="field"><TH class="docinfo-name">Working Group:</TH><TD class="field-body">Evolution</TD>
</TR>
</TBODY>
</TABLE>
<DIV class="abstract topic">
<P class="topic-title first">Abstract</P>
<P>Contract Programming is about providing the programmer with stronger tools 
for expressing correctness arguments directly in the source code. Moreover, the
contracts enable new and powerful optimization opportunities. 
This proposal describes a small assertion sub-language 
that unifies compile-time and run-time assertions.
The benefits 
are among others a higher degree of self-documenting source code,
better design tools, 
and easier debugging and testing.</P>
</DIV>
<DIV class="contents topic" id="table-of-contents">
<P class="topic-title first"><A name="table-of-contents">Table of Contents</A></P>
<UL class="auto-toc simple">
<LI><A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#motivation" id="id23" name="id23">1&nbsp;&nbsp;&nbsp;Motivation</A></LI>
<LI><A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#the-proposal" id="id24" name="id24">2&nbsp;&nbsp;&nbsp;The proposal</A><UL class="auto-toc">
<LI><A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#assertions" id="id25" name="id25">2.1&nbsp;&nbsp;&nbsp;Assertions</A><UL class="auto-toc">
<LI><A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#static-assertions" id="id26" name="id26">2.1.1&nbsp;&nbsp;&nbsp;Static assertions</A></LI>
<LI><A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#runtime-assertions" id="id27" name="id27">2.1.2&nbsp;&nbsp;&nbsp;Runtime assertions</A></LI>
</UL>
</LI>
<LI><A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#function-pre-and-postconditions" id="id28" name="id28">2.2&nbsp;&nbsp;&nbsp;Function pre- and postconditions</A><UL class="auto-toc">
<LI><A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#virtual-functions" id="id29" name="id29">2.2.1&nbsp;&nbsp;&nbsp;Virtual functions</A></LI>
<LI><A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#constructors" id="id30" name="id30">2.2.2&nbsp;&nbsp;&nbsp;Constructors</A></LI>
<LI><A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#function-pointers" id="id31" name="id31">2.2.3&nbsp;&nbsp;&nbsp;Function pointers</A></LI>
</UL>
</LI>
<LI><A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#keyword-oldof" id="id32" name="id32">2.3&nbsp;&nbsp;&nbsp;Keyword <TT class="docutils literal"><SPAN class="pre">oldof</SPAN></TT></A></LI>
<LI><A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#class-invariants" id="id33" name="id33">2.4&nbsp;&nbsp;&nbsp;Class invariants</A></LI>
<LI><A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#namespace-invariants" id="id34" name="id34">2.5&nbsp;&nbsp;&nbsp;Namespace invariants</A></LI>
<LI><A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#failure-handler-functions" id="id35" name="id35">2.6&nbsp;&nbsp;&nbsp;Failure handler functions</A></LI>
<LI><A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#changes-to-the-standard-library" id="id36" name="id36">2.7&nbsp;&nbsp;&nbsp;Changes to the standard library</A></LI>
</UL>
</LI>
<LI><A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#contracts-for-performance" id="id37" name="id37">3&nbsp;&nbsp;&nbsp;Contracts for performance</A><UL class="auto-toc">
<LI><A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#assert-is-evaluated-within-the-library" id="id38" name="id38">3.1&nbsp;&nbsp;&nbsp;<TT class="docutils literal"><SPAN class="pre">assert()</SPAN></TT> is evaluated within the library</A></LI>
<LI><A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#assert-fails-to-distinguish-between-checking-arguments-and-validating-computations" id="id39" name="id39">3.2&nbsp;&nbsp;&nbsp;<TT class="docutils literal"><SPAN class="pre">assert()</SPAN></TT> fails to distinguish between checking arguments and validating computations</A></LI>
<LI><A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#assert-is-indistinguishable-from-regular-code" id="id40" name="id40">3.3&nbsp;&nbsp;&nbsp;<TT class="docutils literal"><SPAN class="pre">assert()</SPAN></TT> is indistinguishable from regular code</A></LI>
</UL>
</LI>
<LI><A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#implementation-model-for-contracts" id="id41" name="id41">4&nbsp;&nbsp;&nbsp;Implementation model for contracts</A></LI>
<LI><A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#open-issues" id="id42" name="id42">5&nbsp;&nbsp;&nbsp;Open issues</A><UL class="auto-toc">
<LI><A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#are-failure-handler-functions-wrongly-specified" id="id43" name="id43">5.1&nbsp;&nbsp;&nbsp;Are failure handler functions wrongly specified?</A></LI>
</UL>
</LI>
<LI><A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#major-changes-from-n1773" id="id44" name="id44">6&nbsp;&nbsp;&nbsp;Major changes from n1773</A></LI>
<LI><A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#list-of-proposals-that-could-be-affected-by-this-proposal" id="id45" name="id45">7&nbsp;&nbsp;&nbsp;List of proposals that could be affected by this proposal</A></LI>
<LI><A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#implementability" id="id46" name="id46">8&nbsp;&nbsp;&nbsp;Implementability</A></LI>
<LI><A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#alternative-syntax" id="id47" name="id47">9&nbsp;&nbsp;&nbsp;Alternative syntax</A></LI>
<LI><A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#list-of-examples" id="id48" name="id48">10&nbsp;&nbsp;&nbsp;List of examples</A><UL class="auto-toc">
<LI><A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#vector-example-hpp" id="id49" name="id49">10.1&nbsp;&nbsp;&nbsp;vector_example.hpp</A></LI>
<LI><A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#vector-example-alternative-syntax-hpp" id="id50" name="id50">10.2&nbsp;&nbsp;&nbsp;vector_example_alternative_syntax.hpp</A></LI>
<LI><A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#subcontracting-example-hpp" id="id51" name="id51">10.3&nbsp;&nbsp;&nbsp;subcontracting_example.hpp</A></LI>
</UL>
</LI>
<LI><A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#comparison-of-contract-programming-in-d-eiffel-and-c" id="id52" name="id52">11&nbsp;&nbsp;&nbsp;Comparison of Contract Programming in D, Eiffel and C++</A></LI>
<LI><A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#acknowledgements" id="id53" name="id53">12&nbsp;&nbsp;&nbsp;Acknowledgements</A></LI>
<LI><A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#footnotes" id="id54" name="id54">13&nbsp;&nbsp;&nbsp;Footnotes</A></LI>
</UL>
</DIV>
<DIV class="section" id="motivation">
<H1><A class="toc-backref" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#id23" name="motivation">1&nbsp;&nbsp;&nbsp;Motivation</A></H1>
<P>Language support for Contract Programming has several benefits:</P>
<OL class="arabic simple">
<LI>It can remove the need for separation of documentation and implementation.</LI>
</OL>
<!--  -->
<OL class="arabic simple" start="2">
<LI>It can enable the compiler to generate faster code <A class="footnote-reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#id15" id="id1" name="id1">[0]</A>
(see also <A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#contracts-for-performance">Contracts for performance</A>).</LI>
</OL>
<!--  -->
<OL class="arabic simple" start="3">
<LI>It can make debugging and testing much easier.</LI>
</OL>
<!--  -->
<OL class="arabic simple" start="4">
<LI>It can improve communication between designers and programmers in large C++ projects.</LI>
</OL>
<!--  -->
<OL class="arabic simple" start="5">
<LI>It can make inheritance easier to use correctly (see <A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#subcontracting-example-hpp">subcontracting_example.hpp</A> ).</LI>
</OL>
<!--  -->
<OL class="arabic simple" start="6">
<LI>It can ensure that every programmer understands the contract metaphors <A class="footnote-reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#id16" id="id2" name="id2">[1]</A> .</LI>
</OL>
<!--  -->
<OL class="arabic simple" start="7">
<LI>It can enable more powerful static analysis tools.</LI>
</OL>
<P>Please refer to <A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1800.pdf">n1800</A> and <A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2004/n1613.pdf">n1613</A> for an extensive discussion of these benefits.</P>
<P>Already with the current proposal, it is quite remarkable how much
of an interface that can be documented. For a good example, please
see how <TT class="docutils literal"><SPAN class="pre">std::vector</SPAN></TT> is declared in <A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#vector-example-hpp">vector_example.hpp</A>; there is only a small
portion of the specification of <TT class="docutils literal"><SPAN class="pre">std::vector</SPAN></TT> that cannot be described in the 
contracts.</P>
</DIV>
<DIV class="section" id="the-proposal">
<H1><A class="toc-backref" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#id24" name="the-proposal">2&nbsp;&nbsp;&nbsp;The proposal</A></H1>
<P>The idea is to extend C++</P>
<UL class="simple">
<LI>function declarations with <A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#functionx">pre- and postconditions</A>,</LI>
</UL>
<!--  -->
<UL class="simple">
<LI>class declarations with <A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#class-invariants">class invariants</A>,</LI>
</UL>
<!--  -->
<UL class="simple">
<LI>namespace declarations and function scope with <A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#namespace-invariants">namespace invariants</A>.</LI>
</UL>
<P>These new <EM>contract scopes</EM> can contain <A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#assertions">assertions</A> that
may be evaluated either at compiler-time or at
run-time as part of the program to verify their correctness.</P>
<DIV class="section" id="assertions">
<H2><A class="toc-backref" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#id25" name="assertions">2.1&nbsp;&nbsp;&nbsp;Assertions</A></H2>
<P>The basic building blocks of contracts are 
<EM>assertions</EM>. Assertions come in two categories:</P>
<UL class="simple">
<LI><A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#static-assertions">static assertions</A></LI>
</UL>
<!--  -->
<UL class="simple">
<LI><A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#runtime-assertions">runtime assertions</A></LI>
</UL>
<DIV class="section" id="static-assertions">
<H3><A class="toc-backref" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#id26" name="static-assertions">2.1.1&nbsp;&nbsp;&nbsp;Static assertions</A></H3>
<P>There are two flavors of <EM>static</EM> assertions:</P>
<OL class="arabic">
<LI><P class="first"><EM>default</EM> assertions</P>
<BLOCKQUOTE>
<DL class="docutils">
<DT>syntax: </DT>
<DD><OL class="first last arabic simple">
<LI><EM>static-assertion</EM>:  <EM>constant-expression</EM> <TT class="docutils literal"><SPAN class="pre">:</SPAN></TT> <EM>string-literal</EM> <TT class="docutils literal"><SPAN class="pre">;</SPAN></TT></LI>
</OL>
</DD>
<DT>example: </DT>
<DD><P class="first last"><TT class="docutils literal"><SPAN class="pre">is_pod&lt;T&gt;::value</SPAN> <SPAN class="pre">:</SPAN> <SPAN class="pre">"T</SPAN> <SPAN class="pre">must</SPAN> <SPAN class="pre">model</SPAN> <SPAN class="pre">a</SPAN> <SPAN class="pre">POD";</SPAN></TT></P>
</DD>
</DL>
</BLOCKQUOTE>
</LI>
<LI><P class="first"><EM>select</EM> assertions</P>
<BLOCKQUOTE>
<DL class="docutils">
<DT>syntax:</DT>
<DD><OL class="first last arabic simple">
<LI><EM>static-assertion-sequence</EM>:</LI>
<LI><EM>static-assertion-sequence</EM>: <EM>static-assertion-sequence</EM> <EM>static-assertion</EM></LI>
<LI><EM>static-body</EM>: <EM>static-assertion</EM></LI>
<LI><EM>static-body</EM>: <TT class="docutils literal"><SPAN class="pre">{</SPAN></TT> <EM>static-assertion-sequence</EM> <TT class="docutils literal"><SPAN class="pre">}</SPAN></TT></LI>
<LI><EM>static-if-assertion</EM> : <TT class="docutils literal"><SPAN class="pre">if(</SPAN></TT> <EM>constant-expression</EM> <TT class="docutils literal"><SPAN class="pre">)</SPAN></TT> <EM>static-body</EM> <EM>static-else-assertion</EM> <SUB>opt</SUB></LI>
<LI><EM>static-else-assertion</EM> : <TT class="docutils literal"><SPAN class="pre">else</SPAN></TT> <EM>static-body</EM></LI>
</OL>
</DD>
<DT>example:</DT>
<DD><DL class="first last docutils">
<DT><TT class="docutils literal"><SPAN class="pre">if(</SPAN> <SPAN class="pre">is_pod&lt;T&gt;::value</SPAN> <SPAN class="pre">)</SPAN></TT></DT>
<DD><P class="first last"><TT class="docutils literal"><SPAN class="pre">sizeof(</SPAN> <SPAN class="pre">T</SPAN> <SPAN class="pre">)</SPAN> <SPAN class="pre">&lt;=</SPAN> <SPAN class="pre">sizeof(</SPAN> <SPAN class="pre">long</SPAN> <SPAN class="pre">)</SPAN> <SPAN class="pre">:</SPAN> <SPAN class="pre">"Only</SPAN> <SPAN class="pre">PODs</SPAN> <SPAN class="pre">smaller</SPAN> <SPAN class="pre">than</SPAN> <SPAN class="pre">long</SPAN> <SPAN class="pre">supported";</SPAN></TT></P>
</DD>
</DL>
</DD>
</DL>
</BLOCKQUOTE>
</LI>
</OL>
<P>The <EM>contant-expression</EM> is implicitly converted to <TT class="docutils literal"><SPAN class="pre">bool</SPAN></TT>.</P>
<P>The static assertions are exactly like the ones described in <A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2004/n1617.html">n1617</A>. The 
main difference is that we</P>
<!-- 1. reuse the keyword ``static`` instead of adding a new one,  -->
<!--  -->
<OL class="arabic simple">
<LI>confine the scope of the static assertion to contract scope, and</LI>
</OL>
<!--  -->
<OL class="arabic simple" start="2">
<LI>allow compile-time select statements to avoid duplication of conditions.</LI>
</OL>
</DIV>
<DIV class="section" id="runtime-assertions">
<H3><A class="toc-backref" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#id27" name="runtime-assertions">2.1.2&nbsp;&nbsp;&nbsp;Runtime assertions</A></H3>
<P>There are two flavors of <EM>runtime</EM> assertions:</P>
<OL class="arabic">
<LI><P class="first"><EM>default</EM> assertions</P>
<BLOCKQUOTE>
<DL class="docutils">
<DT>syntax:</DT>
<DD><OL class="first last arabic simple">
<LI><EM>runtime-assertion</EM> : <EM>boolean-expression</EM> <EM>importance-ordering</EM> <SUB>opt</SUB> <TT class="docutils literal"><SPAN class="pre">;</SPAN></TT></LI>
<LI><EM>importance-ordering</EM> : <TT class="docutils literal"><SPAN class="pre">:</SPAN></TT> <EM>integer-constant</EM></LI>
</OL>
</DD>
<DT>example:</DT>
<DD><P class="first last"><TT class="docutils literal"><SPAN class="pre">std::cout.good();</SPAN></TT></P>
</DD>
</DL>
</BLOCKQUOTE>
</LI>
<LI><P class="first"><EM>select</EM> assertions</P>
<BLOCKQUOTE>
<DL class="docutils">
<DT>syntax:</DT>
<DD><OL class="first last arabic simple">
<LI><EM>runtime-assertion-sequence</EM> :</LI>
<LI><EM>runtime-assertion-sequence</EM> : <EM>runtime-assertion-sequence</EM> <EM>runtime-assertion</EM></LI>
<LI><EM>runtime-body</EM> : <EM>runtime-assertion</EM></LI>
<LI><EM>runtime-body</EM> : <TT class="docutils literal"><SPAN class="pre">{</SPAN></TT> <EM>runtime-assertion-sequence</EM> <TT class="docutils literal"><SPAN class="pre">}</SPAN></TT></LI>
<LI><EM>runtime-if-assertion</EM> : <TT class="docutils literal"><SPAN class="pre">if(</SPAN></TT> <EM>condition</EM> <TT class="docutils literal"><SPAN class="pre">)</SPAN></TT> <EM>runtime-body</EM> <EM>runtime-else-assertion</EM> <SUB>opt</SUB></LI>
<LI><EM>runtime-else-assertion</EM> : <TT class="docutils literal"><SPAN class="pre">else</SPAN></TT> <EM>runtime-body</EM></LI>
</OL>
</DD>
<DT>example:</DT>
<DD><DL class="first last docutils">
<DT><TT class="docutils literal"><SPAN class="pre">if(</SPAN> <SPAN class="pre">empty()</SPAN> <SPAN class="pre">)</SPAN></TT> </DT>
<DD><P class="first last"><TT class="docutils literal"><SPAN class="pre">result</SPAN> <SPAN class="pre">==</SPAN> <SPAN class="pre">end();</SPAN></TT></P>
</DD>
</DL>
</DD>
</DL>
</BLOCKQUOTE>
</LI>
</OL>
<P>The following general points are worth noting:</P>
<OL class="arabic">
<LI><P class="first">Default assertions defaults to calling <TT class="docutils literal"><SPAN class="pre">terminate()</SPAN></TT>, but the behavior can be <A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#failure-handler-functions">customized</A>.</P>
<BLOCKQUOTE>
</BLOCKQUOTE>
</LI>
<LI><P class="first">The select assertions remove the need for the implication operator that was discussed in <A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2004/n1613.pdf">n1613</A>.</P>
</LI>
<LI><P class="first">The syntactic freedom has been kept minimal to ensure a good documentation effect.</P>
</LI>
<LI><P class="first">All visible functions and variables can be used within contract scope.</P>
</LI>
<LI><P class="first">Member reference within constract scope is subject to the same constraints as member reference within <TT class="docutils literal"><SPAN class="pre">const</SPAN></TT> member functions.</P>
</LI>
</OL>
<!-- Wrt. constness, then contract scope behaves as if it was a const member function [2]_. -->
<OL class="arabic simple" start="6">
<LI>If the compiler can determine that the condition of an assertion is true, it may choose not to evaluate 
that assertion.</LI>
</OL>
<!-- James have alternative wording  -->
<!--  -->
<OL class="arabic simple" start="7">
<LI>If the compiler can determine that the condition of an assertion is false, it may choose 
to call the <A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#failure-handler-functions">broken contract handler</A> or call the action without evaluating that condition.</LI>
</OL>
<!--  -->
<OL class="arabic simple" start="8">
<LI>Importance ordering allows users to specify multiple levels of assertions.
The higher an integer, the more crucial it is to keep an assertion in the
object code.</LI>
</OL>
<!--  -->
<OL class="arabic simple" start="9">
<LI>The default importance ordering is <TT class="docutils literal"><SPAN class="pre">0</SPAN></TT> and is in effect
when no integer is specified.</LI>
</OL>
<P>It is possible to mix static and runtime assertions. In that case talk about
assertion sequences:</P>
<BLOCKQUOTE>
<OL class="arabic simple">
<LI><EM>assertion-sequence</EM> :</LI>
<LI><EM>assertion-sequence</EM> : <EM>assertion-sequence</EM> <EM>static-assertion-sequence</EM></LI>
<LI><EM>assertion-sequence</EM> : <EM>assertion-sequence</EM> <EM>runtime-assertion-sequence</EM></LI>
</OL>
</BLOCKQUOTE>
</DIV>
</DIV>
<SPAN id="functionx"></SPAN><SPAN id="function"></SPAN><DIV class="section" id="function-pre-and-postconditions">
<H2><A class="toc-backref" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#id28" name="function-pre-and-postconditions">2.2&nbsp;&nbsp;&nbsp;Function pre- and postconditions</A></H2>
<P>The function declaration and definition
are changed into:</P>
<BLOCKQUOTE>
<BLOCKQUOTE>
<OL class="arabic simple">
<LI><EM>precontracted-function</EM> : <EM>function-head</EM></LI>
<LI><EM>precontracted-function</EM> : <EM>function-head</EM> <EM>precondition-contract</EM></LI>
<LI><EM>postcontracted-function</EM> : <EM>precontracted-function</EM></LI>
<LI><EM>postcontracted-function</EM> : <EM>precontracted-function</EM> <EM>postcondition-contract</EM></LI>
<LI><EM>function-declaration</EM> : <EM>postcontracted-function</EM> <TT class="docutils literal"><SPAN class="pre">;</SPAN></TT></LI>
<LI><EM>function-definition</EM> : <EM>postcontracted-function</EM> <TT class="docutils literal"><SPAN class="pre">{</SPAN></TT> <EM>function-body</EM> <TT class="docutils literal"><SPAN class="pre">}</SPAN></TT></LI>
<LI><EM>precondition-contract</EM> : <TT class="docutils literal"><SPAN class="pre">precondition</SPAN> <SPAN class="pre">{</SPAN></TT> <EM>assertion-sequence</EM> <TT class="docutils literal"><SPAN class="pre">}</SPAN></TT></LI>
<LI><EM>postcondition-contract</EM> : <TT class="docutils literal"><SPAN class="pre">postcondition</SPAN></TT> <EM>return-value-declaration</EM><SUB>opt</SUB> <TT class="docutils literal"><SPAN class="pre">{</SPAN></TT> <EM>assertion-sequence</EM> <TT class="docutils literal"><SPAN class="pre">}</SPAN></TT></LI>
<LI><EM>return-value-declaration</EM>: <TT class="docutils literal"><SPAN class="pre">(</SPAN></TT> <EM>identifier</EM> <TT class="docutils literal"><SPAN class="pre">)</SPAN></TT></LI>
</OL>
</BLOCKQUOTE>
<P>example:</P>
<PRE class="literal-block">double sqrt( double r )
    precondition
    {
        r &gt; 0.;
    }
    postcondition( result )
    {
        equal_within_precision( result * result, r );
    }
</PRE>
</BLOCKQUOTE>
<P>In the <EM>return-value-declaration</EM> we declare a local variable that acts as a <TT class="docutils literal"><SPAN class="pre">const</SPAN></TT> reference to the computed 
return value. It follows that a <EM>return-value-declaration</EM> is illegal if the return type is <TT class="docutils literal"><SPAN class="pre">void</SPAN></TT>.</P>
<P>The following general rules apply:</P>
<OL class="arabic">
<LI><P class="first">If a function has both a declaration and a definition, the contracts must appear on the declaration.</P>
</LI>
<LI><P class="first"><SPAN class="target" id="the-execution-of-a-function">The execution of a function</SPAN> is now</P>
<BLOCKQUOTE>
<OL class="loweralpha simple">
<LI>evaluate the precondition assertion by assertion in order starting from the top,</LI>
<LI>evaluate <TT class="docutils literal"><SPAN class="pre">oldof</SPAN></TT> occurrences in the postcondition,</LI>
<LI>evaluate the function body,</LI>
<LI>evaluate the postcondition assertion by assertion in order starting from the top.</LI>
</OL>
</BLOCKQUOTE>
</LI>
<LI><P class="first">The execution of a member function is now as in 2, but</P>
<BLOCKQUOTE>
<OL class="loweralpha">
<LI><P class="first"><TT class="docutils literal"><SPAN class="pre">2.a</SPAN></TT> is <EM>preceded</EM> by a call to the <A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#class-invariants">class invariant</A>,</P>
</LI>
<LI><P class="first"><TT class="docutils literal"><SPAN class="pre">2.d</SPAN></TT> is <EM>preceded</EM> by a call to the class invariant,</P>
<BLOCKQUOTE>
<UL class="simple">
<LI>rationale: the contracts might call public functions in the class which require the invariant to be established.</LI>
</UL>
</BLOCKQUOTE>
</LI>
</OL>
</BLOCKQUOTE>
</LI>
<LI><P class="first">Function-try-blocks can appear together with pre- and postconditions on function
definitions.</P>
</LI>
<LI><P class="first">Pre- and postconditions are evaluated outside any function-try-block.</P>
</LI>
</OL>
<OL class="arabic simple" start="6">
<LI>During execution of the postcondition other contracts (recursively encountered) are <EM>not</EM> evaluated.</LI>
</OL>
<DIV class="section" id="virtual-functions">
<H3><A class="toc-backref" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#id29" name="virtual-functions">2.2.1&nbsp;&nbsp;&nbsp;Virtual functions</A></H3>
<P>If the function <TT class="docutils literal"><SPAN class="pre">F</SPAN></TT> is virtual, we require that</P>
<OL class="arabic simple">
<LI>only the first declaration/definition of <TT class="docutils literal"><SPAN class="pre">F</SPAN></TT> can have a precondition.</LI>
</OL>
<P>Section <TT class="docutils literal"><SPAN class="pre">3.5</SPAN></TT> of <A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2004/n1613.pdf">n1613</A> explains how little redefinition of preconditions is used. Even though
subcontracting is theoretically sound, it ends up being fairly useless in practice <A class="footnote-reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#id18" id="id7" name="id7">[3]</A>.</P>
<P>Postconditions can be made stronger in a derived class as seen in the <A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#subcontracting-example-hpp">subcontracting_example.hpp</A>.
We can summarize the remaining rules for virtual functions as</P>
<OL class="arabic simple" start="2">
<LI>pure virtual functions can have contracts,</LI>
</OL>
<!--  -->
<OL class="arabic simple" start="3">
<LI>postconditions from a function in a base class and the overridden version in a derived class
are <EM>AND</EM>ed together <A class="footnote-reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#id19" id="id8" name="id8">[4]</A>.</LI>
</OL>
<P>The last rule ensures that the function in the derived class has a stronger postcondition <EM>by design</EM>.
A programmer can via a downcast obtain the stronger guarantee, but the runtime check must still
follow rule 3 above.</P>
<P>In connection with multiple inheritance we require special rules.
if <TT class="docutils literal"><SPAN class="pre">F</SPAN></TT> overrides more than one virtual function due to multiple inheritance,
it holds that</P>
<OL class="arabic simple" start="4">
<LI>the precondition on <TT class="docutils literal"><SPAN class="pre">F</SPAN></TT> is an <EM>OR</EM>ing of the preconditions of all the
functions <TT class="docutils literal"><SPAN class="pre">F</SPAN></TT> override,</LI>
</OL>
<!--  -->
<OL class="arabic simple" start="5">
<LI>the postcondition on <TT class="docutils literal"><SPAN class="pre">F</SPAN></TT> is an <EM>AND</EM>ing of (1) the postconditions of all the
functions <TT class="docutils literal"><SPAN class="pre">F</SPAN></TT> override and (2) <TT class="docutils literal"><SPAN class="pre">F</SPAN></TT>'s own postcondition.</LI>
</OL>
</DIV>
<DIV class="section" id="constructors">
<H3><A class="toc-backref" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#id30" name="constructors">2.2.2&nbsp;&nbsp;&nbsp;Constructors</A></H3>
<P>Constructors behave much like member functions. This means that a constructor
can have a precondition and a postcondition.</P>
</DIV>
<DIV class="section" id="function-pointers">
<H3><A class="toc-backref" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#id31" name="function-pointers">2.2.3&nbsp;&nbsp;&nbsp;Function pointers</A></H3>
<P>If the address of a function is taken, it holds that</P>
<OL class="arabic simple">
<LI>the precondition is evaluated before the function body when the function is called 
through the function pointer.</LI>
</OL>
<P>Remark: A compiler might be able to determine that the precondition is satisfied, in that case
the compiler may generate a call directly to the function body 
(thus sharing implementation with the function pointer call).</P>
</DIV>
</DIV>
<DIV class="section" id="keyword-oldof">
<H2><A class="toc-backref" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#id32" name="keyword-oldof">2.3&nbsp;&nbsp;&nbsp;Keyword <TT class="docutils literal docutils literal"><SPAN class="pre">oldof</SPAN></TT></A></H2>
<P>It is very useful to be able to take a copy of a variable to compare
it with other values later. In particular, this is true in <A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#function">function postconditions</A>.</P>
<P>Assume <TT class="docutils literal"><SPAN class="pre">i</SPAN></TT> is a visible <TT class="docutils literal"><SPAN class="pre">int</SPAN></TT>, then the compiler translates</P>
<PRE class="literal-block">{
    oldof i == 42;
}
</PRE>
<P>into</P>
<PRE class="literal-block">{
    const int __old_i( i );
    __old_i == 42;
}
</PRE>
<P>A set of rules govern how <TT class="docutils literal"><SPAN class="pre">oldof</SPAN></TT> behaves within a certain contract:</P>
<OL class="arabic simple">
<LI>If it is applied to the same expression <EM>n</EM> times, that expression need only be
evaluated once and only one copy need to be stored.</LI>
</OL>
<!--  -->
<OL class="arabic simple" start="2">
<LI>The copy of its argument is taken <EM>after</EM> the precondition is evaluated.</LI>
</OL>
<P>The precondition should be evaluated first to allow it to report its errors first.
Notice that we can only apply <TT class="docutils literal"><SPAN class="pre">oldof</SPAN></TT> to objects of a type that defines a copy-constructor 
taking a <TT class="docutils literal"><SPAN class="pre">const</SPAN></TT> reference (ie., <TT class="docutils literal"><SPAN class="pre">std::auto_ptr</SPAN></TT> cannot be used).</P>
</DIV>
<DIV class="section" id="class-invariants">
<H2><A class="toc-backref" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#id33" name="class-invariants">2.4&nbsp;&nbsp;&nbsp;Class invariants</A></H2>
<P>Within class scope it is possible to define a class invariant:</P>
<BLOCKQUOTE>
<DL class="docutils">
<DT>syntax:</DT>
<DD><OL class="first last arabic simple">
<LI><EM>class-invariant</EM> : <TT class="docutils literal"><SPAN class="pre">invariant</SPAN> <SPAN class="pre">{</SPAN></TT> <EM>assertion-sequence</EM> <TT class="docutils literal"><SPAN class="pre">}</SPAN></TT></LI>
</OL>
</DD>
<DT>example: </DT>
<DD>see <A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#vector-example-hpp">vector_example.hpp</A></DD>
</DL>
</BLOCKQUOTE>
<P>The class invariant has the following properties:</P>
<OL class="arabic">
<LI><P class="first">It must appear in the declaration of a class.</P>
</LI>
<LI><P class="first">It is inherited in the sense that the invariant of a derived class <EM>implicitly</EM> will have the base-class invariant(s)
<EM>AND</EM>ed to it (see also item 6-7).</P>
<BLOCKQUOTE>
<P>example:</P>
<PRE class="literal-block">struct base { invariant { ... } };
struct derived : base
{
    invariant
    {
        base::invariant(); // implicitly generated
        ...
    }
};
</PRE>
<P>(Remark: the above is pseudo-code and is <EM>not</EM> affected by the disabling of assertions within assertions.)</P>
</BLOCKQUOTE>
</LI>
<LI><P class="first">It can always be called from within or outside the class as if it was a member function with the declaration <TT class="docutils literal"><SPAN class="pre">void</SPAN> <SPAN class="pre">invariant()</SPAN> <SPAN class="pre">const;</SPAN></TT>.</P>
</LI>
<LI><P class="first">It is called <EM>implicitly</EM> from public</P>
<BLOCKQUOTE>
<OL class="loweralpha simple">
<LI><A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#function">pre- and postconditions</A>,</LI>
</OL>
<OL class="loweralpha" start="2">
<LI><P class="first">constructors,</P>
<BLOCKQUOTE>
<UL class="simple">
<LI>call the class invariant <EM>before</EM> the postcondition,</LI>
</UL>
</BLOCKQUOTE>
</LI>
<LI><P class="first">destructors,</P>
<BLOCKQUOTE>
<UL class="simple">
<LI>call the class invariant <EM>before</EM> the destructor body.</LI>
</UL>
</BLOCKQUOTE>
</LI>
<LI><P class="first">member functions that exit abnormally via an exception <A class="footnote-reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#id20" id="id11" name="id11">[5]</A></P>
</LI>
</OL>
</BLOCKQUOTE>
</LI>
<LI><P class="first"><SPAN class="target" id="it-is-always-called">It is always called</SPAN> as if surrounded by a try-catch block:</P>
<PRE class="literal-block">try
{
    class_invariant();
}
catch( ... )
{
    std::class_invariant_broken();
}
</PRE>
</LI>
</OL>
<BLOCKQUOTE>
<UL class="simple">
<LI>rationale: this ensures that exceptions thrown in the invariant cannot escape from functions 
and in particular not from the destructor. <A class="footnote-reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#id21" id="id12" name="id12">[6]</A></LI>
</UL>
</BLOCKQUOTE>
<OL class="arabic" start="6">
<LI><P class="first">For its execution <EM>during</EM> construction <A class="footnote-reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#id22" id="id13" name="id13">[7]</A> holds that:</P>
<BLOCKQUOTE>
<OL class="loweralpha">
<LI><P class="first">each assertion is executed in order starting from the top <EM>excluding</EM> any part inherited,</P>
<BLOCKQUOTE>
<UL class="simple">
<LI>rationale: if we do not exclude inherited parts, those parts would be evaluated multiple times.</LI>
</UL>
</BLOCKQUOTE>
</LI>
</OL>
</BLOCKQUOTE>
</LI>
<LI><P class="first">For its execution <EM>after</EM> construction holds that:</P>
<BLOCKQUOTE>
<OL class="loweralpha simple">
<LI>each assertion is executed in order starting from the top <EM>including</EM> any part inherited,</LI>
<LI>if the class has any sub-classes, then the inherited portion is executed first,</LI>
<LI>if the class has several sub-classes the order of the classes in the base-clause is followed.</LI>
</OL>
</BLOCKQUOTE>
</LI>
</OL>
</DIV>
<DIV class="section" id="namespace-invariants">
<H2><A class="toc-backref" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#id34" name="namespace-invariants">2.5&nbsp;&nbsp;&nbsp;Namespace invariants</A></H2>
<P>To better support assertions at namespace scope or
function-scope we use namespace invariants:</P>
<BLOCKQUOTE>
<DL class="docutils">
<DT>syntax:    </DT>
<DD><OL class="first last arabic simple">
<LI><EM>namespace-invariant</EM>: <TT class="docutils literal"><SPAN class="pre">invariant</SPAN> <SPAN class="pre">{</SPAN></TT> <EM>assertion-sequence</EM> <TT class="docutils literal"><SPAN class="pre">}</SPAN></TT></LI>
</OL>
</DD>
</DL>
<P>example:</P>
<PRE class="literal-block">namespace foo
{
    int     buffer_size;
    int*    buffer;

    invariant
    {
        buffer_size &gt; 0;
        buffer     != 0;
        sizeof( int ) &gt;= 4 : "int must be 32 bit"; 
    }
    
    void foo()
    {
        int i = 0;
        for(;;)
        {
            invariant { i &lt; 10; }
            ...
        }
    }
}
</PRE>
</BLOCKQUOTE>
<P>The namespace invariants use the same syntax as the class invariant, 
but appears in different scopes and is called in different ways.</P>
<P>The properties of namespace invariants are:</P>
<OL class="arabic">
<LI><P class="first">they can appear multiple times in the same namespace across multiple translation units,</P>
</LI>
<LI><P class="first">for each translation unit, the present invariants are executed once 
after the static initialization phase, that is, conceptually as the 
last part of the static initialization phase,</P>
</LI>
<LI><P class="first">they are always called as if surrounded by a try-catch block:</P>
<PRE class="literal-block">try
{
    namespace_invariant(); // pseudo code
}
catch( ... )
{
    std::namespace_invariant_broken();
}
</PRE>
</LI>
<LI><P class="first">the order of evaluation of the invariants is unspecified,</P>
</LI>
<LI><P class="first">the order of evaluation of the assertions in an invariant is from top to bottom,</P>
</LI>
<LI><P class="first">for any namespace <TT class="docutils literal"><SPAN class="pre">N</SPAN></TT>, <TT class="docutils literal"><SPAN class="pre">N::invariant()</SPAN></TT> executes all invariants from namespace <TT class="docutils literal"><SPAN class="pre">N</SPAN></TT>.</P>
</LI>
</OL>
</DIV>
<DIV class="section" id="failure-handler-functions">
<H2><A class="toc-backref" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#id35" name="failure-handler-functions">2.6&nbsp;&nbsp;&nbsp;Failure handler functions</A></H2>
<P>The default behavior for all default assertions is to call <TT class="docutils literal"><SPAN class="pre">terminate()</SPAN></TT> via a call
to their respective handler. As seen below, we have a handler for each type of contract.
If the default behavior
is undesirable, the standard library provides the following handlers:</P>
<PRE class="literal-block">namespace std
{        
    void precondition_broken();
    void postcondition_broken();
    void class_invariant_broken();
    void namespace_invariant_broken();
    
    typedef void (*broken_contract_handler)();
    
    broken_contract_handler  set_precondition_broken_handler( broken_contract_handler r ) throw();
    broken_contract_handler  set_postcondition_broken_handler( broken_contract_handler r ) throw();
    broken_contract_handler  set_class_invariant_broken_handler( broken_contract_handler r ) throw();
    broken_contract_handler  set_namespace_invariant_broken_handler( broken_contract_handler r ) throw();
}
</PRE>
<P>This should provide plenty of room for customization. The precondition for all the <TT class="docutils literal"><SPAN class="pre">set_XX_handler</SPAN></TT>
functions should be <TT class="docutils literal"><SPAN class="pre">r</SPAN> <SPAN class="pre">!=</SPAN> <SPAN class="pre">0</SPAN></TT>.</P>
</DIV>
<DIV class="section" id="changes-to-the-standard-library">
<H2><A class="toc-backref" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#id36" name="changes-to-the-standard-library">2.7&nbsp;&nbsp;&nbsp;Changes to the standard library</A></H2>
<P>We suggest that no required changes should be made to
the standard library. An implementation is free to
implement all standard guarantees in terms of contract
code, but not required to.</P>
<!-- ======================================
IDEA PROPOSAL VERSUS STANDARDS CHANGES
======================================

This proposal presents ideas and syntax.  It is not itself a proposal
for changes in the text of the standard.  It is not yet time for text
changes.  The distinction enables us to mention the following two
subjects. -->
</DIV>
</DIV>
<DIV class="section" id="contracts-for-performance">
<H1><A class="toc-backref" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#id37" name="contracts-for-performance">3&nbsp;&nbsp;&nbsp;Contracts for performance</A></H1>
<P>This section discusses how contracts can help the compiler
to generate faster code.</P>
<P>A limited form of contract programming is the use of the <TT class="docutils literal"><SPAN class="pre">assert()</SPAN></TT>
macro.  Its use is standard practice in many software
projects.  Unfortunately, it suffers from several problems.  We
will evaluate these problems by distinguishing between a
library and its client.</P>
<DIV class="section" id="assert-is-evaluated-within-the-library">
<H2><A class="toc-backref" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#id38" name="assert-is-evaluated-within-the-library">3.1&nbsp;&nbsp;&nbsp;<TT class="docutils literal docutils literal"><SPAN class="pre">assert()</SPAN></TT> is evaluated within the library</A></H2>
<P>As a consequence, the enabling or disabling of
assertion checking is a compile-time decision of the
library.  The result is generally either</P>
<OL class="arabic simple">
<LI>no checking, in which case errors are lost, or</LI>
<LI>checking, in which case performance is lost.</LI>
</OL>
<P>In contrast, preconditions may be evaluated in the
client.  The client decides on the acceptable tradeoff
between performance and checking.</P>
</DIV>
<DIV class="section" id="assert-fails-to-distinguish-between-checking-arguments-and-validating-computations">
<H2><A class="toc-backref" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#id39" name="assert-fails-to-distinguish-between-checking-arguments-and-validating-computations">3.2&nbsp;&nbsp;&nbsp;<TT class="docutils literal docutils literal"><SPAN class="pre">assert()</SPAN></TT> fails to distinguish between checking arguments and validating computations</A></H2>
<P>In well-tested production code, validating computation
is rarely needed, because the function has proven
itself.  On the other hand, checking arguments has
continuing need because of the evolution of callers.
With only a single form, programmers that turn off
validating computation for performance, will also turn
off checking arguments.</P>
<P>In contrast, the proposed syntactic distinction between
preconditions, postconditions and invariants preserves the very
real need to enable them separately.</P>
</DIV>
<DIV class="section" id="assert-is-indistinguishable-from-regular-code">
<H2><A class="toc-backref" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#id40" name="assert-is-indistinguishable-from-regular-code">3.3&nbsp;&nbsp;&nbsp;<TT class="docutils literal docutils literal"><SPAN class="pre">assert()</SPAN></TT> is indistinguishable from regular code</A></H2>
<P>As a consequence it is very difficult for a compiler to
make use of the contents of an <TT class="docutils literal"><SPAN class="pre">assert()</SPAN></TT> macro.</P>
<P>In contrast, preconditions, postconditions and invariants are very
visible to the compiler.  The compiler can use preconditions
and postconditions as a constraint on the value-space of
the code, which in turn enables optimization.</P>
<P>Explicit preconditions and postconditions enable optimization
in two ways.</P>
<OL class="arabic">
<LI><P class="first">The compiler can eliminate conditions known statically.</P>
<BLOCKQUOTE>
<P>For example, given</P>
<PRE class="literal-block">char *foo()
postcondition( result ) { result != 0; };

void bar( char *arg )
precondition { arg != 0; }
...
bar( foo() )
</PRE>
<P>the compiler can propagate the postcondition of <TT class="docutils literal"><SPAN class="pre">foo()</SPAN></TT>
to the precondition of <TT class="docutils literal"><SPAN class="pre">bar()</SPAN></TT> and entirely eliminate
the precondition checking in <TT class="docutils literal"><SPAN class="pre">bar()</SPAN></TT>.</P>
</BLOCKQUOTE>
</LI>
<LI><P class="first">The compiler can use conditions to guide code generation.</P>
<BLOCKQUOTE>
<P>For example, given</P>
<PRE class="literal-block">double sum( int count, double array[] )
precondition { count % 4 == 0; }
{
    double accum = 0.0;
    for ( int i = 0; i &lt; count; i++ )
            accum += array[i];
    return accum;
}
</PRE>
<P>the compiler can unroll the loop four times, and avoid
generating the stuttering at the start of the loop.</P>
<P>Furthermore, given the same code but with a precondition of
<TT class="docutils literal"><SPAN class="pre">count</SPAN> <SPAN class="pre">&gt;</SPAN> <SPAN class="pre">1000</SPAN></TT>, the compiler could chose to implement the
loop in parallel.  Likewise, with <TT class="docutils literal"><SPAN class="pre">count&lt;</SPAN> <SPAN class="pre">100</SPAN></TT>, the
compiler may forgo any checking for the possibility of
parallelism.</P>
</BLOCKQUOTE>
</LI>
</OL>
<!-- ``assert()`` does not allow the compiler to warn about side-effects
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
</DIV>
</DIV>
<DIV class="section" id="implementation-model-for-contracts">
<H1><A class="toc-backref" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#id41" name="implementation-model-for-contracts">4&nbsp;&nbsp;&nbsp;Implementation model for contracts</A></H1>
<P>This section discusses the feasibility of
implementation.  We provide an
implementation model that is reasonable and consistent with the
above proposal.</P>
<P>Consider the function</P>
<PRE class="literal-block">int factorial( int n )
precondition 
{
    0 &lt;= n &amp;&amp; n &lt;= 12;
}
postcondition( result ) 
{
    result &gt;= 1;
}
{
    if ( n &lt; 2 )
        return 1;
    else
        return n * factorial( n - 1 );
}
</PRE>
<P>When all conditions are enabled, the compiler generates three
functions:</P>
<OL class="arabic">
<LI><P class="first">The <EM>core function</EM> without any condition checking.</P>
<BLOCKQUOTE>
<P>Call this function when compiler switches disable all
condition evaluation.</P>
</BLOCKQUOTE>
</LI>
<LI><P class="first">A <EM>postcondition evaluator</EM>, which calls core function and then
executes the postcondition.</P>
<BLOCKQUOTE>
<P>Call this function from normal code when the caller
evaluates the preconditions.</P>
</BLOCKQUOTE>
</LI>
<LI><P class="first">A <EM>precondition evaluator</EM>, which executes the precondition
and then calls the postcondition evaluator.</P>
<BLOCKQUOTE>
<P>Call this function when the caller does not or cannot
evaluate the preconditions. (Remark: the precondition evaluator
would for example be used when
a function is called via a function-pointer.)</P>
</BLOCKQUOTE>
</LI>
</OL>
<P>When postconditions are disabled, a library-build-time
decision, the first two functions above are identical, and may
be implemented as a single function with two labels.</P>
<P>When preconditions are disabled, a client-build-time decision,
the client simply calls the second function.</P>
<P>The evaluation of class invariants is dependent on the
evaluation of the preconditions and postconditions that call
them.  As an additional performance option, compilers can turn
of invariant evaluation while still enabling other conditions.</P>
<P>Furthermore, a compiler might choose to provide a switch for
generating a single call to the invariant in the constructor.</P>
</DIV>
<DIV class="section" id="open-issues">
<H1><A class="toc-backref" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#id42" name="open-issues">5&nbsp;&nbsp;&nbsp;Open issues</A></H1>
<UL class="simple">
<LI><A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#are-failure-handler-functions-wrongly-specified">Are failure handler functions wrongly specified?</A></LI>
</UL>
<DIV class="section" id="are-failure-handler-functions-wrongly-specified">
<H2><A class="toc-backref" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#id43" name="are-failure-handler-functions-wrongly-specified">5.1&nbsp;&nbsp;&nbsp;Are failure handler functions wrongly specified?</A></H2>
<P>Currently a <A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#failure-handler-functions">failure handler function</A> does not
allow one to</P>
<OL class="arabic simple">
<LI>see the context of the broken assertion, or</LI>
<LI>use other functions than free-standing functions.</LI>
</OL>
<P>It might be desirable to change the functions to</P>
<PRE class="literal-block">namespace std
{
    class assertion_context
    {
        contract_context( const char* where, const char* assertion ) throw();
        ~contract_context() throw();
        const char* context() const throw();
    };

    void precondition_broken( const assertion_context&amp; cc );
    // ... etc
}
</PRE>
<P>or even</P>
<PRE class="literal-block">namespace std
{
    extern std::function&lt; void ( const assertion_context&amp; ) &gt; precondition_broken;
    // ... etc
}
</PRE>
<P>This would hopefully ensure good error-messages.</P>
</DIV>
</DIV>
<DIV class="section" id="major-changes-from-n1773">
<H1><A name="major-changes-from-n1773">6&nbsp;&nbsp;&nbsp;Major changes from </A><A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html">n1773</A></H1>
<OL class="arabic">
<LI><P class="first">reformulated the syntax of <A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#static-assertions">static assertions</A> 
(no use of <TT class="docutils literal"><SPAN class="pre">static</SPAN></TT> keyword).</P>
</LI>
<LI><P class="first">reformulated the syntax of <A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#runtime-assertions">runtime assertions</A>
(we now allow importance ordering).</P>
</LI>
<LI><P class="first">the invariant mechanisms have been
merged (hence now much simpler).</P>
</LI>
<LI><P class="first">changed use of keyword:</P>
<BLOCKQUOTE>
<TABLE border="1" class="docutils">
<COLGROUP>
<COL width="44%">
<COL width="56%">
</COLGROUP>
<TBODY valign="top">
<TR><TD><P class="first last"><STRONG>before</STRONG></P>
</TD>
<TD><P class="first last"><STRONG>now</STRONG></P>
</TD>
</TR>
<TR><TD><P class="first last"><TT class="docutils literal"><SPAN class="pre">__old</SPAN></TT></P>
</TD>
<TD><P class="first last"><TT class="docutils literal"><SPAN class="pre">oldof</SPAN></TT></P>
</TD>
</TR>
</TBODY>
</TABLE>
</BLOCKQUOTE>
</LI>
</OL>
</DIV>
<DIV class="section" id="list-of-proposals-that-could-be-affected-by-this-proposal">
<H1><A class="toc-backref" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#id45" name="list-of-proposals-that-could-be-affected-by-this-proposal">7&nbsp;&nbsp;&nbsp;List of proposals that could be affected by this proposal</A></H1>
<OL class="arabic simple">
<LI>static assertions as described in <A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2004/n1617.html">n1617</A></LI>
<LI>concepts as described in <A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2003/n1510.pdf">n1510</A>, <A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2003/n1522.pdf">n1522</A>, <A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2003/n1536.pdf">n1536</A> and <A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1758.pdf">n1758</A></LI>
<LI>any proposal that seeks to enhance meta-programming capabilities</LI>
</OL>
</DIV>
<DIV class="section" id="implementability">
<H1><A class="toc-backref" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#id46" name="implementability">8&nbsp;&nbsp;&nbsp;Implementability</A></H1>
<P>We expect that it will take about 3 man months to implement the proposal without
dedicating any time to optimizations.</P>
</DIV>
<DIV class="section" id="alternative-syntax">
<H1><A class="toc-backref" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#id47" name="alternative-syntax">9&nbsp;&nbsp;&nbsp;Alternative syntax</A></H1>
<P>In Lillehammer it was suggested to
use normal C++ syntax for separation
of assertions. In particular it was suggested
to write an assertion-sequence as</P>
<PRE class="literal-block">{
    foo() &amp;&amp;
    bar() &amp;&amp;
    true;
}
</PRE>
<P>instead of</P>
<PRE class="literal-block">{
    foo();
    bar();
    true;
} 
</PRE>
<P>A full example have been made with the proposed
syntax (see <A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#vector-example-alternative-syntax-hpp">vector_example_alternative_syntax.hpp</A>).</P>
<P>It is quite obvious that this syntax has the following
drawbacks:</P>
<OL class="arabic simple">
<LI>it becomes harder for debuggers to break on
individual assertions, because the whole assertion-sequence
is a single statement</LI>
</OL>
<!--  -->
<OL class="arabic simple" start="2">
<LI>the ternary operator is harder to read than if-statements</LI>
</OL>
<!--  -->
<OL class="arabic simple" start="3">
<LI>the combination of <TT class="docutils literal"><SPAN class="pre">assertion</SPAN> <SPAN class="pre">:</SPAN> <SPAN class="pre">"string"</SPAN></TT> and
<TT class="docutils literal"><SPAN class="pre">assertion</SPAN> <SPAN class="pre">:</SPAN> <SPAN class="pre">2</SPAN></TT> do not look good.</LI>
</OL>
</DIV>
<DIV class="section" id="list-of-examples">
<H1><A class="toc-backref" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#id48" name="list-of-examples">10&nbsp;&nbsp;&nbsp;List of examples</A></H1>
<UL class="simple">
<LI><A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#vector-example-hpp">vector_example.hpp</A></LI>
<LI><A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#vector-example-alternative-syntax-hpp">vector_example_alternative_syntax.hpp</A></LI>
<LI><A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#subcontracting-example-hpp">subcontracting_example.hpp</A></LI>
</UL>
<DIV class="section" id="vector-example-hpp">
<H2><A class="toc-backref" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#id49" name="vector-example-hpp">10.1&nbsp;&nbsp;&nbsp;vector_example.hpp</A></H2>




<LINK rel="stylesheet" href="./Ottosen2005_Proposal_Rev3-n1866_files/style.css" type="text/css">



<PRE>
<SPAN class="comment">///////////////////////////////////////
// Tools
///////////////////////////////////////</SPAN>

<SPAN class="keyword">template</SPAN><SPAN class="special">&lt;</SPAN> <SPAN class="keyword">class</SPAN> <SPAN class="identifier">Iter</SPAN><SPAN class="special">,</SPAN> <SPAN class="keyword">class</SPAN> <SPAN class="identifier">T</SPAN> <SPAN class="special">&gt;</SPAN>
<SPAN class="keyword">bool</SPAN> <SPAN class="identifier">all_equals</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">Iter</SPAN> <SPAN class="identifier">first</SPAN><SPAN class="special">,</SPAN> <SPAN class="identifier">Iter</SPAN> <SPAN class="identifier">last</SPAN><SPAN class="special">,</SPAN> <SPAN class="keyword">const</SPAN> <SPAN class="identifier">T</SPAN><SPAN class="special">&amp;</SPAN> <SPAN class="identifier">val</SPAN> <SPAN class="special">)</SPAN>
<SPAN class="special">{</SPAN> <SPAN class="comment">/* for simplicity, let us assume T's can be compared */</SPAN> <SPAN class="special">}</SPAN>

<SPAN class="keyword">template</SPAN><SPAN class="special">&lt;</SPAN> <SPAN class="keyword">class</SPAN> <SPAN class="identifier">Iter</SPAN><SPAN class="special">,</SPAN> <SPAN class="keyword">class</SPAN> <SPAN class="identifier">Size</SPAN> <SPAN class="special">&gt;</SPAN>
<SPAN class="keyword">bool</SPAN> <SPAN class="identifier">equal_distance</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">Iter</SPAN> <SPAN class="identifier">first</SPAN><SPAN class="special">,</SPAN> <SPAN class="identifier">Iter</SPAN> <SPAN class="identifier">last</SPAN><SPAN class="special">,</SPAN> <SPAN class="identifier">Size</SPAN> <SPAN class="identifier">size</SPAN> <SPAN class="special">)</SPAN>
<SPAN class="special">{</SPAN> <SPAN class="comment">/* internal tagging mechnism so even input iterators can be passed */</SPAN> <SPAN class="special">}</SPAN>

<SPAN class="comment">///////////////////////////////////////
// New vector interface
///////////////////////////////////////</SPAN>

<SPAN class="keyword">template</SPAN><SPAN class="special">&lt;</SPAN> <SPAN class="keyword">class</SPAN> <SPAN class="identifier">T</SPAN><SPAN class="special">,</SPAN> <SPAN class="keyword">class</SPAN> <SPAN class="identifier">Alloc</SPAN> <SPAN class="special">=</SPAN> <SPAN class="identifier">allocator</SPAN><SPAN class="special">&lt;</SPAN><SPAN class="identifier">T</SPAN><SPAN class="special">&gt;</SPAN> <SPAN class="special">&gt;</SPAN>
<SPAN class="keyword">class</SPAN> <SPAN class="identifier">vector</SPAN> 
<SPAN class="special">{</SPAN>
    <SPAN class="keyword">invariant</SPAN>
    <SPAN class="special">{</SPAN>
	<SPAN class="identifier">is_assignable</SPAN><SPAN class="special">&lt;</SPAN><SPAN class="identifier">T</SPAN><SPAN class="special">&gt;::</SPAN><SPAN class="identifier">value</SPAN>         <SPAN class="special">:</SPAN> <SPAN class="string">"value_type must be Assignable"</SPAN> <SPAN class="special">;</SPAN>
	<SPAN class="identifier">is_copy_constructible</SPAN><SPAN class="special">&lt;</SPAN><SPAN class="identifier">T</SPAN><SPAN class="special">&gt;::</SPAN><SPAN class="identifier">value</SPAN> <SPAN class="special">:</SPAN> <SPAN class="string">"value_type must be CopyConstructible"</SPAN> <SPAN class="special">;</SPAN>

        <SPAN class="special">(</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">==</SPAN> <SPAN class="number">0</SPAN> <SPAN class="special">)</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">empty</SPAN><SPAN class="special">();</SPAN>
        <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">std</SPAN><SPAN class="special">::</SPAN><SPAN class="identifier">distance</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">begin</SPAN><SPAN class="special">(),</SPAN> <SPAN class="identifier">end</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">);</SPAN>
        <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">std</SPAN><SPAN class="special">::</SPAN><SPAN class="identifier">distance</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">rbegin</SPAN><SPAN class="special">(),</SPAN> <SPAN class="identifier">rend</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">);</SPAN>
        <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">&lt;=</SPAN> <SPAN class="identifier">capacity</SPAN><SPAN class="special">();</SPAN>
        <SPAN class="identifier">capacity</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">&lt;=</SPAN> <SPAN class="identifier">max_size</SPAN><SPAN class="special">();</SPAN>
    <SPAN class="special">}</SPAN>
    
    
<SPAN class="keyword">public</SPAN><SPAN class="special">:</SPAN>
    <SPAN class="keyword">typedef</SPAN> <SPAN class="identifier">Alloc</SPAN>                             <SPAN class="identifier">allocator_type</SPAN><SPAN class="special">;</SPAN>
    <SPAN class="keyword">typedef</SPAN> <SPAN class="keyword">typename</SPAN> <SPAN class="identifier">Alloc</SPAN><SPAN class="special">::</SPAN><SPAN class="identifier">pointer</SPAN>           <SPAN class="identifier">pointer</SPAN><SPAN class="special">;</SPAN>
    <SPAN class="keyword">typedef</SPAN> <SPAN class="keyword">typename</SPAN> <SPAN class="identifier">Alloc</SPAN><SPAN class="special">::</SPAN><SPAN class="identifier">const_pointer</SPAN>     <SPAN class="identifier">const_pointer</SPAN><SPAN class="special">;</SPAN>
    <SPAN class="keyword">typedef</SPAN> <SPAN class="keyword">typename</SPAN> <SPAN class="identifier">Alloc</SPAN><SPAN class="special">::</SPAN><SPAN class="identifier">reference</SPAN>         <SPAN class="identifier">reference</SPAN><SPAN class="special">;</SPAN>
    <SPAN class="keyword">typedef</SPAN> <SPAN class="keyword">typename</SPAN> <SPAN class="identifier">Alloc</SPAN><SPAN class="special">::</SPAN><SPAN class="identifier">const_reference</SPAN>   <SPAN class="identifier">const_reference</SPAN><SPAN class="special">;</SPAN>
    <SPAN class="keyword">typedef</SPAN> <SPAN class="keyword">typename</SPAN> <SPAN class="identifier">Alloc</SPAN><SPAN class="special">::</SPAN><SPAN class="identifier">value_type</SPAN>        <SPAN class="identifier">value_type</SPAN><SPAN class="special">;</SPAN>
    <SPAN class="keyword">typedef</SPAN> <SPAN class="special">...</SPAN>                               <SPAN class="identifier">iterator</SPAN><SPAN class="special">;</SPAN>
    <SPAN class="keyword">typedef</SPAN> <SPAN class="special">...</SPAN>                               <SPAN class="identifier">const_iterator</SPAN><SPAN class="special">;</SPAN>
    <SPAN class="keyword">typedef</SPAN> <SPAN class="special">...</SPAN>                               <SPAN class="identifier">size_type</SPAN><SPAN class="special">;</SPAN>
    <SPAN class="keyword">typedef</SPAN> <SPAN class="special">...</SPAN>                               <SPAN class="identifier">difference_type</SPAN><SPAN class="special">;</SPAN>
    <SPAN class="keyword">typedef</SPAN> <SPAN class="identifier">reverse_iterator</SPAN><SPAN class="special">&lt;</SPAN><SPAN class="identifier">iterator</SPAN><SPAN class="special">&gt;</SPAN>        <SPAN class="identifier">reverse_iterator</SPAN><SPAN class="special">;</SPAN>
    <SPAN class="keyword">typedef</SPAN> <SPAN class="identifier">reverse_iterator</SPAN><SPAN class="special">&lt;</SPAN><SPAN class="identifier">const_iterator</SPAN><SPAN class="special">&gt;</SPAN>  <SPAN class="identifier">const_reverse_iterator</SPAN><SPAN class="special">;</SPAN>

             <SPAN class="identifier">vector</SPAN><SPAN class="special">()</SPAN>                  
                 <SPAN class="keyword">postcondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="identifier">empty</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN> 
                 
    <SPAN class="keyword">explicit</SPAN> <SPAN class="identifier">vector</SPAN><SPAN class="special">(</SPAN> <SPAN class="keyword">const</SPAN> <SPAN class="identifier">Alloc</SPAN><SPAN class="special">&amp;</SPAN> <SPAN class="identifier">al</SPAN> <SPAN class="special">)</SPAN> 
                 <SPAN class="keyword">postcondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="identifier">empty</SPAN><SPAN class="special">();</SPAN> 
                                 <SPAN class="identifier">al</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">get_allocator</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
                 
    <SPAN class="keyword">explicit</SPAN> <SPAN class="identifier">vector</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">size_type</SPAN> <SPAN class="identifier">count</SPAN> <SPAN class="special">)</SPAN> 
                 <SPAN class="keyword">postcondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">count</SPAN><SPAN class="special">;</SPAN> 
                                 <SPAN class="identifier">all_equals</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">begin</SPAN><SPAN class="special">(),</SPAN> <SPAN class="identifier">end</SPAN><SPAN class="special">(),</SPAN> <SPAN class="identifier">T</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">);</SPAN> <SPAN class="special">}</SPAN>
                 
             <SPAN class="identifier">vector</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">size_type</SPAN> <SPAN class="identifier">count</SPAN><SPAN class="special">,</SPAN> <SPAN class="keyword">const</SPAN> <SPAN class="identifier">T</SPAN><SPAN class="special">&amp;</SPAN> <SPAN class="identifier">val</SPAN> <SPAN class="special">)</SPAN> 
                 <SPAN class="keyword">postcondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">count</SPAN><SPAN class="special">;</SPAN> 
                                 <SPAN class="identifier">all_equals</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">begin</SPAN><SPAN class="special">(),</SPAN> <SPAN class="identifier">end</SPAN><SPAN class="special">(),</SPAN> <SPAN class="identifier">val</SPAN> <SPAN class="special">);</SPAN> <SPAN class="special">}</SPAN>
             
             <SPAN class="identifier">vector</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">size_type</SPAN> <SPAN class="identifier">count</SPAN><SPAN class="special">,</SPAN> <SPAN class="keyword">const</SPAN> <SPAN class="identifier">T</SPAN><SPAN class="special">&amp;</SPAN> <SPAN class="identifier">val</SPAN><SPAN class="special">,</SPAN> <SPAN class="keyword">const</SPAN> <SPAN class="identifier">Alloc</SPAN><SPAN class="special">&amp;</SPAN> <SPAN class="identifier">al</SPAN> <SPAN class="special">)</SPAN> 
                 <SPAN class="keyword">postcondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="identifier">size</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">count</SPAN><SPAN class="special">;</SPAN> 
                                 <SPAN class="identifier">all_equals</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">begin</SPAN><SPAN class="special">(),</SPAN> <SPAN class="identifier">end</SPAN><SPAN class="special">(),</SPAN> <SPAN class="identifier">val</SPAN> <SPAN class="special">);</SPAN> 
                                 <SPAN class="identifier">al</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">get_allocator</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}:</SPAN>
             
             <SPAN class="identifier">vector</SPAN><SPAN class="special">(</SPAN> <SPAN class="keyword">const</SPAN> <SPAN class="identifier">vector</SPAN><SPAN class="special">&amp;</SPAN> <SPAN class="identifier">right</SPAN> <SPAN class="special">)</SPAN> 
                 <SPAN class="keyword">postcondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="identifier">right</SPAN> <SPAN class="special">==</SPAN> <SPAN class="special">*</SPAN><SPAN class="keyword">this</SPAN><SPAN class="special">;</SPAN> <SPAN class="special">}</SPAN>
    
             <SPAN class="keyword">template</SPAN><SPAN class="special">&lt;</SPAN> <SPAN class="keyword">class</SPAN> <SPAN class="identifier">InIt</SPAN> <SPAN class="special">&gt;</SPAN>
             <SPAN class="identifier">vector</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">InIt</SPAN> <SPAN class="identifier">first</SPAN><SPAN class="special">,</SPAN> <SPAN class="identifier">InIt</SPAN> <SPAN class="identifier">last</SPAN> <SPAN class="special">)</SPAN> 
                 <SPAN class="keyword">precondition</SPAN>  <SPAN class="special">{</SPAN> <SPAN class="identifier">is_input_iterator</SPAN><SPAN class="special">&lt;</SPAN><SPAN class="identifier">InIt</SPAN><SPAN class="special">&gt;::</SPAN><SPAN class="identifier">value</SPAN> <SPAN class="special">:</SPAN> <SPAN class="string">"Iterator argument must model an InputIterator"</SPAN><SPAN class="special">;</SPAN> <SPAN class="special">}</SPAN>
                 <SPAN class="keyword">postcondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="identifier">equal_distance</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">first</SPAN><SPAN class="special">,</SPAN> <SPAN class="identifier">last</SPAN><SPAN class="special">,</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">);</SPAN> <SPAN class="special">}</SPAN>
                 
             <SPAN class="keyword">template</SPAN><SPAN class="special">&lt;</SPAN> <SPAN class="keyword">class</SPAN> <SPAN class="identifier">InIt</SPAN> <SPAN class="special">&gt;</SPAN>
             <SPAN class="identifier">vector</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">InIt</SPAN> <SPAN class="identifier">first</SPAN><SPAN class="special">,</SPAN> <SPAN class="identifier">InIt</SPAN> <SPAN class="identifier">last</SPAN><SPAN class="special">,</SPAN> <SPAN class="keyword">const</SPAN> <SPAN class="identifier">Alloc</SPAN><SPAN class="special">&amp;</SPAN> <SPAN class="identifier">al</SPAN> <SPAN class="special">);</SPAN>
                 <SPAN class="keyword">precondition</SPAN>  <SPAN class="special">{</SPAN> <SPAN class="identifier">is_input_iterator</SPAN><SPAN class="special">&lt;</SPAN><SPAN class="identifier">InIt</SPAN><SPAN class="special">&gt;::</SPAN><SPAN class="identifier">value</SPAN> <SPAN class="special">:</SPAN> <SPAN class="string">"Iterator argument must model an InputIterator"</SPAN><SPAN class="special">;</SPAN> <SPAN class="special">}</SPAN>
                 <SPAN class="keyword">postcondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="identifier">equal_distance</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">first</SPAN><SPAN class="special">,</SPAN> <SPAN class="identifier">last</SPAN><SPAN class="special">,</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">);</SPAN> 
                                 <SPAN class="identifier">al</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">get_allocator</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>

             <SPAN class="keyword">void</SPAN> <SPAN class="identifier">reserve</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">size_type</SPAN> <SPAN class="identifier">count</SPAN> <SPAN class="special">)</SPAN> 
                 <SPAN class="keyword">precondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="identifier">count</SPAN> <SPAN class="special">&lt;</SPAN> <SPAN class="identifier">max_size</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
                 <SPAN class="keyword">postcondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="identifier">capacity</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">&gt;=</SPAN> <SPAN class="identifier">count</SPAN><SPAN class="special">;</SPAN> <SPAN class="special">}</SPAN>
                 
             <SPAN class="identifier">size_type</SPAN> <SPAN class="identifier">capacity</SPAN><SPAN class="special">()</SPAN> <SPAN class="keyword">const</SPAN><SPAN class="special">;</SPAN>
                 <SPAN class="keyword">postcondition</SPAN><SPAN class="special">(</SPAN> <SPAN class="keyword">result</SPAN> <SPAN class="special">)</SPAN> <SPAN class="special">{</SPAN> <SPAN class="keyword">result</SPAN> <SPAN class="special">&gt;=</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
                 
             <SPAN class="identifier">iterator</SPAN> <SPAN class="identifier">begin</SPAN><SPAN class="special">()</SPAN>
                 <SPAN class="keyword">postcondition</SPAN><SPAN class="special">(</SPAN> <SPAN class="keyword">result</SPAN> <SPAN class="special">)</SPAN> <SPAN class="special">{</SPAN> <SPAN class="keyword">if</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">empty</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">)</SPAN> <SPAN class="keyword">result</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">end</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
             
             <SPAN class="identifier">const_iterator</SPAN> <SPAN class="identifier">begin</SPAN><SPAN class="special">()</SPAN> <SPAN class="keyword">const</SPAN>
                 <SPAN class="keyword">postcondition</SPAN><SPAN class="special">(</SPAN> <SPAN class="keyword">result</SPAN> <SPAN class="special">)</SPAN> <SPAN class="special">{</SPAN> <SPAN class="keyword">if</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">empty</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">)</SPAN> <SPAN class="keyword">result</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">end</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
             
             <SPAN class="identifier">iterator</SPAN> <SPAN class="identifier">end</SPAN><SPAN class="special">();</SPAN>
             <SPAN class="identifier">const_iterator</SPAN> <SPAN class="identifier">end</SPAN><SPAN class="special">()</SPAN> <SPAN class="keyword">const</SPAN><SPAN class="special">;</SPAN>
             
             <SPAN class="identifier">reverse_iterator</SPAN> <SPAN class="identifier">rbegin</SPAN><SPAN class="special">()</SPAN>
                 <SPAN class="keyword">postcondition</SPAN><SPAN class="special">(</SPAN> <SPAN class="keyword">result</SPAN> <SPAN class="special">)</SPAN> <SPAN class="special">{</SPAN> <SPAN class="keyword">if</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">empty</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">)</SPAN> <SPAN class="keyword">result</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">rend</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
             
             <SPAN class="identifier">const_reverse_iterator</SPAN> <SPAN class="identifier">rbegin</SPAN><SPAN class="special">()</SPAN> <SPAN class="keyword">const</SPAN>
                 <SPAN class="keyword">postcondition</SPAN><SPAN class="special">(</SPAN> <SPAN class="keyword">result</SPAN> <SPAN class="special">)</SPAN> <SPAN class="special">{</SPAN> <SPAN class="keyword">if</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">empty</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">)</SPAN> <SPAN class="keyword">result</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">rend</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
             
             <SPAN class="identifier">reverse_iterator</SPAN> <SPAN class="identifier">rend</SPAN><SPAN class="special">();</SPAN>
             <SPAN class="identifier">const_reverse_iterator</SPAN> <SPAN class="identifier">rend</SPAN><SPAN class="special">()</SPAN> <SPAN class="keyword">const</SPAN><SPAN class="special">;</SPAN>
             
             <SPAN class="keyword">void</SPAN> <SPAN class="identifier">resize</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">size_type</SPAN> <SPAN class="identifier">newsize</SPAN> <SPAN class="special">)</SPAN>
                 <SPAN class="keyword">postcondition</SPAN> <SPAN class="comment">// version 1: with an if</SPAN>
                 <SPAN class="special">{</SPAN> 
                     <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">newsize</SPAN><SPAN class="special">;</SPAN> 
                     <SPAN class="keyword">if</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">newsize</SPAN> <SPAN class="special">&gt;</SPAN> <SPAN class="identifier">oldof</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">)</SPAN>
                         <SPAN class="identifier">all_equals</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">begin</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">+</SPAN> <SPAN class="identifier">oldof</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">(),</SPAN> <SPAN class="identifier">end</SPAN><SPAN class="special">(),</SPAN> <SPAN class="identifier">T</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">);</SPAN>
                 <SPAN class="special">}</SPAN>
             
             <SPAN class="keyword">void</SPAN> <SPAN class="identifier">resize</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">size_type</SPAN> <SPAN class="identifier">newsize</SPAN><SPAN class="special">,</SPAN> <SPAN class="identifier">T</SPAN> <SPAN class="identifier">val</SPAN> <SPAN class="special">)</SPAN>
                 <SPAN class="keyword">postcondition</SPAN> <SPAN class="comment">// version 2: with ternary operator</SPAN>
                 <SPAN class="special">{</SPAN>
                     <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">newsize</SPAN><SPAN class="special">;</SPAN> 
                     <SPAN class="identifier">newsize</SPAN> <SPAN class="special">&gt;</SPAN> <SPAN class="identifier">oldof</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">())</SPAN> <SPAN class="special">?</SPAN> 
                         <SPAN class="identifier">all_equals</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">begin</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">+</SPAN> <SPAN class="identifier">oldof</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">(),</SPAN> <SPAN class="identifier">end</SPAN><SPAN class="special">(),</SPAN> <SPAN class="identifier">val</SPAN> <SPAN class="special">)</SPAN> <SPAN class="special">:</SPAN> <SPAN class="keyword">true</SPAN><SPAN class="special">;</SPAN>
                 <SPAN class="special">}</SPAN>
         
             <SPAN class="identifier">size_type</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="keyword">const</SPAN>
                 <SPAN class="keyword">postcondition</SPAN><SPAN class="special">(</SPAN> <SPAN class="keyword">result</SPAN> <SPAN class="special">)</SPAN> <SPAN class="special">{</SPAN> <SPAN class="keyword">result</SPAN> <SPAN class="special">&lt;=</SPAN> <SPAN class="identifier">capacity</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
                 
             <SPAN class="identifier">size_type</SPAN> <SPAN class="identifier">max_size</SPAN><SPAN class="special">()</SPAN> <SPAN class="keyword">const</SPAN>
                 <SPAN class="keyword">postcondition</SPAN><SPAN class="special">(</SPAN> <SPAN class="keyword">result</SPAN> <SPAN class="special">)</SPAN> <SPAN class="special">{</SPAN> <SPAN class="keyword">result</SPAN> <SPAN class="special">&gt;=</SPAN> <SPAN class="identifier">capacity</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
             
             <SPAN class="keyword">bool</SPAN> <SPAN class="identifier">empty</SPAN><SPAN class="special">()</SPAN> <SPAN class="keyword">const</SPAN>
                 <SPAN class="keyword">postcondition</SPAN><SPAN class="special">(</SPAN> <SPAN class="keyword">result</SPAN> <SPAN class="special">)</SPAN> <SPAN class="special">{</SPAN> <SPAN class="keyword">result</SPAN> <SPAN class="special">==</SPAN> <SPAN class="special">(</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">==</SPAN> <SPAN class="number">0</SPAN> <SPAN class="special">);</SPAN> <SPAN class="special">}</SPAN>
             
             <SPAN class="identifier">Alloc</SPAN> <SPAN class="identifier">get_allocator</SPAN><SPAN class="special">()</SPAN> <SPAN class="keyword">const</SPAN><SPAN class="special">;</SPAN>
             
             <SPAN class="identifier">reference</SPAN> <SPAN class="identifier">at</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">size_type</SPAN> <SPAN class="identifier">off</SPAN> <SPAN class="special">);</SPAN>
                 <SPAN class="keyword">precondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="identifier">off</SPAN> <SPAN class="special">&lt;</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
             
             <SPAN class="identifier">const_reference</SPAN> <SPAN class="identifier">at</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">size_type</SPAN> <SPAN class="identifier">off</SPAN> <SPAN class="special">)</SPAN> <SPAN class="keyword">const</SPAN><SPAN class="special">;</SPAN>
                 <SPAN class="keyword">precondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="identifier">off</SPAN> <SPAN class="special">&lt;</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
                 
             <SPAN class="identifier">reference</SPAN> <SPAN class="keyword">operator</SPAN><SPAN class="special">[](</SPAN> <SPAN class="identifier">size_type</SPAN> <SPAN class="identifier">off</SPAN> <SPAN class="special">)</SPAN>
                 <SPAN class="keyword">precondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="identifier">off</SPAN> <SPAN class="special">&lt;</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>

             <SPAN class="identifier">const_reference</SPAN> <SPAN class="keyword">operator</SPAN><SPAN class="special">[](</SPAN> <SPAN class="identifier">size_type</SPAN> <SPAN class="identifier">off</SPAN> <SPAN class="special">)</SPAN>
                 <SPAN class="keyword">precondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="identifier">off</SPAN> <SPAN class="special">&lt;</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
    
             <SPAN class="identifier">reference</SPAN> <SPAN class="identifier">front</SPAN><SPAN class="special">();</SPAN>
                 <SPAN class="keyword">precondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="keyword">not</SPAN> <SPAN class="identifier">empty</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
             
             <SPAN class="identifier">const_reference</SPAN> <SPAN class="identifier">front</SPAN><SPAN class="special">()</SPAN> <SPAN class="keyword">const</SPAN><SPAN class="special">;</SPAN>
                 <SPAN class="keyword">precondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="keyword">not</SPAN> <SPAN class="identifier">empty</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
    
             <SPAN class="identifier">reference</SPAN> <SPAN class="identifier">back</SPAN><SPAN class="special">()</SPAN>
                 <SPAN class="keyword">precondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="keyword">not</SPAN> <SPAN class="identifier">empty</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
             
             <SPAN class="identifier">const_reference</SPAN> <SPAN class="identifier">back</SPAN><SPAN class="special">()</SPAN> <SPAN class="keyword">const</SPAN><SPAN class="special">;</SPAN>
                 <SPAN class="keyword">precondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="keyword">not</SPAN> <SPAN class="identifier">empty</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
                 
             <SPAN class="keyword">void</SPAN> <SPAN class="identifier">push_back</SPAN><SPAN class="special">(</SPAN> <SPAN class="keyword">const</SPAN> <SPAN class="identifier">T</SPAN><SPAN class="special">&amp;</SPAN> <SPAN class="identifier">val</SPAN> <SPAN class="special">)</SPAN>
                 <SPAN class="keyword">precondition</SPAN>  <SPAN class="special">{</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">&lt;</SPAN> <SPAN class="identifier">max_size</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
                 <SPAN class="keyword">postcondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="identifier">back</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">val</SPAN><SPAN class="special">;</SPAN> 
                                 <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">oldof</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">+</SPAN> <SPAN class="number">1</SPAN><SPAN class="special">;</SPAN> 
                                 <SPAN class="identifier">capacity</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">&gt;=</SPAN> <SPAN class="identifier">oldof</SPAN> <SPAN class="identifier">capacity</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
                 
             <SPAN class="keyword">void</SPAN> <SPAN class="identifier">pop_back</SPAN><SPAN class="special">()</SPAN>
                 <SPAN class="keyword">precondition</SPAN>  <SPAN class="special">{</SPAN> <SPAN class="keyword">not</SPAN> <SPAN class="identifier">empty</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
                 <SPAN class="keyword">postcondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">oldof</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">-</SPAN> <SPAN class="number">1</SPAN><SPAN class="special">;</SPAN> <SPAN class="special">}</SPAN>
             
             <SPAN class="keyword">template</SPAN><SPAN class="special">&lt;</SPAN> <SPAN class="keyword">class</SPAN> <SPAN class="identifier">InIt</SPAN> <SPAN class="special">&gt;</SPAN>
             <SPAN class="keyword">void</SPAN> <SPAN class="identifier">assign</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">InIt</SPAN> <SPAN class="identifier">first</SPAN><SPAN class="special">,</SPAN> <SPAN class="identifier">InIt</SPAN> <SPAN class="identifier">last</SPAN> <SPAN class="special">)</SPAN>
                 <SPAN class="keyword">precondition</SPAN>  
                 <SPAN class="special">{</SPAN>
                     <SPAN class="identifier">is_input_iterator</SPAN><SPAN class="special">&lt;</SPAN><SPAN class="identifier">InIt</SPAN><SPAN class="special">&gt;::</SPAN><SPAN class="identifier">value</SPAN> <SPAN class="special">:</SPAN> <SPAN class="string">"Iterator argument must model an InputIterator"</SPAN><SPAN class="special">;</SPAN> 
                     <SPAN class="string">"The range [first,last) is not a sub-range of [begin(),end())"</SPAN><SPAN class="special">;</SPAN>
                 <SPAN class="special">}</SPAN>
                 <SPAN class="keyword">postcondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="identifier">equal_distance</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">first</SPAN><SPAN class="special">,</SPAN> <SPAN class="identifier">last</SPAN><SPAN class="special">,</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">);</SPAN> <SPAN class="special">}</SPAN>
             
             <SPAN class="keyword">void</SPAN> <SPAN class="identifier">assign</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">size_type</SPAN> <SPAN class="identifier">count</SPAN><SPAN class="special">,</SPAN> <SPAN class="keyword">const</SPAN> <SPAN class="identifier">T</SPAN><SPAN class="special">&amp;</SPAN> <SPAN class="identifier">val</SPAN> <SPAN class="special">)</SPAN>
                 <SPAN class="keyword">precondition</SPAN>  <SPAN class="special">{</SPAN> <SPAN class="identifier">count</SPAN> <SPAN class="special">&lt;=</SPAN> <SPAN class="identifier">max_size</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
                 <SPAN class="keyword">postcondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="identifier">all_equals</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">begin</SPAN><SPAN class="special">(),</SPAN> <SPAN class="identifier">end</SPAN><SPAN class="special">(),</SPAN> <SPAN class="identifier">val</SPAN> <SPAN class="special">);</SPAN> <SPAN class="special">}</SPAN>
                 
             <SPAN class="identifier">iterator</SPAN> <SPAN class="identifier">insert</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">iterator</SPAN> <SPAN class="identifier">where</SPAN><SPAN class="special">,</SPAN> <SPAN class="keyword">const</SPAN> <SPAN class="identifier">T</SPAN><SPAN class="special">&amp;</SPAN> <SPAN class="identifier">val</SPAN> <SPAN class="special">)</SPAN>
                 <SPAN class="keyword">precondition</SPAN>  <SPAN class="special">{</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">&lt;</SPAN> <SPAN class="identifier">max_size</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
                 <SPAN class="keyword">postcondition</SPAN><SPAN class="special">(</SPAN> <SPAN class="keyword">result</SPAN> <SPAN class="special">)</SPAN> 
                 <SPAN class="special">{</SPAN>
                     <SPAN class="special">*</SPAN><SPAN class="keyword">result</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">val</SPAN><SPAN class="special">;</SPAN>
                     <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN>  <SPAN class="special">==</SPAN> <SPAN class="identifier">oldof</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">+</SPAN> <SPAN class="number">1</SPAN><SPAN class="special">;</SPAN>
                     <SPAN class="identifier">capacity</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">&gt;=</SPAN> <SPAN class="identifier">oldof</SPAN> <SPAN class="identifier">capacity</SPAN><SPAN class="special">();</SPAN>
                     
                     <SPAN class="keyword">if</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">capacity</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">&gt;</SPAN> <SPAN class="identifier">oldof</SPAN> <SPAN class="identifier">capacity</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">)</SPAN>
                         <SPAN class="string">"All iterators have been invalidated"</SPAN><SPAN class="special">;</SPAN>
                     <SPAN class="keyword">else</SPAN>
                         <SPAN class="string">"All iterators in the range [where,end()) have been invalidated"</SPAN><SPAN class="special">;</SPAN>
                 <SPAN class="special">}</SPAN>
             
             <SPAN class="keyword">void</SPAN> <SPAN class="identifier">insert</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">iterator</SPAN> <SPAN class="identifier">where</SPAN><SPAN class="special">,</SPAN> <SPAN class="identifier">size_type</SPAN> <SPAN class="identifier">count</SPAN><SPAN class="special">,</SPAN> <SPAN class="keyword">const</SPAN> <SPAN class="identifier">T</SPAN><SPAN class="special">&amp;</SPAN> <SPAN class="identifier">val</SPAN> <SPAN class="special">)</SPAN>
                 <SPAN class="keyword">precondition</SPAN>  <SPAN class="special">{</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">+</SPAN> <SPAN class="identifier">count</SPAN> <SPAN class="special">&lt;=</SPAN> <SPAN class="identifier">max_size</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
                 <SPAN class="keyword">postcondition</SPAN> 
                 <SPAN class="special">{</SPAN>
                     <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">oldof</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">+</SPAN> <SPAN class="identifier">count</SPAN><SPAN class="special">;</SPAN>
                     <SPAN class="identifier">capacity</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">&gt;=</SPAN> <SPAN class="identifier">oldof</SPAN> <SPAN class="identifier">capacity</SPAN><SPAN class="special">();</SPAN>
                     
                     <SPAN class="keyword">if</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">capacity</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">oldof</SPAN> <SPAN class="identifier">capacity</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">)</SPAN>
                     <SPAN class="special">{</SPAN>
                         <SPAN class="identifier">all_equals</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">oldof</SPAN> <SPAN class="identifier">prior</SPAN><SPAN class="special">(</SPAN><SPAN class="identifier">where</SPAN><SPAN class="special">),</SPAN> <SPAN class="identifier">oldof</SPAN> <SPAN class="identifier">prior</SPAN><SPAN class="special">(</SPAN><SPAN class="identifier">where</SPAN><SPAN class="special">)</SPAN> <SPAN class="special">+</SPAN> <SPAN class="identifier">count</SPAN><SPAN class="special">,</SPAN> <SPAN class="identifier">val</SPAN> <SPAN class="special">);</SPAN>
                         <SPAN class="string">"All iterators in the range [where,end()) have been invalidated"</SPAN><SPAN class="special">;</SPAN>
                     <SPAN class="special">}</SPAN>
                     <SPAN class="keyword">else</SPAN>
                         <SPAN class="string">"All iterators have been invalidated"</SPAN><SPAN class="special">;</SPAN>
                 <SPAN class="special">}</SPAN>
                 
             <SPAN class="keyword">template</SPAN><SPAN class="special">&lt;</SPAN> <SPAN class="keyword">class</SPAN> <SPAN class="identifier">InIt</SPAN> <SPAN class="special">&gt;</SPAN>
             <SPAN class="keyword">void</SPAN> <SPAN class="identifier">insert</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">iterator</SPAN> <SPAN class="identifier">where</SPAN><SPAN class="special">,</SPAN> <SPAN class="identifier">InIt</SPAN> <SPAN class="identifier">first</SPAN><SPAN class="special">,</SPAN> <SPAN class="identifier">InIt</SPAN> <SPAN class="identifier">last</SPAN> <SPAN class="special">)</SPAN>
                 <SPAN class="keyword">precondition</SPAN>  
                 <SPAN class="special">{</SPAN> 
                     <SPAN class="identifier">is_input_iterator</SPAN><SPAN class="special">&lt;</SPAN><SPAN class="identifier">InIt</SPAN><SPAN class="special">&gt;::</SPAN><SPAN class="identifier">value</SPAN> <SPAN class="special">:</SPAN> <SPAN class="string">"Iterator argument must model an InputIterator"</SPAN><SPAN class="special">;</SPAN>
                     <SPAN class="string">"The range [first,last) is not a sub-range of [begin(),end())"</SPAN><SPAN class="special">;</SPAN>
                     <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">+</SPAN> <SPAN class="identifier">count</SPAN> <SPAN class="special">&lt;=</SPAN> <SPAN class="identifier">max_size</SPAN><SPAN class="special">();</SPAN> 
                 <SPAN class="special">}</SPAN>
                 <SPAN class="keyword">postcondition</SPAN>
                 <SPAN class="special">{</SPAN>
                     <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">oldof</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">+</SPAN> <SPAN class="identifier">count</SPAN><SPAN class="special">;</SPAN>
                     <SPAN class="identifier">capacity</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">&gt;=</SPAN> <SPAN class="identifier">oldof</SPAN> <SPAN class="identifier">capacity</SPAN><SPAN class="special">();</SPAN>
        
                     <SPAN class="keyword">if</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">capacity</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">oldof</SPAN> <SPAN class="identifier">capacity</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">)</SPAN>
                     <SPAN class="special">{</SPAN>
                         <SPAN class="identifier">all_equals</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">oldof</SPAN> <SPAN class="identifier">prior</SPAN><SPAN class="special">(</SPAN><SPAN class="identifier">where</SPAN><SPAN class="special">),</SPAN> <SPAN class="identifier">oldof</SPAN> <SPAN class="identifier">prior</SPAN><SPAN class="special">(</SPAN><SPAN class="identifier">where</SPAN><SPAN class="special">)</SPAN> <SPAN class="special">+</SPAN> <SPAN class="identifier">count</SPAN><SPAN class="special">,</SPAN> <SPAN class="identifier">val</SPAN> <SPAN class="special">);</SPAN>
                         <SPAN class="string">"All iterators in the range [where,end()) have been invalidated"</SPAN><SPAN class="special">;</SPAN>
                     <SPAN class="special">}</SPAN>
                     <SPAN class="keyword">else</SPAN>
                         <SPAN class="string">"All iterators have been invalidated"</SPAN><SPAN class="special">;</SPAN>
                 <SPAN class="special">}</SPAN>

             <SPAN class="identifier">iterator</SPAN> <SPAN class="identifier">erase</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">iterator</SPAN> <SPAN class="identifier">where</SPAN> <SPAN class="special">);</SPAN>
                 <SPAN class="keyword">precondition</SPAN>  
                 <SPAN class="special">{</SPAN> 
                     <SPAN class="keyword">not</SPAN> <SPAN class="identifier">empty</SPAN><SPAN class="special">();</SPAN> 
                     <SPAN class="identifier">where</SPAN> <SPAN class="special">!=</SPAN> <SPAN class="identifier">end</SPAN><SPAN class="special">();</SPAN>
                 <SPAN class="special">}</SPAN>
                 <SPAN class="keyword">postcondition</SPAN><SPAN class="special">(</SPAN> <SPAN class="keyword">result</SPAN> <SPAN class="special">)</SPAN> 
                 <SPAN class="special">{</SPAN>
                      <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">oldof</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">-</SPAN> <SPAN class="number">1</SPAN><SPAN class="special">;</SPAN> 
                      <SPAN class="keyword">if</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">empty</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">)</SPAN>
                          <SPAN class="keyword">result</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">end</SPAN><SPAN class="special">();</SPAN>
                      <SPAN class="string">"All iterators in the range [where,end()) have been invalidated"</SPAN><SPAN class="special">;</SPAN>
                 <SPAN class="special">}</SPAN>
                 
             <SPAN class="identifier">iterator</SPAN> <SPAN class="identifier">erase</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">iterator</SPAN> <SPAN class="identifier">first</SPAN><SPAN class="special">,</SPAN> <SPAN class="identifier">iterator</SPAN> <SPAN class="identifier">last</SPAN> <SPAN class="special">)</SPAN>
                 <SPAN class="keyword">precondition</SPAN>  <SPAN class="special">{</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">&gt;=</SPAN> <SPAN class="identifier">std</SPAN><SPAN class="special">::</SPAN><SPAN class="identifier">distance</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">first</SPAN><SPAN class="special">,</SPAN> <SPAN class="identifier">last</SPAN> <SPAN class="special">);</SPAN> <SPAN class="special">}</SPAN>
                 <SPAN class="keyword">postcondition</SPAN><SPAN class="special">(</SPAN> <SPAN class="keyword">result</SPAN> <SPAN class="special">)</SPAN> 
                 <SPAN class="special">{</SPAN>
                      <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">oldof</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">-</SPAN> <SPAN class="identifier">std</SPAN><SPAN class="special">::</SPAN><SPAN class="identifier">distance</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">first</SPAN><SPAN class="special">,</SPAN> <SPAN class="identifier">last</SPAN> <SPAN class="special">);</SPAN> 
                      <SPAN class="keyword">if</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">empty</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">)</SPAN>
                          <SPAN class="keyword">result</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">end</SPAN><SPAN class="special">();</SPAN>
                      <SPAN class="string">"All iterators in the range [first,end()) have been invalidated"</SPAN><SPAN class="special">;</SPAN>
                 <SPAN class="special">}</SPAN>

             <SPAN class="keyword">void</SPAN> <SPAN class="identifier">clear</SPAN><SPAN class="special">();</SPAN>
                 <SPAN class="keyword">postcondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="identifier">empty</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
                 
             <SPAN class="keyword">void</SPAN> <SPAN class="identifier">swap</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">vector</SPAN><SPAN class="special">&amp;</SPAN> <SPAN class="identifier">right</SPAN> <SPAN class="special">)</SPAN>
                 <SPAN class="keyword">postcondition</SPAN> 
                 <SPAN class="special">{</SPAN> 
                     <SPAN class="identifier">oldof</SPAN> <SPAN class="special">*</SPAN><SPAN class="keyword">this</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">right</SPAN><SPAN class="special">;</SPAN>
                     <SPAN class="identifier">oldof</SPAN> <SPAN class="identifier">right</SPAN> <SPAN class="special">==</SPAN> <SPAN class="special">*</SPAN><SPAN class="keyword">this</SPAN><SPAN class="special">;</SPAN>
                 <SPAN class="special">}</SPAN>
             
<SPAN class="special">};</SPAN> <SPAN class="comment">// class 'vector'</SPAN>

</PRE>


</DIV>
<DIV class="section" id="vector-example-alternative-syntax-hpp">
<H2><A class="toc-backref" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#id50" name="vector-example-alternative-syntax-hpp">10.2&nbsp;&nbsp;&nbsp;vector_example_alternative_syntax.hpp</A></H2>




<LINK rel="stylesheet" href="./Ottosen2005_Proposal_Rev3-n1866_files/style.css" type="text/css">



<PRE><SPAN class="comment">///////////////////////////////////////
// Tools
///////////////////////////////////////</SPAN>

<SPAN class="keyword">template</SPAN><SPAN class="special">&lt;</SPAN> <SPAN class="keyword">class</SPAN> <SPAN class="identifier">Iter</SPAN><SPAN class="special">,</SPAN> <SPAN class="keyword">class</SPAN> <SPAN class="identifier">T</SPAN> <SPAN class="special">&gt;</SPAN>
<SPAN class="keyword">bool</SPAN> <SPAN class="identifier">all_equals</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">Iter</SPAN> <SPAN class="identifier">first</SPAN><SPAN class="special">,</SPAN> <SPAN class="identifier">Iter</SPAN> <SPAN class="identifier">last</SPAN><SPAN class="special">,</SPAN> <SPAN class="keyword">const</SPAN> <SPAN class="identifier">T</SPAN><SPAN class="special">&amp;</SPAN> <SPAN class="identifier">val</SPAN> <SPAN class="special">)</SPAN>
<SPAN class="special">{</SPAN> <SPAN class="comment">/* for simplicity, let us assume T's can be compared */</SPAN> <SPAN class="special">}</SPAN>

<SPAN class="keyword">template</SPAN><SPAN class="special">&lt;</SPAN> <SPAN class="keyword">class</SPAN> <SPAN class="identifier">Iter</SPAN><SPAN class="special">,</SPAN> <SPAN class="keyword">class</SPAN> <SPAN class="identifier">Size</SPAN> <SPAN class="special">&gt;</SPAN>
<SPAN class="keyword">bool</SPAN> <SPAN class="identifier">equal_distance</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">Iter</SPAN> <SPAN class="identifier">first</SPAN><SPAN class="special">,</SPAN> <SPAN class="identifier">Iter</SPAN> <SPAN class="identifier">last</SPAN><SPAN class="special">,</SPAN> <SPAN class="identifier">Size</SPAN> <SPAN class="identifier">size</SPAN> <SPAN class="special">)</SPAN>
<SPAN class="special">{</SPAN> <SPAN class="comment">/* internal tagging mechnism so even input iterators can be passed */</SPAN> <SPAN class="special">}</SPAN>

<SPAN class="comment">///////////////////////////////////////
// New vector interface
///////////////////////////////////////</SPAN>

<SPAN class="keyword">template</SPAN><SPAN class="special">&lt;</SPAN> <SPAN class="keyword">class</SPAN> <SPAN class="identifier">T</SPAN><SPAN class="special">,</SPAN> <SPAN class="keyword">class</SPAN> <SPAN class="identifier">Alloc</SPAN> <SPAN class="special">=</SPAN> <SPAN class="identifier">allocator</SPAN><SPAN class="special">&lt;</SPAN><SPAN class="identifier">T</SPAN><SPAN class="special">&gt;</SPAN> <SPAN class="special">&gt;</SPAN>
<SPAN class="keyword">class</SPAN> <SPAN class="identifier">vector</SPAN> 
<SPAN class="special">{</SPAN>
    <SPAN class="keyword">invariant</SPAN>
    <SPAN class="special">{</SPAN>
	<SPAN class="identifier">is_assignable</SPAN><SPAN class="special">&lt;</SPAN><SPAN class="identifier">T</SPAN><SPAN class="special">&gt;::</SPAN><SPAN class="identifier">value</SPAN>         <SPAN class="special">:</SPAN> <SPAN class="string">"value_type must be Assignable"</SPAN> <SPAN class="special">&amp;&amp;</SPAN>
	<SPAN class="identifier">is_copy_constructible</SPAN><SPAN class="special">&lt;</SPAN><SPAN class="identifier">T</SPAN><SPAN class="special">&gt;::</SPAN><SPAN class="identifier">value</SPAN> <SPAN class="special">:</SPAN> <SPAN class="string">"value_type must be CopyConstructible"</SPAN> <SPAN class="special">&amp;&amp;</SPAN>
        <SPAN class="special">(</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">==</SPAN> <SPAN class="number">0</SPAN> <SPAN class="special">)</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">empty</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">&amp;&amp;</SPAN>
        <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">std</SPAN><SPAN class="special">::</SPAN><SPAN class="identifier">distance</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">begin</SPAN><SPAN class="special">(),</SPAN> <SPAN class="identifier">end</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">)</SPAN> <SPAN class="special">&amp;&amp;</SPAN>
        <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">std</SPAN><SPAN class="special">::</SPAN><SPAN class="identifier">distance</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">rbegin</SPAN><SPAN class="special">(),</SPAN> <SPAN class="identifier">rend</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">)</SPAN> <SPAN class="special">&amp;&amp;</SPAN>
        <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">&lt;=</SPAN> <SPAN class="identifier">capacity</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">&amp;&amp;</SPAN>
        <SPAN class="identifier">capacity</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">&lt;=</SPAN> <SPAN class="identifier">max_size</SPAN><SPAN class="special">();</SPAN>
    <SPAN class="special">}</SPAN>
    
    
<SPAN class="keyword">public</SPAN><SPAN class="special">:</SPAN>
    <SPAN class="keyword">typedef</SPAN> <SPAN class="identifier">Alloc</SPAN>                             <SPAN class="identifier">allocator_type</SPAN><SPAN class="special">;</SPAN>
    <SPAN class="keyword">typedef</SPAN> <SPAN class="keyword">typename</SPAN> <SPAN class="identifier">Alloc</SPAN><SPAN class="special">::</SPAN><SPAN class="identifier">pointer</SPAN>           <SPAN class="identifier">pointer</SPAN><SPAN class="special">;</SPAN>
    <SPAN class="keyword">typedef</SPAN> <SPAN class="keyword">typename</SPAN> <SPAN class="identifier">Alloc</SPAN><SPAN class="special">::</SPAN><SPAN class="identifier">const_pointer</SPAN>     <SPAN class="identifier">const_pointer</SPAN><SPAN class="special">;</SPAN>
    <SPAN class="keyword">typedef</SPAN> <SPAN class="keyword">typename</SPAN> <SPAN class="identifier">Alloc</SPAN><SPAN class="special">::</SPAN><SPAN class="identifier">reference</SPAN>         <SPAN class="identifier">reference</SPAN><SPAN class="special">;</SPAN>
    <SPAN class="keyword">typedef</SPAN> <SPAN class="keyword">typename</SPAN> <SPAN class="identifier">Alloc</SPAN><SPAN class="special">::</SPAN><SPAN class="identifier">const_reference</SPAN>   <SPAN class="identifier">const_reference</SPAN><SPAN class="special">;</SPAN>
    <SPAN class="keyword">typedef</SPAN> <SPAN class="keyword">typename</SPAN> <SPAN class="identifier">Alloc</SPAN><SPAN class="special">::</SPAN><SPAN class="identifier">value_type</SPAN>        <SPAN class="identifier">value_type</SPAN><SPAN class="special">;</SPAN>
    <SPAN class="keyword">typedef</SPAN> <SPAN class="special">...</SPAN>                               <SPAN class="identifier">iterator</SPAN><SPAN class="special">;</SPAN>
    <SPAN class="keyword">typedef</SPAN> <SPAN class="special">...</SPAN>                               <SPAN class="identifier">const_iterator</SPAN><SPAN class="special">;</SPAN>
    <SPAN class="keyword">typedef</SPAN> <SPAN class="special">...</SPAN>                               <SPAN class="identifier">size_type</SPAN><SPAN class="special">;</SPAN>
    <SPAN class="keyword">typedef</SPAN> <SPAN class="special">...</SPAN>                               <SPAN class="identifier">difference_type</SPAN><SPAN class="special">;</SPAN>
    <SPAN class="keyword">typedef</SPAN> <SPAN class="identifier">reverse_iterator</SPAN><SPAN class="special">&lt;</SPAN><SPAN class="identifier">iterator</SPAN><SPAN class="special">&gt;</SPAN>        <SPAN class="identifier">reverse_iterator</SPAN><SPAN class="special">;</SPAN>
    <SPAN class="keyword">typedef</SPAN> <SPAN class="identifier">reverse_iterator</SPAN><SPAN class="special">&lt;</SPAN><SPAN class="identifier">const_iterator</SPAN><SPAN class="special">&gt;</SPAN>  <SPAN class="identifier">const_reverse_iterator</SPAN><SPAN class="special">;</SPAN>

             <SPAN class="identifier">vector</SPAN><SPAN class="special">()</SPAN>                  
                 <SPAN class="keyword">postcondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="identifier">empty</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN> 
                 
    <SPAN class="keyword">explicit</SPAN> <SPAN class="identifier">vector</SPAN><SPAN class="special">(</SPAN> <SPAN class="keyword">const</SPAN> <SPAN class="identifier">Alloc</SPAN><SPAN class="special">&amp;</SPAN> <SPAN class="identifier">al</SPAN> <SPAN class="special">)</SPAN> 
                 <SPAN class="keyword">postcondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="identifier">empty</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">&amp;&amp;</SPAN> 
                                 <SPAN class="identifier">al</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">get_allocator</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
                 
    <SPAN class="keyword">explicit</SPAN> <SPAN class="identifier">vector</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">size_type</SPAN> <SPAN class="identifier">count</SPAN> <SPAN class="special">)</SPAN> 
                 <SPAN class="keyword">postcondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">count</SPAN> <SPAN class="special">&amp;&amp;</SPAN> 
                                 <SPAN class="identifier">all_equals</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">begin</SPAN><SPAN class="special">(),</SPAN> <SPAN class="identifier">end</SPAN><SPAN class="special">(),</SPAN> <SPAN class="identifier">T</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">);</SPAN> <SPAN class="special">}</SPAN>
                 
             <SPAN class="identifier">vector</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">size_type</SPAN> <SPAN class="identifier">count</SPAN><SPAN class="special">,</SPAN> <SPAN class="keyword">const</SPAN> <SPAN class="identifier">T</SPAN><SPAN class="special">&amp;</SPAN> <SPAN class="identifier">val</SPAN> <SPAN class="special">)</SPAN> 
                 <SPAN class="keyword">postcondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">count</SPAN> <SPAN class="special">&amp;&amp;</SPAN>
                                 <SPAN class="identifier">all_equals</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">begin</SPAN><SPAN class="special">(),</SPAN> <SPAN class="identifier">end</SPAN><SPAN class="special">(),</SPAN> <SPAN class="identifier">val</SPAN> <SPAN class="special">);</SPAN> <SPAN class="special">}</SPAN>
             
             <SPAN class="identifier">vector</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">size_type</SPAN> <SPAN class="identifier">count</SPAN><SPAN class="special">,</SPAN> <SPAN class="keyword">const</SPAN> <SPAN class="identifier">T</SPAN><SPAN class="special">&amp;</SPAN> <SPAN class="identifier">val</SPAN><SPAN class="special">,</SPAN> <SPAN class="keyword">const</SPAN> <SPAN class="identifier">Alloc</SPAN><SPAN class="special">&amp;</SPAN> <SPAN class="identifier">al</SPAN> <SPAN class="special">)</SPAN> 
                 <SPAN class="keyword">postcondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="identifier">size</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">count</SPAN> <SPAN class="special">&amp;&amp;</SPAN> 
                                 <SPAN class="identifier">all_equals</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">begin</SPAN><SPAN class="special">(),</SPAN> <SPAN class="identifier">end</SPAN><SPAN class="special">(),</SPAN> <SPAN class="identifier">val</SPAN> <SPAN class="special">)</SPAN> <SPAN class="special">&amp;&amp;</SPAN> 
                                 <SPAN class="identifier">al</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">get_allocator</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
             
             <SPAN class="identifier">vector</SPAN><SPAN class="special">(</SPAN> <SPAN class="keyword">const</SPAN> <SPAN class="identifier">vector</SPAN><SPAN class="special">&amp;</SPAN> <SPAN class="identifier">right</SPAN> <SPAN class="special">)</SPAN> 
                 <SPAN class="keyword">postcondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="identifier">right</SPAN> <SPAN class="special">==</SPAN> <SPAN class="special">*</SPAN><SPAN class="keyword">this</SPAN><SPAN class="special">;</SPAN> <SPAN class="special">}</SPAN>
    
             <SPAN class="keyword">template</SPAN><SPAN class="special">&lt;</SPAN> <SPAN class="keyword">class</SPAN> <SPAN class="identifier">InIt</SPAN> <SPAN class="special">&gt;</SPAN>
             <SPAN class="identifier">vector</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">InIt</SPAN> <SPAN class="identifier">first</SPAN><SPAN class="special">,</SPAN> <SPAN class="identifier">InIt</SPAN> <SPAN class="identifier">last</SPAN> <SPAN class="special">)</SPAN> 
                 <SPAN class="keyword">precondition</SPAN>  <SPAN class="special">{</SPAN> <SPAN class="identifier">is_input_iterator</SPAN><SPAN class="special">&lt;</SPAN><SPAN class="identifier">InIt</SPAN><SPAN class="special">&gt;::</SPAN><SPAN class="identifier">value</SPAN> <SPAN class="special">:</SPAN> <SPAN class="string">"Iterator argument must model an InputIterator"</SPAN><SPAN class="special">;</SPAN> <SPAN class="special">}</SPAN>
                 <SPAN class="keyword">postcondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="identifier">equal_distance</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">first</SPAN><SPAN class="special">,</SPAN> <SPAN class="identifier">last</SPAN><SPAN class="special">,</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">);</SPAN> <SPAN class="special">}</SPAN>
                 
             <SPAN class="keyword">template</SPAN><SPAN class="special">&lt;</SPAN> <SPAN class="keyword">class</SPAN> <SPAN class="identifier">InIt</SPAN> <SPAN class="special">&gt;</SPAN>
             <SPAN class="identifier">vector</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">InIt</SPAN> <SPAN class="identifier">first</SPAN><SPAN class="special">,</SPAN> <SPAN class="identifier">InIt</SPAN> <SPAN class="identifier">last</SPAN><SPAN class="special">,</SPAN> <SPAN class="keyword">const</SPAN> <SPAN class="identifier">Alloc</SPAN><SPAN class="special">&amp;</SPAN> <SPAN class="identifier">al</SPAN> <SPAN class="special">);</SPAN>
                 <SPAN class="keyword">precondition</SPAN>  <SPAN class="special">{</SPAN> <SPAN class="identifier">is_input_iterator</SPAN><SPAN class="special">&lt;</SPAN><SPAN class="identifier">InIt</SPAN><SPAN class="special">&gt;::</SPAN><SPAN class="identifier">value</SPAN> <SPAN class="special">:</SPAN> <SPAN class="string">"Iterator argument must model an InputIterator"</SPAN><SPAN class="special">;</SPAN> <SPAN class="special">}</SPAN>
                 <SPAN class="keyword">postcondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="identifier">equal_distance</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">first</SPAN><SPAN class="special">,</SPAN> <SPAN class="identifier">last</SPAN><SPAN class="special">,</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">)</SPAN> <SPAN class="special">&amp;&amp;</SPAN> 
                                 <SPAN class="identifier">al</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">get_allocator</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>

             <SPAN class="keyword">void</SPAN> <SPAN class="identifier">reserve</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">size_type</SPAN> <SPAN class="identifier">count</SPAN> <SPAN class="special">)</SPAN> 
                 <SPAN class="keyword">precondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="identifier">count</SPAN> <SPAN class="special">&lt;</SPAN> <SPAN class="identifier">max_size</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
                 <SPAN class="keyword">postcondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="identifier">capacity</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">&gt;=</SPAN> <SPAN class="identifier">count</SPAN><SPAN class="special">;</SPAN> <SPAN class="special">}</SPAN>
                 
             <SPAN class="identifier">size_type</SPAN> <SPAN class="identifier">capacity</SPAN><SPAN class="special">()</SPAN> <SPAN class="keyword">const</SPAN><SPAN class="special">;</SPAN>
                 <SPAN class="keyword">postcondition</SPAN><SPAN class="special">(</SPAN> <SPAN class="keyword">result</SPAN> <SPAN class="special">)</SPAN> <SPAN class="special">{</SPAN> <SPAN class="keyword">result</SPAN> <SPAN class="special">&gt;=</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
                 
             <SPAN class="identifier">iterator</SPAN> <SPAN class="identifier">begin</SPAN><SPAN class="special">()</SPAN>
                 <SPAN class="keyword">postcondition</SPAN><SPAN class="special">(</SPAN> <SPAN class="keyword">result</SPAN> <SPAN class="special">)</SPAN> <SPAN class="special">{</SPAN> <SPAN class="identifier">empty</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">?</SPAN> <SPAN class="keyword">result</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">end</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">:</SPAN> <SPAN class="keyword">true</SPAN><SPAN class="special">;</SPAN> <SPAN class="special">}</SPAN>
             
             <SPAN class="identifier">const_iterator</SPAN> <SPAN class="identifier">begin</SPAN><SPAN class="special">()</SPAN> <SPAN class="keyword">const</SPAN>
                 <SPAN class="keyword">postcondition</SPAN><SPAN class="special">(</SPAN> <SPAN class="keyword">result</SPAN> <SPAN class="special">)</SPAN> <SPAN class="special">{</SPAN> <SPAN class="identifier">empty</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">?</SPAN> <SPAN class="keyword">result</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">end</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">:</SPAN> <SPAN class="keyword">true</SPAN><SPAN class="special">;</SPAN> <SPAN class="special">}</SPAN>
             
             <SPAN class="identifier">iterator</SPAN> <SPAN class="identifier">end</SPAN><SPAN class="special">();</SPAN>
             <SPAN class="identifier">const_iterator</SPAN> <SPAN class="identifier">end</SPAN><SPAN class="special">()</SPAN> <SPAN class="keyword">const</SPAN><SPAN class="special">;</SPAN>
             
             <SPAN class="identifier">reverse_iterator</SPAN> <SPAN class="identifier">rbegin</SPAN><SPAN class="special">()</SPAN>
                 <SPAN class="keyword">postcondition</SPAN><SPAN class="special">(</SPAN> <SPAN class="keyword">result</SPAN> <SPAN class="special">)</SPAN> <SPAN class="special">{</SPAN> <SPAN class="identifier">empty</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">?</SPAN> <SPAN class="keyword">result</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">rend</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">:</SPAN> <SPAN class="keyword">true</SPAN><SPAN class="special">;</SPAN> <SPAN class="special">}</SPAN>
             
             <SPAN class="identifier">const_reverse_iterator</SPAN> <SPAN class="identifier">rbegin</SPAN><SPAN class="special">()</SPAN> <SPAN class="keyword">const</SPAN>
                 <SPAN class="keyword">postcondition</SPAN><SPAN class="special">(</SPAN> <SPAN class="keyword">result</SPAN> <SPAN class="special">)</SPAN> <SPAN class="special">{</SPAN> <SPAN class="identifier">empty</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">?</SPAN> <SPAN class="keyword">result</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">rend</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">:</SPAN> <SPAN class="keyword">true</SPAN><SPAN class="special">;</SPAN> <SPAN class="special">}</SPAN>
             
             <SPAN class="identifier">reverse_iterator</SPAN> <SPAN class="identifier">rend</SPAN><SPAN class="special">();</SPAN>
             <SPAN class="identifier">const_reverse_iterator</SPAN> <SPAN class="identifier">rend</SPAN><SPAN class="special">()</SPAN> <SPAN class="keyword">const</SPAN><SPAN class="special">;</SPAN>
             
             <SPAN class="keyword">void</SPAN> <SPAN class="identifier">resize</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">size_type</SPAN> <SPAN class="identifier">newsize</SPAN> <SPAN class="special">)</SPAN>
                 <SPAN class="keyword">postcondition</SPAN> <SPAN class="comment">// version 1: with an if</SPAN>
                 <SPAN class="special">{</SPAN> 
                     <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">newsize</SPAN> <SPAN class="special">&amp;&amp;</SPAN>
                     <SPAN class="identifier">newsize</SPAN> <SPAN class="special">&gt;</SPAN> <SPAN class="identifier">oldof</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">?</SPAN>
                         <SPAN class="identifier">all_equals</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">begin</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">+</SPAN> <SPAN class="identifier">oldof</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">(),</SPAN> <SPAN class="identifier">end</SPAN><SPAN class="special">(),</SPAN> <SPAN class="identifier">T</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">)</SPAN> <SPAN class="special">:</SPAN> <SPAN class="keyword">true</SPAN><SPAN class="special">;</SPAN>
                 <SPAN class="special">}</SPAN>
             
             <SPAN class="keyword">void</SPAN> <SPAN class="identifier">resize</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">size_type</SPAN> <SPAN class="identifier">newsize</SPAN><SPAN class="special">,</SPAN> <SPAN class="identifier">T</SPAN> <SPAN class="identifier">val</SPAN> <SPAN class="special">)</SPAN>
                 <SPAN class="keyword">postcondition</SPAN> <SPAN class="comment">// version 2: with ternary operator</SPAN>
                 <SPAN class="special">{</SPAN>
                     <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">newsize</SPAN> <SPAN class="special">&amp;&amp;</SPAN> 
                     <SPAN class="identifier">newsize</SPAN> <SPAN class="special">&gt;</SPAN> <SPAN class="identifier">oldof</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">())</SPAN> <SPAN class="special">?</SPAN> 
                         <SPAN class="identifier">all_equals</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">begin</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">+</SPAN> <SPAN class="identifier">oldof</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">(),</SPAN> <SPAN class="identifier">end</SPAN><SPAN class="special">(),</SPAN> <SPAN class="identifier">val</SPAN> <SPAN class="special">)</SPAN> <SPAN class="special">:</SPAN> <SPAN class="keyword">true</SPAN><SPAN class="special">;</SPAN>
                 <SPAN class="special">}</SPAN>
         
             <SPAN class="identifier">size_type</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="keyword">const</SPAN>
                 <SPAN class="keyword">postcondition</SPAN><SPAN class="special">(</SPAN> <SPAN class="keyword">result</SPAN> <SPAN class="special">)</SPAN> <SPAN class="special">{</SPAN> <SPAN class="keyword">result</SPAN> <SPAN class="special">&lt;=</SPAN> <SPAN class="identifier">capacity</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
                 
             <SPAN class="identifier">size_type</SPAN> <SPAN class="identifier">max_size</SPAN><SPAN class="special">()</SPAN> <SPAN class="keyword">const</SPAN>
                 <SPAN class="keyword">postcondition</SPAN><SPAN class="special">(</SPAN> <SPAN class="keyword">result</SPAN> <SPAN class="special">)</SPAN> <SPAN class="special">{</SPAN> <SPAN class="keyword">result</SPAN> <SPAN class="special">&gt;=</SPAN> <SPAN class="identifier">capacity</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
             
             <SPAN class="keyword">bool</SPAN> <SPAN class="identifier">empty</SPAN><SPAN class="special">()</SPAN> <SPAN class="keyword">const</SPAN>
                 <SPAN class="keyword">postcondition</SPAN><SPAN class="special">(</SPAN> <SPAN class="keyword">result</SPAN> <SPAN class="special">)</SPAN> <SPAN class="special">{</SPAN> <SPAN class="keyword">result</SPAN> <SPAN class="special">==</SPAN> <SPAN class="special">(</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">==</SPAN> <SPAN class="number">0</SPAN> <SPAN class="special">);</SPAN> <SPAN class="special">}</SPAN>
             
             <SPAN class="identifier">Alloc</SPAN> <SPAN class="identifier">get_allocator</SPAN><SPAN class="special">()</SPAN> <SPAN class="keyword">const</SPAN><SPAN class="special">;</SPAN>
             
             <SPAN class="identifier">reference</SPAN> <SPAN class="identifier">at</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">size_type</SPAN> <SPAN class="identifier">off</SPAN> <SPAN class="special">);</SPAN>
                 <SPAN class="keyword">precondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="identifier">off</SPAN> <SPAN class="special">&lt;</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
             
             <SPAN class="identifier">const_reference</SPAN> <SPAN class="identifier">at</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">size_type</SPAN> <SPAN class="identifier">off</SPAN> <SPAN class="special">)</SPAN> <SPAN class="keyword">const</SPAN><SPAN class="special">;</SPAN>
                 <SPAN class="keyword">precondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="identifier">off</SPAN> <SPAN class="special">&lt;</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
                 
             <SPAN class="identifier">reference</SPAN> <SPAN class="keyword">operator</SPAN><SPAN class="special">[](</SPAN> <SPAN class="identifier">size_type</SPAN> <SPAN class="identifier">off</SPAN> <SPAN class="special">)</SPAN>
                 <SPAN class="keyword">precondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="identifier">off</SPAN> <SPAN class="special">&lt;</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>

             <SPAN class="identifier">const_reference</SPAN> <SPAN class="keyword">operator</SPAN><SPAN class="special">[](</SPAN> <SPAN class="identifier">size_type</SPAN> <SPAN class="identifier">off</SPAN> <SPAN class="special">)</SPAN>
                 <SPAN class="keyword">precondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="identifier">off</SPAN> <SPAN class="special">&lt;</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
    
             <SPAN class="identifier">reference</SPAN> <SPAN class="identifier">front</SPAN><SPAN class="special">();</SPAN>
                 <SPAN class="keyword">precondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="keyword">not</SPAN> <SPAN class="identifier">empty</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
             
             <SPAN class="identifier">const_reference</SPAN> <SPAN class="identifier">front</SPAN><SPAN class="special">()</SPAN> <SPAN class="keyword">const</SPAN><SPAN class="special">;</SPAN>
                 <SPAN class="keyword">precondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="keyword">not</SPAN> <SPAN class="identifier">empty</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
    
             <SPAN class="identifier">reference</SPAN> <SPAN class="identifier">back</SPAN><SPAN class="special">()</SPAN>
                 <SPAN class="keyword">precondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="keyword">not</SPAN> <SPAN class="identifier">empty</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
             
             <SPAN class="identifier">const_reference</SPAN> <SPAN class="identifier">back</SPAN><SPAN class="special">()</SPAN> <SPAN class="keyword">const</SPAN><SPAN class="special">;</SPAN>
                 <SPAN class="keyword">precondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="keyword">not</SPAN> <SPAN class="identifier">empty</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
                 
             <SPAN class="keyword">void</SPAN> <SPAN class="identifier">push_back</SPAN><SPAN class="special">(</SPAN> <SPAN class="keyword">const</SPAN> <SPAN class="identifier">T</SPAN><SPAN class="special">&amp;</SPAN> <SPAN class="identifier">val</SPAN> <SPAN class="special">)</SPAN>
                 <SPAN class="keyword">precondition</SPAN>  <SPAN class="special">{</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">&lt;</SPAN> <SPAN class="identifier">max_size</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
                 <SPAN class="keyword">postcondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="identifier">back</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">val</SPAN> <SPAN class="special">&amp;&amp;</SPAN> 
                                 <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">oldof</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">+</SPAN> <SPAN class="number">1</SPAN> <SPAN class="special">&amp;&amp;</SPAN> 
                                 <SPAN class="identifier">capacity</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">&gt;=</SPAN> <SPAN class="identifier">oldof</SPAN> <SPAN class="identifier">capacity</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
                 
             <SPAN class="keyword">void</SPAN> <SPAN class="identifier">pop_back</SPAN><SPAN class="special">()</SPAN>
                 <SPAN class="keyword">precondition</SPAN>  <SPAN class="special">{</SPAN> <SPAN class="keyword">not</SPAN> <SPAN class="identifier">empty</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
                 <SPAN class="keyword">postcondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">oldof</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">-</SPAN> <SPAN class="number">1</SPAN><SPAN class="special">;</SPAN> <SPAN class="special">}</SPAN>
             
             <SPAN class="keyword">template</SPAN><SPAN class="special">&lt;</SPAN> <SPAN class="keyword">class</SPAN> <SPAN class="identifier">InIt</SPAN> <SPAN class="special">&gt;</SPAN>
             <SPAN class="keyword">void</SPAN> <SPAN class="identifier">assign</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">InIt</SPAN> <SPAN class="identifier">first</SPAN><SPAN class="special">,</SPAN> <SPAN class="identifier">InIt</SPAN> <SPAN class="identifier">last</SPAN> <SPAN class="special">)</SPAN>
                 <SPAN class="keyword">precondition</SPAN>  
                 <SPAN class="special">{</SPAN>
                     <SPAN class="identifier">is_input_iterator</SPAN><SPAN class="special">&lt;</SPAN><SPAN class="identifier">InIt</SPAN><SPAN class="special">&gt;::</SPAN><SPAN class="identifier">value</SPAN> <SPAN class="special">:</SPAN> <SPAN class="string">"Iterator argument must model an InputIterator"</SPAN> <SPAN class="special">&amp;&amp;</SPAN> 
                     <SPAN class="string">"The range [first,last) is not a sub-range of [begin(),end())"</SPAN><SPAN class="special">;</SPAN>
                 <SPAN class="special">}</SPAN>
                 <SPAN class="keyword">postcondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="identifier">equal_distance</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">first</SPAN><SPAN class="special">,</SPAN> <SPAN class="identifier">last</SPAN><SPAN class="special">,</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">);</SPAN> <SPAN class="special">}</SPAN>
             
             <SPAN class="keyword">void</SPAN> <SPAN class="identifier">assign</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">size_type</SPAN> <SPAN class="identifier">count</SPAN><SPAN class="special">,</SPAN> <SPAN class="keyword">const</SPAN> <SPAN class="identifier">T</SPAN><SPAN class="special">&amp;</SPAN> <SPAN class="identifier">val</SPAN> <SPAN class="special">)</SPAN>
                 <SPAN class="keyword">precondition</SPAN>  <SPAN class="special">{</SPAN> <SPAN class="identifier">count</SPAN> <SPAN class="special">&lt;=</SPAN> <SPAN class="identifier">max_size</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
                 <SPAN class="keyword">postcondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="identifier">all_equals</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">begin</SPAN><SPAN class="special">(),</SPAN> <SPAN class="identifier">end</SPAN><SPAN class="special">(),</SPAN> <SPAN class="identifier">val</SPAN> <SPAN class="special">);</SPAN> <SPAN class="special">}</SPAN>
                 
             <SPAN class="identifier">iterator</SPAN> <SPAN class="identifier">insert</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">iterator</SPAN> <SPAN class="identifier">where</SPAN><SPAN class="special">,</SPAN> <SPAN class="keyword">const</SPAN> <SPAN class="identifier">T</SPAN><SPAN class="special">&amp;</SPAN> <SPAN class="identifier">val</SPAN> <SPAN class="special">)</SPAN>
                 <SPAN class="keyword">precondition</SPAN>  <SPAN class="special">{</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">&lt;</SPAN> <SPAN class="identifier">max_size</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
                 <SPAN class="keyword">postcondition</SPAN><SPAN class="special">(</SPAN> <SPAN class="keyword">result</SPAN> <SPAN class="special">)</SPAN> 
                 <SPAN class="special">{</SPAN>
                     <SPAN class="special">*</SPAN><SPAN class="keyword">result</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">val</SPAN> <SPAN class="special">&amp;&amp;</SPAN>
                     <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN>  <SPAN class="special">==</SPAN> <SPAN class="identifier">oldof</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">+</SPAN> <SPAN class="number">1</SPAN> <SPAN class="special">&amp;&amp;</SPAN>
                     <SPAN class="identifier">capacity</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">&gt;=</SPAN> <SPAN class="identifier">oldof</SPAN> <SPAN class="identifier">capacity</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">&amp;&amp;</SPAN>
                     
                     <SPAN class="identifier">capacity</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">&gt;</SPAN> <SPAN class="identifier">oldof</SPAN> <SPAN class="identifier">capacity</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">?</SPAN>
                         <SPAN class="string">"All iterators have been invalidated"</SPAN> <SPAN class="special">:</SPAN>
                         <SPAN class="string">"All iterators in the range [where,end()) have been invalidated"</SPAN><SPAN class="special">;</SPAN>
                 <SPAN class="special">}</SPAN>
             
             <SPAN class="keyword">void</SPAN> <SPAN class="identifier">insert</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">iterator</SPAN> <SPAN class="identifier">where</SPAN><SPAN class="special">,</SPAN> <SPAN class="identifier">size_type</SPAN> <SPAN class="identifier">count</SPAN><SPAN class="special">,</SPAN> <SPAN class="keyword">const</SPAN> <SPAN class="identifier">T</SPAN><SPAN class="special">&amp;</SPAN> <SPAN class="identifier">val</SPAN> <SPAN class="special">)</SPAN>
                 <SPAN class="keyword">precondition</SPAN>  <SPAN class="special">{</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">+</SPAN> <SPAN class="identifier">count</SPAN> <SPAN class="special">&lt;=</SPAN> <SPAN class="identifier">max_size</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
                 <SPAN class="keyword">postcondition</SPAN> 
                 <SPAN class="special">{</SPAN>
                     <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">oldof</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">+</SPAN> <SPAN class="identifier">count</SPAN> <SPAN class="special">&amp;&amp;</SPAN>
                     <SPAN class="identifier">capacity</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">&gt;=</SPAN> <SPAN class="identifier">oldof</SPAN> <SPAN class="identifier">capacity</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">&amp;&amp;</SPAN>
                     
                     <SPAN class="identifier">capacity</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">oldof</SPAN> <SPAN class="identifier">capacity</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">?</SPAN>
                         <SPAN class="identifier">all_equals</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">oldof</SPAN> <SPAN class="identifier">prior</SPAN><SPAN class="special">(</SPAN><SPAN class="identifier">where</SPAN><SPAN class="special">),</SPAN> <SPAN class="identifier">oldof</SPAN> <SPAN class="identifier">prior</SPAN><SPAN class="special">(</SPAN><SPAN class="identifier">where</SPAN><SPAN class="special">)</SPAN> <SPAN class="special">+</SPAN> <SPAN class="identifier">count</SPAN><SPAN class="special">,</SPAN> <SPAN class="identifier">val</SPAN> <SPAN class="special">)</SPAN> <SPAN class="special">&amp;&amp;</SPAN>
                         <SPAN class="string">"All iterators in the range [where,end()) have been invalidated"</SPAN> <SPAN class="special">:</SPAN>
                         <SPAN class="string">"All iterators have been invalidated"</SPAN><SPAN class="special">;</SPAN>
                 <SPAN class="special">}</SPAN>
                 
             <SPAN class="keyword">template</SPAN><SPAN class="special">&lt;</SPAN> <SPAN class="keyword">class</SPAN> <SPAN class="identifier">InIt</SPAN> <SPAN class="special">&gt;</SPAN>
             <SPAN class="keyword">void</SPAN> <SPAN class="identifier">insert</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">iterator</SPAN> <SPAN class="identifier">where</SPAN><SPAN class="special">,</SPAN> <SPAN class="identifier">InIt</SPAN> <SPAN class="identifier">first</SPAN><SPAN class="special">,</SPAN> <SPAN class="identifier">InIt</SPAN> <SPAN class="identifier">last</SPAN> <SPAN class="special">)</SPAN>
                 <SPAN class="keyword">precondition</SPAN>  
                 <SPAN class="special">{</SPAN> 
                     <SPAN class="identifier">is_input_iterator</SPAN><SPAN class="special">&lt;</SPAN><SPAN class="identifier">InIt</SPAN><SPAN class="special">&gt;::</SPAN><SPAN class="identifier">value</SPAN> <SPAN class="special">:</SPAN> <SPAN class="string">"Iterator argument must model an InputIterator"</SPAN> <SPAN class="special">&amp;&amp;</SPAN>
                     <SPAN class="string">"The range [first,last) is not a sub-range of [begin(),end())"</SPAN> <SPAN class="special">&amp;&amp;</SPAN>
                     <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">+</SPAN> <SPAN class="identifier">count</SPAN> <SPAN class="special">&lt;=</SPAN> <SPAN class="identifier">max_size</SPAN><SPAN class="special">();</SPAN> 
                 <SPAN class="special">}</SPAN>
                 <SPAN class="keyword">postcondition</SPAN>
                 <SPAN class="special">{</SPAN>
                     <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">oldof</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">+</SPAN> <SPAN class="identifier">count</SPAN> <SPAN class="special">&amp;&amp;</SPAN>
                     <SPAN class="identifier">capacity</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">&gt;=</SPAN> <SPAN class="identifier">oldof</SPAN> <SPAN class="identifier">capacity</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">&amp;&amp;</SPAN>
        
                     <SPAN class="identifier">capacity</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">oldof</SPAN> <SPAN class="identifier">capacity</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">?</SPAN>
                         <SPAN class="identifier">all_equals</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">oldof</SPAN> <SPAN class="identifier">prior</SPAN><SPAN class="special">(</SPAN><SPAN class="identifier">where</SPAN><SPAN class="special">),</SPAN> <SPAN class="identifier">oldof</SPAN> <SPAN class="identifier">prior</SPAN><SPAN class="special">(</SPAN><SPAN class="identifier">where</SPAN><SPAN class="special">)</SPAN> <SPAN class="special">+</SPAN> <SPAN class="identifier">count</SPAN><SPAN class="special">,</SPAN> <SPAN class="identifier">val</SPAN> <SPAN class="special">)</SPAN> <SPAN class="special">&amp;&amp;</SPAN>
                         <SPAN class="string">"All iterators in the range [where,end()) have been invalidated"</SPAN><SPAN class="special">:</SPAN>
                         <SPAN class="string">"All iterators have been invalidated"</SPAN><SPAN class="special">;</SPAN>
                 <SPAN class="special">}</SPAN>

             <SPAN class="identifier">iterator</SPAN> <SPAN class="identifier">erase</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">iterator</SPAN> <SPAN class="identifier">where</SPAN> <SPAN class="special">);</SPAN>
                 <SPAN class="keyword">precondition</SPAN>  
                 <SPAN class="special">{</SPAN> 
                     <SPAN class="keyword">not</SPAN> <SPAN class="identifier">empty</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">&amp;&amp;</SPAN> 
                     <SPAN class="identifier">where</SPAN> <SPAN class="special">!=</SPAN> <SPAN class="identifier">end</SPAN><SPAN class="special">();</SPAN>
                 <SPAN class="special">}</SPAN>
                 <SPAN class="keyword">postcondition</SPAN><SPAN class="special">(</SPAN> <SPAN class="keyword">result</SPAN> <SPAN class="special">)</SPAN> 
                 <SPAN class="special">{</SPAN>
                      <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">oldof</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">-</SPAN> <SPAN class="number">1</SPAN> <SPAN class="special">&amp;&amp;</SPAN>
						   
                      <SPAN class="identifier">empty</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">?</SPAN> <SPAN class="keyword">result</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">end</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">:</SPAN> <SPAN class="keyword">true</SPAN> <SPAN class="special">&amp;&amp;</SPAN>
						  
                      <SPAN class="string">"All iterators in the range [where,end()) have been invalidated"</SPAN><SPAN class="special">;</SPAN>
                 <SPAN class="special">}</SPAN>
                 
             <SPAN class="identifier">iterator</SPAN> <SPAN class="identifier">erase</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">iterator</SPAN> <SPAN class="identifier">first</SPAN><SPAN class="special">,</SPAN> <SPAN class="identifier">iterator</SPAN> <SPAN class="identifier">last</SPAN> <SPAN class="special">)</SPAN>
                 <SPAN class="keyword">precondition</SPAN>  <SPAN class="special">{</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">&gt;=</SPAN> <SPAN class="identifier">std</SPAN><SPAN class="special">::</SPAN><SPAN class="identifier">distance</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">first</SPAN><SPAN class="special">,</SPAN> <SPAN class="identifier">last</SPAN> <SPAN class="special">);</SPAN> <SPAN class="special">}</SPAN>
                 <SPAN class="keyword">postcondition</SPAN><SPAN class="special">(</SPAN> <SPAN class="keyword">result</SPAN> <SPAN class="special">)</SPAN> 
                 <SPAN class="special">{</SPAN>
                      <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">oldof</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">-</SPAN> <SPAN class="identifier">std</SPAN><SPAN class="special">::</SPAN><SPAN class="identifier">distance</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">first</SPAN><SPAN class="special">,</SPAN> <SPAN class="identifier">last</SPAN> <SPAN class="special">)</SPAN> <SPAN class="special">&amp;&amp;</SPAN> 
                      <SPAN class="identifier">empty</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">?</SPAN> <SPAN class="keyword">result</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">end</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">&amp;&amp;</SPAN>
                      <SPAN class="string">"All iterators in the range [first,end()) have been invalidated"</SPAN><SPAN class="special">;</SPAN>
                 <SPAN class="special">}</SPAN>

             <SPAN class="keyword">void</SPAN> <SPAN class="identifier">clear</SPAN><SPAN class="special">();</SPAN>
                 <SPAN class="keyword">postcondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="identifier">empty</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
                 
             <SPAN class="keyword">void</SPAN> <SPAN class="identifier">swap</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">vector</SPAN><SPAN class="special">&amp;</SPAN> <SPAN class="identifier">right</SPAN> <SPAN class="special">)</SPAN>
                 <SPAN class="keyword">postcondition</SPAN> 
                 <SPAN class="special">{</SPAN> 
                     <SPAN class="identifier">oldof</SPAN> <SPAN class="special">*</SPAN><SPAN class="keyword">this</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">right</SPAN> <SPAN class="special">&amp;&amp;</SPAN>
                     <SPAN class="identifier">oldof</SPAN> <SPAN class="identifier">right</SPAN> <SPAN class="special">==</SPAN> <SPAN class="special">*</SPAN><SPAN class="keyword">this</SPAN><SPAN class="special">;</SPAN>
                 <SPAN class="special">}</SPAN>
             
<SPAN class="special">};</SPAN> <SPAN class="comment">// class 'vector'</SPAN>

</PRE>


</DIV>
<DIV class="section" id="subcontracting-example-hpp">
<H2><A class="toc-backref" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#id51" name="subcontracting-example-hpp">10.3&nbsp;&nbsp;&nbsp;subcontracting_example.hpp</A></H2>




<LINK rel="stylesheet" href="./Ottosen2005_Proposal_Rev3-n1866_files/style.css" type="text/css">




<PRE><SPAN class="comment">//
// This example shows how Contract Programming 
// allows one to keep the virtual function public 
// and still enforce the contract of the function
//</SPAN>

<SPAN class="keyword">class</SPAN> <SPAN class="identifier">shape</SPAN>
<SPAN class="special">{</SPAN>
<SPAN class="keyword">public</SPAN><SPAN class="special">:</SPAN>
    <SPAN class="keyword">virtual</SPAN> <SPAN class="special">~</SPAN><SPAN class="identifier">shape</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">{}</SPAN>
    
    <SPAN class="keyword">virtual</SPAN> <SPAN class="keyword">int</SPAN> <SPAN class="identifier">compute_area</SPAN><SPAN class="special">()</SPAN> <SPAN class="keyword">const</SPAN> <SPAN class="special">=</SPAN> <SPAN class="number">0</SPAN>
        <SPAN class="keyword">postcondition</SPAN><SPAN class="special">(</SPAN> <SPAN class="keyword">result</SPAN> <SPAN class="special">)</SPAN> 
        <SPAN class="special">{</SPAN>
            <SPAN class="keyword">result</SPAN> <SPAN class="special">&gt;</SPAN> <SPAN class="number">0</SPAN><SPAN class="special">;</SPAN>
        <SPAN class="special">}</SPAN>
<SPAN class="special">};</SPAN>

<SPAN class="keyword">class</SPAN> <SPAN class="identifier">circle</SPAN> <SPAN class="special">:</SPAN> <SPAN class="keyword">public</SPAN> <SPAN class="identifier">shape</SPAN>
<SPAN class="special">{</SPAN>
<SPAN class="keyword">public</SPAN><SPAN class="special">:</SPAN>
    <SPAN class="keyword">int</SPAN> <SPAN class="identifier">radius</SPAN><SPAN class="special">()</SPAN> <SPAN class="keyword">const</SPAN><SPAN class="special">;</SPAN>
    
    <SPAN class="keyword">virtual</SPAN> <SPAN class="keyword">int</SPAN> <SPAN class="identifier">compute_area</SPAN><SPAN class="special">()</SPAN> <SPAN class="keyword">const</SPAN>
        <SPAN class="keyword">postcondition</SPAN><SPAN class="special">(</SPAN> <SPAN class="keyword">result</SPAN> <SPAN class="special">)</SPAN>
        <SPAN class="special">{</SPAN>
            <SPAN class="keyword">result</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">pi</SPAN> <SPAN class="special">*</SPAN> <SPAN class="identifier">radius</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">*</SPAN> <SPAN class="identifier">radius</SPAN><SPAN class="special">();</SPAN>
        <SPAN class="special">}</SPAN>
<SPAN class="special">};</SPAN>
</PRE>







</DIV>
</DIV>
<DIV class="section" id="comparison-of-contract-programming-in-d-eiffel-and-c">
<H1><A class="toc-backref" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#id52" name="comparison-of-contract-programming-in-d-eiffel-and-c">11&nbsp;&nbsp;&nbsp;Comparison of Contract Programming in D, Eiffel and C++</A></H1>
<P>The table below contains a comparison of how Contract
Programming is implemented in D, Eiffel and C++.</P>
<TABLE border="1" class="docutils">
<COLGROUP>
<COL width="25%">
<COL width="21%">
<COL width="20%">
<COL width="34%">
</COLGROUP>
<TBODY valign="top">
<TR><TD><STRONG>Feature</STRONG></TD>
<TD><STRONG>ISE Eiffel 5.4</STRONG></TD>
<TD><STRONG>D</STRONG></TD>
<TD><STRONG>C++ Proposal</STRONG></TD>
</TR>
<TR><TD><EM>keywords</EM></TD>
<TD><TT class="docutils literal"><SPAN class="pre">require</SPAN></TT>, <TT class="docutils literal"><SPAN class="pre">ensure</SPAN></TT>,
<TT class="docutils literal"><SPAN class="pre">do</SPAN></TT>, <TT class="docutils literal"><SPAN class="pre">require</SPAN> <SPAN class="pre">else</SPAN></TT>,
<TT class="docutils literal"><SPAN class="pre">ensure</SPAN> <SPAN class="pre">then</SPAN></TT>, <TT class="docutils literal"><SPAN class="pre">invariant</SPAN></TT>,
<TT class="docutils literal"><SPAN class="pre">old</SPAN></TT>, <TT class="docutils literal"><SPAN class="pre">result</SPAN></TT>,
<TT class="docutils literal"><SPAN class="pre">variant</SPAN></TT></TD>
<TD><TT class="docutils literal"><SPAN class="pre">in</SPAN></TT>, <TT class="docutils literal"><SPAN class="pre">out</SPAN></TT>, <TT class="docutils literal"><SPAN class="pre">body</SPAN></TT>,
<TT class="docutils literal"><SPAN class="pre">invariant</SPAN></TT>, <TT class="docutils literal"><SPAN class="pre">assert</SPAN></TT>,
<TT class="docutils literal"><SPAN class="pre">static</SPAN></TT></TD>
<TD><TT class="docutils literal"><SPAN class="pre">precondition</SPAN></TT>,
<TT class="docutils literal"><SPAN class="pre">postcondition</SPAN></TT>,
<TT class="docutils literal"><SPAN class="pre">invariant</SPAN></TT>, <TT class="docutils literal"><SPAN class="pre">static</SPAN></TT></TD>
</TR>
<TR><TD><EM>on failure</EM></TD>
<TD>throws exception</TD>
<TD>throws exception</TD>
<TD>defaults to <TT class="docutils literal"><SPAN class="pre">terminate()</SPAN></TT>,
defaults can be customized,
might throw</TD>
</TR>
<TR><TD><EM>expression copying in postconditions</EM></TD>
<TD>yes, <TT class="docutils literal"><SPAN class="pre">old</SPAN></TT> keyword</TD>
<TD>no</TD>
<TD>yes, <TT class="docutils literal"><SPAN class="pre">oldof</SPAN></TT> keyword</TD>
</TR>
<TR><TD><EM>subcontracting</EM></TD>
<TD>yes</TD>
<TD>yes</TD>
<TD>yes, but only considers
postconditions</TD>
</TR>
<TR><TD><EM>contracts on abstract functions</EM></TD>
<TD>yes</TD>
<TD>no</TD>
<TD>yes</TD>
</TR>
<TR><TD><EM>arbitrary code contracts</EM></TD>
<TD>yes</TD>
<TD>yes</TD>
<TD>no, must be const correct</TD>
</TR>
<TR><TD><EM>function code ordering</EM></TD>
<TD>pre -&gt; body -&gt; post</TD>
<TD>pre -&gt; post -&gt; body</TD>
<TD>pre -&gt; post -&gt; body</TD>
</TR>
<TR><TD><EM>compile-time assertions</EM></TD>
<TD>no</TD>
<TD>yes</TD>
<TD>yes</TD>
</TR>
<TR><TD><EM>loop invariants</EM></TD>
<TD>yes</TD>
<TD>no</TD>
<TD>no</TD>
</TR>
<TR><TD><EM>loop variants</EM></TD>
<TD>yes</TD>
<TD>no</TD>
<TD>no</TD>
</TR>
<TR><TD><EM>const-correct</EM></TD>
<TD>no</TD>
<TD>no</TD>
<TD>yes</TD>
</TR>
<TR><TD><EM>invariant calls</EM></TD>
<TD><UL class="first last simple">
<LI>end of "constructor"</LI>
<LI>around public functions</LI>
</UL>
</TD>
<TD><UL class="first last simple">
<LI>end of constructor</LI>
<LI>around public functions</LI>
<LI>start of destructor</LI>
</UL>
</TD>
<TD><UL class="first last simple">
<LI>as in D</LI>
<LI>when a function exits due to an exception</LI>
</UL>
</TD>
</TR>
<TR><TD><EM>disabling of checks during assertions</EM></TD>
<TD>yes</TD>
<TD>no</TD>
<TD>no</TD>
</TR>
<TR><TD><EM>when public func. call public func.</EM></TD>
<TD>disable all checks</TD>
<TD>disable nothing</TD>
<TD>disable nothing</TD>
</TR>
<TR><TD><EM>removable from object code</EM></TD>
<TD>yes</TD>
<TD>yes</TD>
<TD>yes</TD>
</TR>
</TBODY>
</TABLE>
</DIV>
<DIV class="section" id="acknowledgements">
<H1><A class="toc-backref" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#id53" name="acknowledgements">12&nbsp;&nbsp;&nbsp;Acknowledgements</A></H1>
<P>The following people has been provided feedback and comments throughout the proposals
history: Reece Dunn, Douglas Gregor, Alf Steinbach, Matthew Wilson, 
Berend de Boer, Darren Cook, Pavel Vozenilek, Scott Meyers, Attila Fehr, Walter Bright,
Per Madsen, Kevlin Henney, Sergey Vlasov, Bob Bell, John Nagle, Daveed Vandevoorde,
Jaakko Jarvi, Christopher Diggins, John Torjo, Robert Kawulak, Dave Harris, Michael Wong, 
Thomas Witt, Tim Rowe.</P>
<P>Special thanks goes to David Abrahams and James Widman.</P>
<!-- ############################################### -->
<!-- ################## Links ###################### -->
<!-- ############################################### -->
</DIV>
<DIV class="section" id="footnotes">
<H1><A class="toc-backref" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#id54" name="footnotes">13&nbsp;&nbsp;&nbsp;Footnotes</A></H1>
<!-- ############################################### -->
<!-- ################## Footnotes ################## -->
<!-- ############################################### -->
<TABLE class="docutils footnote" frame="void" id="id15" rules="none">
<COLGROUP><COL class="label"><COL></COLGROUP>
<TBODY valign="top">
<TR><TD class="label"><A class="fn-backref" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#id1" name="id15">[0]</A></TD><TD>For example, if the compiler can determine that a precondition is satisfied,
it can call a function where the precondition is not checked. Also, the 
compiler can always assume contracts to be true; hence the compiler can take
advantage of the precondition in the function body.</TD></TR>
</TBODY>
</TABLE>
<TABLE class="docutils footnote" frame="void" id="id16" rules="none">
<COLGROUP><COL class="label"><COL></COLGROUP>
<TBODY valign="top">
<TR><TD class="label"><A class="fn-backref" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#id2" name="id16">[1]</A></TD><TD><P class="first">Even experienced programmers can choke on the word "invariant" and what it
means for a class to have one. There are a few simple rules we want  
all programmers to learn:</P>
<OL class="last arabic simple">
<LI>that classes can have invariants and that subclasses have stronger or equally strong invariants,</LI>
<LI>that functions have pre- and postconditions: the implementer has as his obligation to fulfill the 
postcondition assuming the precondition holds; the user has as his obligation to fulfill the precondition
and receives the benefits of the postcondition in return,</LI>
<LI>that public functions cannot break the class invariant.</LI>
</OL>
</TD></TR>
</TBODY>
</TABLE>
<TABLE class="docutils footnote" frame="void" id="id17" rules="none">
<COLGROUP><COL class="label"><COL></COLGROUP>
<TBODY valign="top">
<TR><TD class="label"><A name="id17">[2]</A></TD><TD>A good compiler will emit warnings whenever a mutation is detected within a contract. This is 
a major advantage compared to the ad hoc solutions programmers use today; there is no special
scope and hence no way the compiler can emit those warnings.</TD></TR>
</TBODY>
</TABLE>
<TABLE class="docutils footnote" frame="void" id="id18" rules="none">
<COLGROUP><COL class="label"><COL></COLGROUP>
<TBODY valign="top">
<TR><TD class="label"><A class="fn-backref" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#id7" name="id18">[3]</A></TD><TD>A weaker precondition can be taken advantage of if we know the particular type
of the object. If weaker preconditions should be allowed, then there exists two
alternatives: to allow reuse of an existing contract or to require a complete
redefinition. The former favours expressiveness, the latter favours
overview.</TD></TR>
</TBODY>
</TABLE>
<TABLE class="docutils footnote" frame="void" id="id19" rules="none">
<COLGROUP><COL class="label"><COL></COLGROUP>
<TBODY valign="top">
<TR><TD class="label"><A class="fn-backref" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#id8" name="id19">[4]</A></TD><TD>In some cases the compiler will be able to determine overlapping expression and hence
optimize some assertions away.</TD></TR>
</TBODY>
</TABLE>
<TABLE class="docutils footnote" frame="void" id="id20" rules="none">
<COLGROUP><COL class="label"><COL></COLGROUP>
<TBODY valign="top">
<TR><TD class="label"><A class="fn-backref" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#id11" name="id20">[5]</A></TD><TD>To ensure that the function gives the basic guarantee of exception-safety.</TD></TR>
</TBODY>
</TABLE>
<TABLE class="docutils footnote" frame="void" id="id21" rules="none">
<COLGROUP><COL class="label"><COL></COLGROUP>
<TBODY valign="top">
<TR><TD class="label"><A class="fn-backref" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#id12" name="id21">[6]</A></TD><TD>One can imagine an approach where exceptions could escape from an invariant by not checking
invariants when functions exit via an exception. The benefits of such an approach are not
obvious and it will complicate flow analysis unnecessarily.</TD></TR>
</TBODY>
</TABLE>
<TABLE class="docutils footnote" frame="void" id="id22" rules="none">
<COLGROUP><COL class="label"><COL></COLGROUP>
<TBODY valign="top">
<TR><TD class="label"><A class="fn-backref" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html#id13" name="id22">[7]</A></TD><TD>During construction means until the post-condition of the constructor has ended.</TD></TR>
</TBODY>
</TABLE>
</DIV>
</DIV>


</BODY></HTML>