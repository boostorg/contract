<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0066)http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html -->
<HTML xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><HEAD><META http-equiv="Content-Type" content="text/html; charset=UTF-8">

<META name="generator" content="Docutils 0.3.10: http://docutils.sourceforge.net/">
<TITLE>Proposal to add Contract Programming to C++ (revision 4)</TITLE>
<META name="author" content="Lawrence Crowl and Thorsten Ottosen">
<META name="organization" content="Sun Microsystems and Dezide Aps">
<META name="date" content="2006-02-25">
<STYLE type="text/css">

/*
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:date: $Date: 2004/01/12 02:49:54 $
:version: $Revision: 1.2 $
:copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.
*/

.first {
  margin-top: 0 }

.last {
  margin-bottom: 0 }

a.toc-backref {
  text-decoration: none ;
  color: black }

dd {
  margin-bottom: 0.5em }

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.attention, div.caution, div.danger, div.error, div.hint,
div.important, div.note, div.tip, div.warning, div.admonition {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

div.hint p.admonition-title, div.important p.admonition-title,
div.note p.admonition-title, div.tip p.admonition-title,
div.admonition p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em }

div.footer, div.header {
  font-size: smaller }

div.sidebar {
  margin-left: 1em ;
  border: medium outset ;
  padding: 0em 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr {
  width: 75% }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.line-block {
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;
  background-color: #eeeeee }

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.option-argument {
  font-style: italic }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

table {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.citation {
  border-left: solid thin gray ;
  padding-left: 0.5ex }

table.docinfo {
  margin: 2em 4em }

table.footnote {
  border-left: solid thin black ;
  padding-left: 0.5ex }

td, th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

th.docinfo-name, th.field-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap }

h1 tt, h2 tt, h3 tt, h4 tt, h5 tt, h6 tt {
  font-size: 100% }

tt {
  background-color: #eeeeee }

ul.auto-toc {
  list-style-type: none }
  
pre{
  BORDER-RIGHT: gray 1pt solid;
  PADDING-RIGHT: 2pt;
  BORDER-TOP: gray 1pt solid;
  DISPLAY: block;
  PADDING-LEFT: 2pt;
  PADDING-BOTTOM: 2pt;
  BORDER-LEFT: gray 1pt solid;
  MARGIN-RIGHT: 32pt;
  PADDING-TOP: 2pt;
  BORDER-BOTTOM: gray 1pt solid;
  FONT-FAMILY: "Courier New", Courier, mono; 
  background-color: #EEEEEE; 
}


.keyword{color: #0000FF;}
.identifier{}
.comment{font-style: italic; color: #008000;}
.special{color: #800040;}
.preprocessor{color: #3F007F;}
.string{font-style: italic; color: #666666;}
.literal{/*font-style: italic;*/ color: #000000;}


</STYLE>
<TITLE> </TITLE><TITLE> </TITLE></HEAD><BODY>
<DIV class="document" id="proposal-to-add-contract-programming-to-c-revision-4">
<H1 class="title">Proposal to add Contract Programming to C++ (revision 4)</H1>
<TABLE class="docinfo" frame="void" rules="none">
<COL class="docinfo-name">
<COL class="docinfo-content">
<TBODY valign="top">
<TR><TH class="docinfo-name">Author:</TH>
<TD>Lawrence Crowl and Thorsten Ottosen</TD></TR>
<TR><TH class="docinfo-name">Contact:</TH>
<TD><A class="first reference" href="mailto:lawrence.crowl@sun.com">lawrence.crowl@sun.com</A> and <A class="last reference" href="mailto:tottosen@dezide.com">tottosen@dezide.com</A></TD></TR>
<TR><TH class="docinfo-name">Organization:</TH>
<TD>Sun Microsystems and Dezide Aps</TD></TR>
<TR><TH class="docinfo-name">Date:</TH>
<TD>2006-02-25</TD></TR>
<TR class="field"><TH class="docinfo-name">Number:</TH><TD class="field-body">WG21/N1962 and J16/06-0032. This proposal is a
revision of paper <A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html">n1866</A>.</TD>
</TR>
<TR class="field"><TH class="docinfo-name">Working Group:</TH><TD class="field-body">Evolution</TD>
</TR>
</TBODY>
</TABLE>
<DIV class="abstract topic">
<P class="topic-title first">Abstract</P>
<P>Contract Programming is about providing the programmer with stronger tools 
for expressing correctness arguments directly in the source code. Moreover, the
contracts enable new and powerful optimization opportunities. 
The benefits 
are among others a higher degree of self-documenting source code,
better design tools, 
and easier debugging and testing. 
The proposal consists of largely orthogonal mechanisms which
may be pursued in isolation.</P>
</DIV>
<DIV class="contents topic">
<P class="topic-title first"><A id="table-of-contents" name="table-of-contents">Table of Contents</A></P>
<UL class="auto-toc simple">
<LI><A class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#motivation" id="id47" name="id47">1&nbsp;&nbsp;&nbsp;Motivation</A></LI>
<LI><A class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#major-changes-from-n1866" id="id48" name="id48">2&nbsp;&nbsp;&nbsp;Major changes from n1866</A></LI>
<LI><A class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#alternative-ways-to-realize-this-proposals" id="id49" name="id49">3&nbsp;&nbsp;&nbsp;Alternative ways to realize this proposals</A></LI>
<LI><A class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#the-proposal" id="id50" name="id50">4&nbsp;&nbsp;&nbsp;The proposal</A><UL class="auto-toc">
<LI><A class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#assertions" id="id51" name="id51">4.1&nbsp;&nbsp;&nbsp;Assertions</A><UL class="auto-toc">
<LI><A class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#runtime-assertions" id="id52" name="id52">4.1.1&nbsp;&nbsp;&nbsp;Runtime assertions</A></LI>
</UL>
</LI>
<LI><A class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#function-pre-and-postconditions" id="id53" name="id53">4.2&nbsp;&nbsp;&nbsp;Function pre- and postconditions</A><UL class="auto-toc">
<LI><A class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#virtual-functions" id="id54" name="id54">4.2.1&nbsp;&nbsp;&nbsp;Virtual functions</A></LI>
<LI><A class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#constructors" id="id55" name="id55">4.2.2&nbsp;&nbsp;&nbsp;Constructors</A></LI>
<LI><A class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#function-pointers" id="id56" name="id56">4.2.3&nbsp;&nbsp;&nbsp;Function pointers</A></LI>
</UL>
</LI>
<LI><A class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#keyword-oldof" id="id57" name="id57">4.3&nbsp;&nbsp;&nbsp;Keyword <TT class="docutils literal"><SPAN class="pre">oldof</SPAN></TT></A></LI>
<LI><A class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#class-invariants" id="id58" name="id58">4.4&nbsp;&nbsp;&nbsp;Class invariants</A></LI>
<LI><A class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#block-invariants" id="id59" name="id59">4.5&nbsp;&nbsp;&nbsp;block invariants</A></LI>
<LI><A class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#failure-handler-functions" id="id60" name="id60">4.6&nbsp;&nbsp;&nbsp;Failure handler functions</A></LI>
<LI><A class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#changes-to-the-standard-library" id="id61" name="id61">4.7&nbsp;&nbsp;&nbsp;Changes to the standard library</A></LI>
</UL>
</LI>
<LI><A class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#contracts-for-performance" id="id62" name="id62">5&nbsp;&nbsp;&nbsp;Contracts for performance</A><UL class="auto-toc">
<LI><A class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#assert-is-evaluated-within-the-library" id="id63" name="id63">5.1&nbsp;&nbsp;&nbsp;<TT class="docutils literal"><SPAN class="pre">assert()</SPAN></TT> is evaluated within the library</A></LI>
<LI><A class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#assert-fails-to-distinguish-between-checking-arguments-and-validating-computations" id="id64" name="id64">5.2&nbsp;&nbsp;&nbsp;<TT class="docutils literal"><SPAN class="pre">assert()</SPAN></TT> fails to distinguish between checking arguments and validating computations</A></LI>
<LI><A class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#assert-is-indistinguishable-from-regular-code" id="id65" name="id65">5.3&nbsp;&nbsp;&nbsp;<TT class="docutils literal"><SPAN class="pre">assert()</SPAN></TT> is indistinguishable from regular code</A></LI>
</UL>
</LI>
<LI><A class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#implementation-model-for-contracts" id="id66" name="id66">6&nbsp;&nbsp;&nbsp;Implementation model for contracts</A></LI>
<LI><A class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#list-of-proposals-that-could-be-affected-by-this-proposal" id="id67" name="id67">7&nbsp;&nbsp;&nbsp;List of proposals that could be affected by this proposal</A></LI>
<LI><A class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#implementability" id="id68" name="id68">8&nbsp;&nbsp;&nbsp;Implementability</A></LI>
<LI><A class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#alternative-syntax" id="id69" name="id69">9&nbsp;&nbsp;&nbsp;Alternative syntax</A></LI>
<LI><A class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#list-of-examples" id="id70" name="id70">10&nbsp;&nbsp;&nbsp;List of examples</A><UL class="auto-toc">
<LI><A class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#vector-example-hpp" id="id71" name="id71">10.1&nbsp;&nbsp;&nbsp;vector_example.hpp</A></LI>
<LI><A class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#subcontracting-example-hpp" id="id72" name="id72">10.2&nbsp;&nbsp;&nbsp;subcontracting_example.hpp</A></LI>
<LI><A class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#recursion-example" id="id73" name="id73">10.3&nbsp;&nbsp;&nbsp;recursion example</A></LI>
</UL>
</LI>
<LI><A class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#comparison-of-contract-programming-in-d-eiffel-and-c" id="id74" name="id74">11&nbsp;&nbsp;&nbsp;Comparison of Contract Programming in D, Eiffel and C++</A></LI>
<LI><A class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#list-of-contract-programming-resources" id="id75" name="id75">12&nbsp;&nbsp;&nbsp;List of Contract Programming resources</A></LI>
<LI><A class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#acknowledgements" id="id76" name="id76">13&nbsp;&nbsp;&nbsp;Acknowledgements</A></LI>
<LI><A class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#footnotes" id="id77" name="id77">14&nbsp;&nbsp;&nbsp;Footnotes</A></LI>
</UL>
</DIV>
<DIV class="section">
<H1><A class="toc-backref" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#id47" id="motivation" name="motivation">1&nbsp;&nbsp;&nbsp;Motivation</A></H1>
<BLOCKQUOTE>
<DIV class="line-block">
<DIV class="line">Fact 31: Error removal is the most time-consuming phase of the</DIV>
<DIV class="line">[software] life cycle.</DIV>
<DIV class="line"><BR></DIV>
<DIV class="line">Fact 36: Programmer-created built-in debug code, preferably optionally</DIV>
<DIV class="line">included in the object code based on compiler parameters,</DIV>
<DIV class="line">is an important supplement to testing tools.</DIV>
<DIV class="line"><BR></DIV>
<DIV class="line"><EM>Excerpted from Robert L. Glass' fascinating book "Facts and Fallacies of Software Engineering"</EM>.</DIV>
</DIV>
</BLOCKQUOTE>
<P>Language support for Contract Programming in C++ has several benefits:</P>
<OL class="arabic simple">
<LI>It can minimize the need for separation of documentation and implementation.</LI>
</OL>
<!--  -->
<OL class="arabic simple" start="2">
<LI>It can enable the compiler to generate faster code <A class="footnote-reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#id35" id="id1" name="id1">[0]</A>
(see also <A class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#contracts-for-performance">Contracts for performance</A>).</LI>
</OL>
<!--  -->
<OL class="arabic simple" start="3">
<LI>It can make debugging and testing much easier.</LI>
</OL>
<!--  -->
<OL class="arabic simple" start="4">
<LI>It can improve communication between designers and programmers in large C++ projects.</LI>
</OL>
<!--  -->
<OL class="arabic simple" start="5">
<LI>It can make inheritance easier to use correctly (see <A class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#subcontracting-example-hpp">subcontracting_example.hpp</A> and <A class="footnote-reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#id43" id="id2" name="id2">[8]</A>).</LI>
</OL>
<!--  -->
<OL class="arabic simple" start="6">
<LI>It can ensure that every programmer understands the contract metaphors <A class="footnote-reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#id36" id="id3" name="id3">[1]</A> .</LI>
</OL>
<!--  -->
<OL class="arabic simple" start="7">
<LI>It can enable more powerful static analysis tools.</LI>
</OL>
<!--  -->
<OL class="arabic simple" start="8">
<LI>It can make assertions easier to use and more expressive by avoiding infinite recursion
when checking postconditions and class invariants (see <A class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#recursion-example">recursion example</A>).</LI>
</OL>
<P>Please refer to <A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1800.pdf">n1800</A> and <A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2004/n1613.pdf">n1613</A> for an extensive discussion of these benefits.</P>
<P>Already with the current proposal, it is quite remarkable how much
of an interface that can be documented. For a good example, please
see how <TT class="docutils literal"><SPAN class="pre">std::vector</SPAN></TT> is declared in <A class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#vector-example-hpp">vector_example.hpp</A>; there is only a small
portion of the specification of <TT class="docutils literal"><SPAN class="pre">std::vector</SPAN></TT> that cannot be described in the 
contracts.</P>
<P>We remind the reader that the proposal consists of
largely orthogonal mechanisms which may be pursued in isolation. 
See <A class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#alternative-ways-to-realize-this-proposals">Alternative ways to realize this proposals</A> for a
discussion.</P>
<P>Work on Contract Programming exists in many other
languages and the most important may be found <A class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#list-of-contract-programming-resources">below</A>.</P>
</DIV>
<DIV class="section">
<H1><A id="major-changes-from-n1866" name="major-changes-from-n1866">2&nbsp;&nbsp;&nbsp;Major changes from </A><A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html">n1866</A></H1>
<OL class="arabic simple">
<LI>Removed support for alternative static assertions.</LI>
</OL>
<!--  -->
<OL class="arabic simple" start="2">
<LI>Removed support for namespace invariants.</LI>
</OL>
<!--  -->
<OL class="arabic simple" start="3">
<LI>Removed the notion of "importance ordering" <A class="footnote-reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#id45" id="id5" name="id5">[10]</A>.</LI>
</OL>
<!--  -->
</DIV>
<DIV class="section">
<H1><A class="toc-backref" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#id49" id="alternative-ways-to-realize-this-proposals" name="alternative-ways-to-realize-this-proposals">3&nbsp;&nbsp;&nbsp;Alternative ways to realize this proposals</A></H1>
<P>This proposal should be viewed a collection of different
proposals each building on the basic notion of assertions
and adding more and more features.</P>
<P>This lead us to the following possible proposals:</P>
<OL class="arabic simple">
<LI><A class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#functionx">preconditions</A></LI>
</OL>
<!--  -->
<OL class="arabic simple" start="2">
<LI>preconditions + <A class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#functionx">postconditions</A></LI>
</OL>
<!--  -->
<OL class="arabic simple" start="3">
<LI>preconditions + postconditions + <A class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#keywordoldof">oldof</A></LI>
</OL>
<!--  -->
<OL class="arabic simple" start="4">
<LI><A class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#class-invariants">class invariants</A></LI>
</OL>
<!--  -->
<OL class="arabic simple" start="5">
<LI>class invariants + <A class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#block-invariants">block invariants</A></LI>
</OL>
<!--  -->
<OL class="arabic simple" start="5">
<LI>any one of 1,2,3 combined with 4 or 5</LI>
</OL>
<P>Of course, it wouldn't make much sense to pursue only 
postconditions but not preconditions; clearly preconditions
are more essential than any of the other mechanisms.</P>
</DIV>
<DIV class="section">
<H1><A class="toc-backref" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#id50" id="the-proposal" name="the-proposal">4&nbsp;&nbsp;&nbsp;The proposal</A></H1>
<P>The idea is to extend C++</P>
<UL class="simple">
<LI>function declarations with <A class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#functionx">pre- and postconditions</A>,</LI>
</UL>
<!--  -->
<UL class="simple">
<LI>class declarations with <A class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#class-invariants">class invariants</A>,</LI>
</UL>
<!--  -->
<UL class="simple">
<LI>block scope with <A class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#block-invariants">block invariants</A>.</LI>
</UL>
<!-- - namespace declarations and block scope with `namespace invariants`_. -->
<P>These new <EM>contract scopes</EM> can contain <A class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#assertions">assertions</A> that
may be evaluated either at compile-time or at
run-time as part of the program to verify their correctness.</P>
<DIV class="section">
<H2><A class="toc-backref" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#id51" id="assertions" name="assertions">4.1&nbsp;&nbsp;&nbsp;Assertions</A></H2>
<P>The basic building blocks of contracts are 
<EM>assertions</EM>.</P>
<DIV class="section">
<H3><A class="toc-backref" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#id52" id="runtime-assertions" name="runtime-assertions">4.1.1&nbsp;&nbsp;&nbsp;Runtime assertions</A></H3>
<P>There are two flavors of assertions:</P>
<OL class="arabic">
<LI><P class="first"><EM>default</EM> assertions</P>
<BLOCKQUOTE>
<DL class="docutils">
<DT>syntax:</DT>
<DD><OL class="first last arabic simple">
<LI><EM>assertion</EM> : <EM>boolean-expression</EM> <TT class="docutils literal"><SPAN class="pre">;</SPAN></TT></LI>
</OL>
</DD>
<DT>example:</DT>
<DD><P class="first last"><TT class="docutils literal"><SPAN class="pre">std::cout.good();</SPAN></TT></P>
</DD>
</DL>
</BLOCKQUOTE>
</LI>
<LI><P class="first"><EM>select</EM> assertions</P>
<BLOCKQUOTE>
<DL class="docutils">
<DT>syntax:</DT>
<DD><OL class="first last arabic simple">
<LI><EM>assertion-sequence</EM> : <EM>assertion</EM></LI>
<LI><EM>assertion-sequence</EM> : <EM>assertion-sequence</EM> <EM>assertion</EM></LI>
<LI><EM>assertion-body</EM> : <EM>assertion</EM></LI>
<LI><EM>assertion-body</EM> : <TT class="docutils literal"><SPAN class="pre">{</SPAN></TT> <EM>assertion-sequence</EM> <TT class="docutils literal"><SPAN class="pre">}</SPAN></TT></LI>
<LI><EM>if-assertion</EM> : <TT class="docutils literal"><SPAN class="pre">if(</SPAN></TT> <EM>condition</EM> <TT class="docutils literal"><SPAN class="pre">)</SPAN></TT> <EM>assertion-body</EM> <EM>else-assertion</EM> <SUB>opt</SUB></LI>
<LI><EM>else-assertion</EM> : <TT class="docutils literal"><SPAN class="pre">else</SPAN></TT> <EM>assertion-body</EM></LI>
</OL>
</DD>
<DT>example:</DT>
<DD><DL class="first last docutils">
<DT><TT class="docutils literal"><SPAN class="pre">if(</SPAN> <SPAN class="pre">empty()</SPAN> <SPAN class="pre">)</SPAN></TT> </DT>
<DD><P class="first last"><TT class="docutils literal"><SPAN class="pre">result</SPAN> <SPAN class="pre">==</SPAN> <SPAN class="pre">end();</SPAN></TT></P>
</DD>
</DL>
</DD>
</DL>
</BLOCKQUOTE>
</LI>
</OL>
<P>The following general points are worth noting:</P>
<OL class="arabic">
<LI><P class="first">Default assertions defaults to calling <TT class="docutils literal"><SPAN class="pre">terminate()</SPAN></TT>, but the behavior can be <A class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#failure-handler-functions">customized</A>.</P>
<BLOCKQUOTE>
</BLOCKQUOTE>
</LI>
<LI><P class="first">The select assertions remove the need for the implication operator that was discussed in <A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2004/n1613.pdf">n1613</A>.</P>
</LI>
<LI><P class="first">The syntactic freedom has been kept minimal to ensure a good documentation effect.</P>
</LI>
<LI><P class="first">All visible functions and variables can be used within contract scope.</P>
</LI>
<LI><P class="first">Member reference within contract scope is subject to the same constraints as member reference within <TT class="docutils literal"><SPAN class="pre">const</SPAN></TT> member functions.</P>
</LI>
</OL>
<!-- Wrt. constness, then contract scope behaves as if it was a const member function [2]_. -->
<OL class="arabic simple" start="6">
<LI>If the compiler can determine that the condition of an assertion is true, it may choose not to evaluate 
that assertion.</LI>
</OL>
<!-- James have alternative wording  -->
<!--  -->
<OL class="arabic simple" start="7">
<LI>If the compiler can determine that the condition of an assertion is false, it may choose 
to call the <A class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#failure-handler-functions">broken contract handler</A> or call the action without evaluating that condition.</LI>
</OL>
</DIV>
</DIV>
<DIV class="section">
<H2><A class="toc-backref" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#id53" id="function-pre-and-postconditions" name="function-pre-and-postconditions"><SPAN id="functionx"></SPAN><SPAN id="function"></SPAN>4.2&nbsp;&nbsp;&nbsp;Function pre- and postconditions</A></H2>
<P>The function declaration and definition
are changed into:</P>
<BLOCKQUOTE>
<BLOCKQUOTE>
<OL class="arabic simple">
<LI><EM>precontracted-function</EM> : <EM>function-head</EM></LI>
<LI><EM>precontracted-function</EM> : <EM>function-head</EM> <EM>precondition-contract</EM></LI>
<LI><EM>postcontracted-function</EM> : <EM>precontracted-function</EM></LI>
<LI><EM>postcontracted-function</EM> : <EM>precontracted-function</EM> <EM>postcondition-contract</EM></LI>
<LI><EM>function-declaration</EM> : <EM>postcontracted-function</EM> <TT class="docutils literal"><SPAN class="pre">;</SPAN></TT></LI>
<LI><EM>function-definition</EM> : <EM>postcontracted-function</EM> <TT class="docutils literal"><SPAN class="pre">{</SPAN></TT> <EM>function-body</EM> <TT class="docutils literal"><SPAN class="pre">}</SPAN></TT></LI>
<LI><EM>precondition-contract</EM> : <TT class="docutils literal"><SPAN class="pre">precondition</SPAN> <SPAN class="pre">{</SPAN></TT> <EM>assertion-sequence</EM> <TT class="docutils literal"><SPAN class="pre">}</SPAN></TT></LI>
<LI><EM>postcondition-contract</EM> : <TT class="docutils literal"><SPAN class="pre">postcondition</SPAN></TT> <EM>return-value-declaration</EM><SUB>opt</SUB> <TT class="docutils literal"><SPAN class="pre">{</SPAN></TT> <EM>assertion-sequence</EM> <TT class="docutils literal"><SPAN class="pre">}</SPAN></TT></LI>
<LI><EM>return-value-declaration</EM>: <TT class="docutils literal"><SPAN class="pre">(</SPAN></TT> <EM>identifier</EM> <TT class="docutils literal"><SPAN class="pre">)</SPAN></TT></LI>
</OL>
</BLOCKQUOTE>
<P>example:</P>
<PRE class="literal-block">double sqrt( double r )
    precondition
    {
        r &gt; 0.;
    }
    postcondition( result )
    {
        equal_within_precision( result * result, r );
    }
</PRE>
</BLOCKQUOTE>
<P>In the <EM>return-value-declaration</EM> we declare a local variable that acts as a <TT class="docutils literal"><SPAN class="pre">const</SPAN></TT> reference to the computed 
return value. It follows that a <EM>return-value-declaration</EM> is illegal if the return type is <TT class="docutils literal"><SPAN class="pre">void</SPAN></TT>.</P>
<P>The following general rules apply:</P>
<OL class="arabic">
<LI><P class="first">If a function has both a declaration and a definition, the contracts must appear on the declaration.</P>
</LI>
<LI><P class="first"><SPAN class="target" id="the-execution-of-a-function">The execution of a function</SPAN> is now</P>
<BLOCKQUOTE>
<OL class="loweralpha simple">
<LI>evaluate the precondition assertion by assertion in order starting from the top,</LI>
</OL>
<!--  -->
<OL class="loweralpha simple" start="2">
<LI>evaluate <TT class="docutils literal"><SPAN class="pre">oldof</SPAN></TT> occurrences in the postcondition,</LI>
</OL>
<!--  -->
<OL class="loweralpha simple" start="3">
<LI>evaluate the function body,</LI>
</OL>
<!--  -->
<OL class="loweralpha simple" start="4">
<LI>evaluate the postcondition assertion by assertion in order starting from the top <A class="footnote-reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#id46" id="id12" name="id12">[11]</A>.</LI>
</OL>
</BLOCKQUOTE>
</LI>
<LI><P class="first">The execution of a member function is now as in 2, but</P>
<BLOCKQUOTE>
<OL class="loweralpha simple">
<LI><TT class="docutils literal"><SPAN class="pre">2.a</SPAN></TT> is <EM>followed</EM> by a call to the class invariant <A class="footnote-reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#id44" id="id13" name="id13">[9]</A></LI>
</OL>
<!--  -->
<OL class="loweralpha simple" start="2">
<LI><TT class="docutils literal"><SPAN class="pre">2.d</SPAN></TT> is <EM>preceded</EM> by a call to the class invariant,</LI>
</OL>
</BLOCKQUOTE>
</LI>
<LI><P class="first">Function-try-blocks can appear together with pre- and postconditions on function
definitions.</P>
</LI>
<LI><P class="first">Pre- and postconditions are evaluated outside any function-try-block.</P>
</LI>
<LI><P class="first">During execution of the postcondition other contracts (recursively encountered) are <EM>not</EM> evaluated.</P>
</LI>
</OL>
<DIV class="section">
<H3><A class="toc-backref" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#id54" id="virtual-functions" name="virtual-functions">4.2.1&nbsp;&nbsp;&nbsp;Virtual functions</A></H3>
<P>If the function <TT class="docutils literal"><SPAN class="pre">F</SPAN></TT> is virtual, we require that</P>
<OL class="arabic simple">
<LI>only the base virtual function of <TT class="docutils literal"><SPAN class="pre">F</SPAN></TT> can have a precondition.</LI>
</OL>
<P>Section <TT class="docutils literal"><SPAN class="pre">3.5</SPAN></TT> of <A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2004/n1613.pdf">n1613</A> explains how little redefinition of preconditions is used. Even though
subcontracting is theoretically sound, it ends up being fairly useless in practice <A class="footnote-reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#id38" id="id14" name="id14">[3]</A>.</P>
<P>Postconditions can be made stronger in a derived class as seen in the <A class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#subcontracting-example-hpp">subcontracting_example.hpp</A>.
We can summarize the remaining rules for virtual functions as</P>
<OL class="arabic simple" start="2">
<LI>pure virtual functions can have contracts,</LI>
</OL>
<!--  -->
<OL class="arabic simple" start="3">
<LI>postconditions from a function in a base class and the overridden version in a derived class
are <EM>AND</EM>ed together <A class="footnote-reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#id39" id="id15" name="id15">[4]</A>.</LI>
</OL>
<P>The last rule ensures that the function in the derived class has a stronger postcondition <EM>by design</EM>.
A programmer can via a downcast obtain the stronger guarantee, but the runtime check must still
follow rule 3 above.</P>
<P>In connection with multiple inheritance we require special rules.
if <TT class="docutils literal"><SPAN class="pre">F</SPAN></TT> overrides more than one virtual function due to multiple inheritance,
it holds that</P>
<OL class="arabic simple" start="4">
<LI>the precondition on <TT class="docutils literal"><SPAN class="pre">F</SPAN></TT> is an <EM>OR</EM>ing of the preconditions of all the
functions <TT class="docutils literal"><SPAN class="pre">F</SPAN></TT> override,</LI>
</OL>
<!--  -->
<OL class="arabic simple" start="5">
<LI>the postcondition on <TT class="docutils literal"><SPAN class="pre">F</SPAN></TT> is an <EM>AND</EM>ing of (1) the postconditions of all the
functions <TT class="docutils literal"><SPAN class="pre">F</SPAN></TT> override and (2) <TT class="docutils literal"><SPAN class="pre">F</SPAN></TT>'s own postcondition.</LI>
</OL>
</DIV>
<DIV class="section">
<H3><A class="toc-backref" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#id55" id="constructors" name="constructors">4.2.2&nbsp;&nbsp;&nbsp;Constructors</A></H3>
<P>Constructors behave much like member functions. This means that a constructor
can have a precondition and a postcondition. The precondition may not
reference member variables.</P>
</DIV>
<DIV class="section">
<H3><A class="toc-backref" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#id56" id="function-pointers" name="function-pointers">4.2.3&nbsp;&nbsp;&nbsp;Function pointers</A></H3>
<P>If the address of a function is taken, it holds that</P>
<OL class="arabic simple">
<LI>the precondition is evaluated before the function body when the function is called 
through the function pointer.</LI>
</OL>
<P>Remark: A compiler might be able to determine that the precondition is satisfied, in that case
the compiler may generate a call directly to the function body 
(thus sharing implementation with the function pointer call).</P>
</DIV>
</DIV>
<DIV class="section">
<H2><A class="toc-backref" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#id57" id="keyword-oldof" name="keyword-oldof"><SPAN id="keywordoldof"></SPAN>4.3&nbsp;&nbsp;&nbsp;Keyword <TT class="docutils literal docutils literal"><SPAN class="pre">oldof</SPAN></TT></A></H2>
<P>It is very useful to be able to take a copy of a variable to compare
it with other values later. In particular, this is true in <A class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#function">function postconditions</A>.</P>
<P>Assume <TT class="docutils literal"><SPAN class="pre">i</SPAN></TT> is a visible <TT class="docutils literal"><SPAN class="pre">int</SPAN></TT>, then the compiler translates</P>
<PRE class="literal-block">{
    oldof i == 42;
}
</PRE>
<P>into</P>
<PRE class="literal-block">{
    const int __old_i( i );
    __old_i == 42;
}
</PRE>
<P>A set of rules govern how <TT class="docutils literal"><SPAN class="pre">oldof</SPAN></TT> behaves within a certain contract:</P>
<OL class="arabic simple">
<LI>If it is applied to the same expression <EM>n</EM> times, that expression need only be
evaluated once and only one copy need to be stored.</LI>
</OL>
<!--  -->
<OL class="arabic simple" start="2">
<LI>The copy of its argument is taken <EM>after</EM> the precondition is evaluated and <EM>before</EM>
the function body is evaluated.</LI>
</OL>
<P>The precondition should be evaluated first to allow it to report its errors first.
Notice that we can only apply <TT class="docutils literal"><SPAN class="pre">oldof</SPAN></TT> to objects of a type that defines a copy-constructor 
taking a <TT class="docutils literal"><SPAN class="pre">const</SPAN></TT> reference (ie., <TT class="docutils literal"><SPAN class="pre">std::auto_ptr</SPAN></TT> cannot be used).</P>
</DIV>
<DIV class="section">
<H2><A class="toc-backref" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#id58" id="class-invariants" name="class-invariants">4.4&nbsp;&nbsp;&nbsp;Class invariants</A></H2>
<P>Within class scope it is possible to define a class invariant:</P>
<BLOCKQUOTE>
<DL class="docutils">
<DT>syntax:</DT>
<DD><OL class="first last arabic simple">
<LI><EM>class-invariant</EM> : <TT class="docutils literal"><SPAN class="pre">invariant</SPAN> <SPAN class="pre">{</SPAN></TT> <EM>assertion-sequence</EM> <TT class="docutils literal"><SPAN class="pre">}</SPAN></TT></LI>
</OL>
</DD>
<DT>example: </DT>
<DD>see <A class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#vector-example-hpp">vector_example.hpp</A></DD>
</DL>
</BLOCKQUOTE>
<P>The class invariant has the following properties:</P>
<OL class="arabic">
<LI><P class="first">It must appear in the declaration of a class.</P>
</LI>
<LI><P class="first">It is inherited in the sense that the invariant of a derived class <EM>implicitly</EM> will have the base-class invariant(s)
<EM>AND</EM>ed to it (see also item 6-7).</P>
<BLOCKQUOTE>
<P>example:</P>
<PRE class="literal-block">struct base { invariant { ... } };
struct derived : base
{
    invariant
    {
        base::invariant(); // implicitly generated
        ...
    }
};
</PRE>
<P>(Remark: the above is pseudo-code and is <EM>not</EM> affected by the disabling of assertions within assertions.)</P>
</BLOCKQUOTE>
</LI>
<LI><P class="first">It is called <EM>implicitly</EM> from public</P>
<BLOCKQUOTE>
<OL class="loweralpha simple">
<LI><A class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#function">pre- and postconditions</A>,</LI>
</OL>
<OL class="loweralpha" start="2">
<LI><P class="first">constructors,</P>
<BLOCKQUOTE>
<UL class="simple">
<LI>call the class invariant <EM>before</EM> the postcondition,</LI>
</UL>
</BLOCKQUOTE>
</LI>
<LI><P class="first">destructors,</P>
<BLOCKQUOTE>
<UL class="simple">
<LI>call the class invariant <EM>before</EM> the destructor body.</LI>
</UL>
</BLOCKQUOTE>
</LI>
<LI><P class="first">member functions that exit abnormally via an exception <A class="footnote-reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#id40" id="id18" name="id18">[5]</A></P>
</LI>
</OL>
</BLOCKQUOTE>
</LI>
<LI><P class="first"><SPAN class="target" id="it-is-always-called">It is always called</SPAN> as if surrounded by a try-catch block:</P>
<PRE class="literal-block">try
{
    class_invariant();
}
catch( ... )
{
    std::class_invariant_broken();
}
</PRE>
</LI>
</OL>
<BLOCKQUOTE>
<UL class="simple">
<LI>rationale: this ensures that exceptions thrown in the invariant cannot escape from functions 
and in particular not from the destructor. <A class="footnote-reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#id41" id="id19" name="id19">[6]</A></LI>
</UL>
</BLOCKQUOTE>
<OL class="arabic" start="5">
<LI><P class="first">For its execution <EM>during</EM> construction <A class="footnote-reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#id42" id="id20" name="id20">[7]</A> holds that:</P>
<BLOCKQUOTE>
<OL class="loweralpha">
<LI><P class="first">each assertion is executed in order starting from the top <EM>excluding</EM> any part inherited,</P>
<BLOCKQUOTE>
<UL class="simple">
<LI>rationale: if we do not exclude inherited parts, those parts would be evaluated multiple times.</LI>
</UL>
</BLOCKQUOTE>
</LI>
</OL>
</BLOCKQUOTE>
</LI>
<LI><P class="first">For its execution <EM>after</EM> construction holds that:</P>
<BLOCKQUOTE>
<OL class="loweralpha simple">
<LI>each assertion is executed in order starting from the top <EM>including</EM> any part inherited,</LI>
<LI>if the class has any sub-classes, then the inherited portion is executed first,</LI>
<LI>if the class has several sub-classes the order of the classes in the base-clause is followed.</LI>
</OL>
</BLOCKQUOTE>
</LI>
<LI><P class="first">During execution of the invariant other contracts (recursively encountered) are <EM>not</EM> evaluated.</P>
</LI>
</OL>
</DIV>
<DIV class="section">
<H2><A class="toc-backref" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#id59" id="block-invariants" name="block-invariants">4.5&nbsp;&nbsp;&nbsp;block invariants</A></H2>
<P>To better support assertions at block scope we use block invariants:</P>
<BLOCKQUOTE>
<DL class="docutils">
<DT>syntax:    </DT>
<DD><OL class="first last arabic simple">
<LI><EM>block-invariant</EM>: <TT class="docutils literal"><SPAN class="pre">invariant</SPAN> <SPAN class="pre">{</SPAN></TT> <EM>assertion-sequence</EM> <TT class="docutils literal"><SPAN class="pre">}</SPAN></TT></LI>
</OL>
</DD>
</DL>
<P>example:</P>
<PRE class="literal-block">void foo()
{
    int i = 0;
    for(;;)
    {
        invariant { i &lt; 10; }
        ...
    }
}
</PRE>
</BLOCKQUOTE>
<P>The block invariants use the same syntax as the class invariant.
The properties of block invariants are:</P>
<OL class="arabic">
<LI><P class="first">they can appear multiple times in the same scope,</P>
</LI>
<LI><P class="first">they are always called as if surrounded by a try-catch block:</P>
<PRE class="literal-block">try
{
    block_invariant(); // pseudo code
}
catch( ... )
{
    std::block_invariant_broken();
}
</PRE>
</LI>
<LI><P class="first">the order of evaluation of the assertions in an invariant is from top to bottom,</P>
</LI>
</OL>
</DIV>
<DIV class="section">
<H2><A class="toc-backref" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#id60" id="failure-handler-functions" name="failure-handler-functions">4.6&nbsp;&nbsp;&nbsp;Failure handler functions</A></H2>
<P>The default behavior for all default assertions is to call <TT class="docutils literal"><SPAN class="pre">terminate()</SPAN></TT> via a call
to their respective handler. As seen below, we have a handler for each type of contract.
If the default behavior
is undesirable, the standard library provides the following handlers:</P>
<PRE class="literal-block">namespace std
{        
    void precondition_broken();
    void postcondition_broken();
    void class_invariant_broken();
    void block_invariant_broken();
    
    typedef void (*broken_contract_handler)();
    
    broken_contract_handler  set_precondition_broken_handler( broken_contract_handler r ) throw();
    broken_contract_handler  set_postcondition_broken_handler( broken_contract_handler r ) throw();
    broken_contract_handler  set_class_invariant_broken_handler( broken_contract_handler r ) throw();
    broken_contract_handler  set_block_invariant_handler( broken_contract_handler r ) throw();
}
</PRE>
<P>This should provide plenty of room for customization. The precondition for all the <TT class="docutils literal"><SPAN class="pre">set_XX_handler</SPAN></TT>
functions should be <TT class="docutils literal"><SPAN class="pre">r</SPAN> <SPAN class="pre">!=</SPAN> <SPAN class="pre">0</SPAN></TT>.</P>
</DIV>
<DIV class="section">
<H2><A class="toc-backref" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#id61" id="changes-to-the-standard-library" name="changes-to-the-standard-library">4.7&nbsp;&nbsp;&nbsp;Changes to the standard library</A></H2>
<P>We suggest that no required changes should be made to
the standard library. An implementation is free to
implement all standard guarantees in terms of contract
code, but not required to.</P>
<!-- ======================================
IDEA PROPOSAL VERSUS STANDARDS CHANGES
======================================

This proposal presents ideas and syntax.  It is not itself a proposal
for changes in the text of the standard.  It is not yet time for text
changes.  The distinction enables us to mention the following two
subjects. -->
</DIV>
</DIV>
<DIV class="section">
<H1><A class="toc-backref" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#id62" id="contracts-for-performance" name="contracts-for-performance">5&nbsp;&nbsp;&nbsp;Contracts for performance</A></H1>
<P>This section discusses how contracts can help the compiler
to generate faster code.</P>
<P>A limited form of contract programming is the use of the <TT class="docutils literal"><SPAN class="pre">assert()</SPAN></TT>
macro.  Its use is standard practice in many software
projects.  Unfortunately, it suffers from several problems.  We
will evaluate these problems by distinguishing between a
library and its client.</P>
<DIV class="section">
<H2><A class="toc-backref" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#id63" id="assert-is-evaluated-within-the-library" name="assert-is-evaluated-within-the-library">5.1&nbsp;&nbsp;&nbsp;<TT class="docutils literal docutils literal"><SPAN class="pre">assert()</SPAN></TT> is evaluated within the library</A></H2>
<P>As a consequence, the enabling or disabling of
assertion checking is a compile-time decision of the
library.  The result is generally either</P>
<OL class="arabic simple">
<LI>no checking, in which case errors are lost, or</LI>
<LI>checking, in which case performance is lost.</LI>
</OL>
<P>In contrast, preconditions may be evaluated in the
client.  The client decides on the acceptable tradeoff
between performance and checking.</P>
</DIV>
<DIV class="section">
<H2><A class="toc-backref" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#id64" id="assert-fails-to-distinguish-between-checking-arguments-and-validating-computations" name="assert-fails-to-distinguish-between-checking-arguments-and-validating-computations">5.2&nbsp;&nbsp;&nbsp;<TT class="docutils literal docutils literal"><SPAN class="pre">assert()</SPAN></TT> fails to distinguish between checking arguments and validating computations</A></H2>
<P>In well-tested production code, validating computation
is rarely needed, because the function has proven
itself.  On the other hand, checking arguments has
continuing need because of the evolution of callers.
With only a single form, programmers that turn off
validating computation for performance, will also turn
off checking arguments.</P>
<P>In contrast, the proposed syntactic distinction between
preconditions, postconditions and invariants preserves the very
real need to enable them separately.</P>
</DIV>
<DIV class="section">
<H2><A class="toc-backref" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#id65" id="assert-is-indistinguishable-from-regular-code" name="assert-is-indistinguishable-from-regular-code">5.3&nbsp;&nbsp;&nbsp;<TT class="docutils literal docutils literal"><SPAN class="pre">assert()</SPAN></TT> is indistinguishable from regular code</A></H2>
<P>As a consequence it is very difficult for a compiler to
make use of the contents of an <TT class="docutils literal"><SPAN class="pre">assert()</SPAN></TT> macro.</P>
<P>In contrast, preconditions, postconditions and invariants are very
visible to the compiler.  The compiler can use preconditions
and postconditions as a constraint on the value-space of
the code, which in turn enables optimization.</P>
<P>Explicit preconditions and postconditions enable optimization
in two ways.</P>
<OL class="arabic">
<LI><P class="first">The compiler can eliminate conditions known statically.</P>
<BLOCKQUOTE>
<P>For example, given</P>
<PRE class="literal-block">char *foo()
postcondition( result ) { result != 0; };

void bar( char *arg )
precondition { arg != 0; }
...
bar( foo() )
</PRE>
<P>the compiler can propagate the postcondition of <TT class="docutils literal"><SPAN class="pre">foo()</SPAN></TT>
to the precondition of <TT class="docutils literal"><SPAN class="pre">bar()</SPAN></TT> and entirely eliminate
the precondition checking in <TT class="docutils literal"><SPAN class="pre">bar()</SPAN></TT>.</P>
</BLOCKQUOTE>
</LI>
<LI><P class="first">The compiler can use conditions to guide code generation.</P>
<BLOCKQUOTE>
<P>For example, given</P>
<PRE class="literal-block">double sum( int count, double array[] )
precondition { count % 4 == 0; }
{
    double accum = 0.0;
    for ( int i = 0; i &lt; count; i++ )
            accum += array[i];
    return accum;
}
</PRE>
<P>the compiler can unroll the loop four times, and avoid
generating the stuttering at the start of the loop.</P>
<P>Furthermore, given the same code but with a precondition of
<TT class="docutils literal"><SPAN class="pre">count</SPAN> <SPAN class="pre">&gt;</SPAN> <SPAN class="pre">1000</SPAN></TT>, the compiler could chose to implement the
loop in parallel.  Likewise, with <TT class="docutils literal"><SPAN class="pre">count&lt;</SPAN> <SPAN class="pre">100</SPAN></TT>, the
compiler may forgo any checking for the possibility of
parallelism.</P>
</BLOCKQUOTE>
</LI>
</OL>
<!-- ``assert()`` does not allow the compiler to warn about side-effects
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
</DIV>
</DIV>
<DIV class="section">
<H1><A class="toc-backref" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#id66" id="implementation-model-for-contracts" name="implementation-model-for-contracts">6&nbsp;&nbsp;&nbsp;Implementation model for contracts</A></H1>
<P>This section discusses the feasibility of
implementation.  We provide an
implementation model that is reasonable and consistent with the
above proposal.</P>
<P>Consider the function</P>
<PRE class="literal-block">int factorial( int n )
precondition 
{
    0 &lt;= n &amp;&amp; n &lt;= 12;
}
postcondition( result ) 
{
    result &gt;= 1;
}
{
    if ( n &lt; 2 )
        return 1;
    else
        return n * factorial( n - 1 );
}
</PRE>
<P>When all conditions are enabled, the compiler generates three
functions:</P>
<OL class="arabic">
<LI><P class="first">The <EM>core function</EM> without any surrounding condition checking.</P>
<BLOCKQUOTE>
<P>Call this function when compiler switches disable all
condition evaluation.</P>
</BLOCKQUOTE>
</LI>
<LI><P class="first">A <EM>postcondition evaluator</EM>, which</P>
<BLOCKQUOTE>
<OL class="loweralpha simple">
<LI>saves <TT class="docutils literal"><SPAN class="pre">oldof</SPAN></TT> values</LI>
</OL>
<!--  -->
<OL class="loweralpha simple" start="2">
<LI>evaluates class invariant</LI>
</OL>
<!--  -->
<OL class="loweralpha simple" start="3">
<LI>calls core function</LI>
</OL>
<!--  -->
<OL class="loweralpha simple" start="4">
<LI>evaluates class invariant</LI>
</OL>
<!--  -->
<OL class="loweralpha" start="5">
<LI><P class="first">evaluates the postcondition.</P>
<BLOCKQUOTE>
<P>Call this function from normal code when the caller
evaluates the preconditions.</P>
</BLOCKQUOTE>
</LI>
</OL>
</BLOCKQUOTE>
</LI>
<LI><P class="first">A <EM>precondition evaluator</EM>, which executes the precondition
and then calls the postcondition evaluator.</P>
<BLOCKQUOTE>
<P>Call this function when the caller does not or cannot
evaluate the preconditions. (Remark: the precondition evaluator
would for example be used when
a function is called via a function-pointer.)</P>
</BLOCKQUOTE>
</LI>
</OL>
<P>When postconditions and invariants are disabled, probably a library-build-time
decision, the first two functions above are identical, and may
be implemented as a single function with two labels.</P>
<P>When preconditions are disabled, a client-build-time decision,
the client simply calls the second function.</P>
<P>As an additional performance option, compilers can turn
of invariant evaluation while still enabling other conditions.
Furthermore, a compiler might choose to provide a switch for
generating a single call to the invariant in the constructor.</P>
<!-- Inside postconditions, pre- and postconditions are disabled. This is 
for example implemented by dispatching directly to the core function. -->
</DIV>
<DIV class="section">
<H1><A class="toc-backref" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#id67" id="list-of-proposals-that-could-be-affected-by-this-proposal" name="list-of-proposals-that-could-be-affected-by-this-proposal">7&nbsp;&nbsp;&nbsp;List of proposals that could be affected by this proposal</A></H1>
<OL class="arabic simple">
<LI>Concepts as described in <A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2003/n1510.pdf">n1510</A>, <A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2003/n1522.pdf">n1522</A>, <A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2003/n1536.pdf">n1536</A> and <A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1758.pdf">n1758</A>.</LI>
</OL>
<!--  -->
<OL class="arabic simple" start="2">
<LI>Any proposal that seeks to enhance meta-programming capabilities.</LI>
</OL>
<!--  -->
<OL class="arabic simple" start="3">
<LI>Proposals that seek to add special pragma-like attributes to 
block of code <A class="footnote-reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#id45" id="id21" name="id21">[10]</A>.</LI>
</OL>
</DIV>
<DIV class="section">
<H1><A class="toc-backref" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#id68" id="implementability" name="implementability">8&nbsp;&nbsp;&nbsp;Implementability</A></H1>
<P>We expect that it will take about 3 man months to implement the proposal without
dedicating any time to optimizations.</P>
</DIV>
<DIV class="section">
<H1><A class="toc-backref" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#id69" id="alternative-syntax" name="alternative-syntax">9&nbsp;&nbsp;&nbsp;Alternative syntax</A></H1>
<P>In Lillehammer it was suggested to
use normal C++ syntax for separation
of assertions. In particular it was suggested
to write an assertion-sequence as</P>
<PRE class="literal-block">{
    foo() &amp;&amp;
    bar() &amp;&amp;
    true;
}
</PRE>
<P>instead of</P>
<PRE class="literal-block">{
    foo();
    bar();
    true;
} 
</PRE>
<!-- A full example have been made with the proposed
syntax (see vector_example_alternative_syntax.hpp_). -->
<P>It is quite obvious that this syntax has the following
drawbacks:</P>
<OL class="arabic simple">
<LI>it becomes harder for debuggers to break on
individual assertions, because the whole assertion-sequence
is a single statement</LI>
</OL>
<!--  -->
<OL class="arabic simple" start="2">
<LI>the ternary operator is much harder to read than if-statements</LI>
</OL>
<!--  -->
</DIV>
<DIV class="section">
<H1><A class="toc-backref" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#id70" id="list-of-examples" name="list-of-examples">10&nbsp;&nbsp;&nbsp;List of examples</A></H1>
<UL class="simple">
<LI><A class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#vector-example-hpp">vector_example.hpp</A></LI>
<LI><A class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#subcontracting-example-hpp">subcontracting_example.hpp</A></LI>
<LI><A class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#recursion-example">recursion example</A></LI>
</UL>
<DIV class="section">
<H2><A class="toc-backref" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#id71" id="vector-example-hpp" name="vector-example-hpp">10.1&nbsp;&nbsp;&nbsp;vector_example.hpp</A></H2>




<LINK rel="stylesheet" href="./Ottosen2006_Proposal_Rev4-n1962_files/style.css" type="text/css">



<PRE>
<SPAN class="comment">///////////////////////////////////////
// Tools
///////////////////////////////////////</SPAN>

<SPAN class="keyword">template</SPAN><SPAN class="special">&lt;</SPAN> <SPAN class="keyword">class</SPAN> <SPAN class="identifier">Iter</SPAN><SPAN class="special">,</SPAN> <SPAN class="keyword">class</SPAN> <SPAN class="identifier">T</SPAN> <SPAN class="special">&gt;</SPAN>
<SPAN class="keyword">bool</SPAN> <SPAN class="identifier">all_equals</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">Iter</SPAN> <SPAN class="identifier">first</SPAN><SPAN class="special">,</SPAN> <SPAN class="identifier">Iter</SPAN> <SPAN class="identifier">last</SPAN><SPAN class="special">,</SPAN> <SPAN class="keyword">const</SPAN> <SPAN class="identifier">T</SPAN><SPAN class="special">&amp;</SPAN> <SPAN class="identifier">val</SPAN> <SPAN class="special">)</SPAN>
<SPAN class="special">{</SPAN> <SPAN class="comment">/* for simplicity, let us assume T's can be compared */</SPAN> <SPAN class="special">}</SPAN>

<SPAN class="keyword">template</SPAN><SPAN class="special">&lt;</SPAN> <SPAN class="keyword">class</SPAN> <SPAN class="identifier">Iter</SPAN><SPAN class="special">,</SPAN> <SPAN class="keyword">class</SPAN> <SPAN class="identifier">Size</SPAN> <SPAN class="special">&gt;</SPAN>
<SPAN class="keyword">bool</SPAN> <SPAN class="identifier">equal_distance</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">Iter</SPAN> <SPAN class="identifier">first</SPAN><SPAN class="special">,</SPAN> <SPAN class="identifier">Iter</SPAN> <SPAN class="identifier">last</SPAN><SPAN class="special">,</SPAN> <SPAN class="identifier">Size</SPAN> <SPAN class="identifier">size</SPAN> <SPAN class="special">)</SPAN>
<SPAN class="special">{</SPAN> <SPAN class="comment">/* internal tagging mechnism so even input iterators can be passed */</SPAN> <SPAN class="special">}</SPAN>

<SPAN class="comment">///////////////////////////////////////
// New vector interface
///////////////////////////////////////</SPAN>

<SPAN class="keyword">template</SPAN><SPAN class="special">&lt;</SPAN> <SPAN class="keyword">class</SPAN> <SPAN class="identifier">T</SPAN><SPAN class="special">,</SPAN> <SPAN class="keyword">class</SPAN> <SPAN class="identifier">Alloc</SPAN> <SPAN class="special">=</SPAN> <SPAN class="identifier">allocator</SPAN><SPAN class="special">&lt;</SPAN><SPAN class="identifier">T</SPAN><SPAN class="special">&gt;</SPAN> <SPAN class="special">&gt;</SPAN>
<SPAN class="keyword">class</SPAN> <SPAN class="identifier">vector</SPAN> 
<SPAN class="special">{</SPAN>
    <SPAN class="keyword">invariant</SPAN>
    <SPAN class="special">{</SPAN>
        <SPAN class="special">(</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">==</SPAN> <SPAN class="number">0</SPAN> <SPAN class="special">)</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">empty</SPAN><SPAN class="special">();</SPAN>
        <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">std</SPAN><SPAN class="special">::</SPAN><SPAN class="identifier">distance</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">begin</SPAN><SPAN class="special">(),</SPAN> <SPAN class="identifier">end</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">);</SPAN>
        <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">std</SPAN><SPAN class="special">::</SPAN><SPAN class="identifier">distance</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">rbegin</SPAN><SPAN class="special">(),</SPAN> <SPAN class="identifier">rend</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">);</SPAN>
        <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">&lt;=</SPAN> <SPAN class="identifier">capacity</SPAN><SPAN class="special">();</SPAN>
        <SPAN class="identifier">capacity</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">&lt;=</SPAN> <SPAN class="identifier">max_size</SPAN><SPAN class="special">();</SPAN>
    <SPAN class="special">}</SPAN>
    
    
<SPAN class="keyword">public</SPAN><SPAN class="special">:</SPAN>
    <SPAN class="keyword">typedef</SPAN> <SPAN class="identifier">Alloc</SPAN>                             <SPAN class="identifier">allocator_type</SPAN><SPAN class="special">;</SPAN>
    <SPAN class="keyword">typedef</SPAN> <SPAN class="keyword">typename</SPAN> <SPAN class="identifier">Alloc</SPAN><SPAN class="special">::</SPAN><SPAN class="identifier">pointer</SPAN>           <SPAN class="identifier">pointer</SPAN><SPAN class="special">;</SPAN>
    <SPAN class="keyword">typedef</SPAN> <SPAN class="keyword">typename</SPAN> <SPAN class="identifier">Alloc</SPAN><SPAN class="special">::</SPAN><SPAN class="identifier">const_pointer</SPAN>     <SPAN class="identifier">const_pointer</SPAN><SPAN class="special">;</SPAN>
    <SPAN class="keyword">typedef</SPAN> <SPAN class="keyword">typename</SPAN> <SPAN class="identifier">Alloc</SPAN><SPAN class="special">::</SPAN><SPAN class="identifier">reference</SPAN>         <SPAN class="identifier">reference</SPAN><SPAN class="special">;</SPAN>
    <SPAN class="keyword">typedef</SPAN> <SPAN class="keyword">typename</SPAN> <SPAN class="identifier">Alloc</SPAN><SPAN class="special">::</SPAN><SPAN class="identifier">const_reference</SPAN>   <SPAN class="identifier">const_reference</SPAN><SPAN class="special">;</SPAN>
    <SPAN class="keyword">typedef</SPAN> <SPAN class="keyword">typename</SPAN> <SPAN class="identifier">Alloc</SPAN><SPAN class="special">::</SPAN><SPAN class="identifier">value_type</SPAN>        <SPAN class="identifier">value_type</SPAN><SPAN class="special">;</SPAN>
    <SPAN class="keyword">typedef</SPAN> <SPAN class="special">...</SPAN>                               <SPAN class="identifier">iterator</SPAN><SPAN class="special">;</SPAN>
    <SPAN class="keyword">typedef</SPAN> <SPAN class="special">...</SPAN>                               <SPAN class="identifier">const_iterator</SPAN><SPAN class="special">;</SPAN>
    <SPAN class="keyword">typedef</SPAN> <SPAN class="special">...</SPAN>                               <SPAN class="identifier">size_type</SPAN><SPAN class="special">;</SPAN>
    <SPAN class="keyword">typedef</SPAN> <SPAN class="special">...</SPAN>                               <SPAN class="identifier">difference_type</SPAN><SPAN class="special">;</SPAN>
    <SPAN class="keyword">typedef</SPAN> <SPAN class="identifier">reverse_iterator</SPAN><SPAN class="special">&lt;</SPAN><SPAN class="identifier">iterator</SPAN><SPAN class="special">&gt;</SPAN>        <SPAN class="identifier">reverse_iterator</SPAN><SPAN class="special">;</SPAN>
    <SPAN class="keyword">typedef</SPAN> <SPAN class="identifier">reverse_iterator</SPAN><SPAN class="special">&lt;</SPAN><SPAN class="identifier">const_iterator</SPAN><SPAN class="special">&gt;</SPAN>  <SPAN class="identifier">const_reverse_iterator</SPAN><SPAN class="special">;</SPAN>

             <SPAN class="identifier">vector</SPAN><SPAN class="special">()</SPAN>                  
                 <SPAN class="keyword">postcondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="identifier">empty</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN> 
                 
    <SPAN class="keyword">explicit</SPAN> <SPAN class="identifier">vector</SPAN><SPAN class="special">(</SPAN> <SPAN class="keyword">const</SPAN> <SPAN class="identifier">Alloc</SPAN><SPAN class="special">&amp;</SPAN> <SPAN class="identifier">al</SPAN> <SPAN class="special">)</SPAN> 
                 <SPAN class="keyword">postcondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="identifier">empty</SPAN><SPAN class="special">();</SPAN> 
                                 <SPAN class="identifier">al</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">get_allocator</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
                 
    <SPAN class="keyword">explicit</SPAN> <SPAN class="identifier">vector</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">size_type</SPAN> <SPAN class="identifier">count</SPAN> <SPAN class="special">)</SPAN> 
                 <SPAN class="keyword">postcondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">count</SPAN><SPAN class="special">;</SPAN> 
                                 <SPAN class="identifier">all_equals</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">begin</SPAN><SPAN class="special">(),</SPAN> <SPAN class="identifier">end</SPAN><SPAN class="special">(),</SPAN> <SPAN class="identifier">T</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">);</SPAN> <SPAN class="special">}</SPAN>
                 
             <SPAN class="identifier">vector</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">size_type</SPAN> <SPAN class="identifier">count</SPAN><SPAN class="special">,</SPAN> <SPAN class="keyword">const</SPAN> <SPAN class="identifier">T</SPAN><SPAN class="special">&amp;</SPAN> <SPAN class="identifier">val</SPAN> <SPAN class="special">)</SPAN> 
                 <SPAN class="keyword">postcondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">count</SPAN><SPAN class="special">;</SPAN> 
                                 <SPAN class="identifier">all_equals</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">begin</SPAN><SPAN class="special">(),</SPAN> <SPAN class="identifier">end</SPAN><SPAN class="special">(),</SPAN> <SPAN class="identifier">val</SPAN> <SPAN class="special">);</SPAN> <SPAN class="special">}</SPAN>
             
             <SPAN class="identifier">vector</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">size_type</SPAN> <SPAN class="identifier">count</SPAN><SPAN class="special">,</SPAN> <SPAN class="keyword">const</SPAN> <SPAN class="identifier">T</SPAN><SPAN class="special">&amp;</SPAN> <SPAN class="identifier">val</SPAN><SPAN class="special">,</SPAN> <SPAN class="keyword">const</SPAN> <SPAN class="identifier">Alloc</SPAN><SPAN class="special">&amp;</SPAN> <SPAN class="identifier">al</SPAN> <SPAN class="special">)</SPAN> 
                 <SPAN class="keyword">postcondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="identifier">size</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">count</SPAN><SPAN class="special">;</SPAN> 
                                 <SPAN class="identifier">all_equals</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">begin</SPAN><SPAN class="special">(),</SPAN> <SPAN class="identifier">end</SPAN><SPAN class="special">(),</SPAN> <SPAN class="identifier">val</SPAN> <SPAN class="special">);</SPAN> 
                                 <SPAN class="identifier">al</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">get_allocator</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}:</SPAN>
             
             <SPAN class="identifier">vector</SPAN><SPAN class="special">(</SPAN> <SPAN class="keyword">const</SPAN> <SPAN class="identifier">vector</SPAN><SPAN class="special">&amp;</SPAN> <SPAN class="identifier">right</SPAN> <SPAN class="special">)</SPAN> 
                 <SPAN class="keyword">postcondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="identifier">right</SPAN> <SPAN class="special">==</SPAN> <SPAN class="special">*</SPAN><SPAN class="keyword">this</SPAN><SPAN class="special">;</SPAN> <SPAN class="special">}</SPAN>
    
             <SPAN class="keyword">template</SPAN><SPAN class="special">&lt;</SPAN> <SPAN class="keyword">class</SPAN> <SPAN class="identifier">InIt</SPAN> <SPAN class="special">&gt;</SPAN>
             <SPAN class="identifier">vector</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">InIt</SPAN> <SPAN class="identifier">first</SPAN><SPAN class="special">,</SPAN> <SPAN class="identifier">InIt</SPAN> <SPAN class="identifier">last</SPAN> <SPAN class="special">)</SPAN> 
                 <SPAN class="keyword">postcondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="identifier">equal_distance</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">first</SPAN><SPAN class="special">,</SPAN> <SPAN class="identifier">last</SPAN><SPAN class="special">,</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">);</SPAN> <SPAN class="special">}</SPAN>
                 
             <SPAN class="keyword">template</SPAN><SPAN class="special">&lt;</SPAN> <SPAN class="keyword">class</SPAN> <SPAN class="identifier">InIt</SPAN> <SPAN class="special">&gt;</SPAN>
             <SPAN class="identifier">vector</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">InIt</SPAN> <SPAN class="identifier">first</SPAN><SPAN class="special">,</SPAN> <SPAN class="identifier">InIt</SPAN> <SPAN class="identifier">last</SPAN><SPAN class="special">,</SPAN> <SPAN class="keyword">const</SPAN> <SPAN class="identifier">Alloc</SPAN><SPAN class="special">&amp;</SPAN> <SPAN class="identifier">al</SPAN> <SPAN class="special">);</SPAN>
                 <SPAN class="keyword">postcondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="identifier">equal_distance</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">first</SPAN><SPAN class="special">,</SPAN> <SPAN class="identifier">last</SPAN><SPAN class="special">,</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">);</SPAN> 
                                 <SPAN class="identifier">al</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">get_allocator</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>

             <SPAN class="keyword">void</SPAN> <SPAN class="identifier">reserve</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">size_type</SPAN> <SPAN class="identifier">count</SPAN> <SPAN class="special">)</SPAN> 
                 <SPAN class="keyword">precondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="identifier">count</SPAN> <SPAN class="special">&lt;</SPAN> <SPAN class="identifier">max_size</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
                 <SPAN class="keyword">postcondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="identifier">capacity</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">&gt;=</SPAN> <SPAN class="identifier">count</SPAN><SPAN class="special">;</SPAN> <SPAN class="special">}</SPAN>
                 
             <SPAN class="identifier">size_type</SPAN> <SPAN class="identifier">capacity</SPAN><SPAN class="special">()</SPAN> <SPAN class="keyword">const</SPAN><SPAN class="special">;</SPAN>
                 <SPAN class="keyword">postcondition</SPAN><SPAN class="special">(</SPAN> <SPAN class="keyword">result</SPAN> <SPAN class="special">)</SPAN> <SPAN class="special">{</SPAN> <SPAN class="keyword">result</SPAN> <SPAN class="special">&gt;=</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
                 
             <SPAN class="identifier">iterator</SPAN> <SPAN class="identifier">begin</SPAN><SPAN class="special">()</SPAN>
                 <SPAN class="keyword">postcondition</SPAN><SPAN class="special">(</SPAN> <SPAN class="keyword">result</SPAN> <SPAN class="special">)</SPAN> <SPAN class="special">{</SPAN> <SPAN class="keyword">if</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">empty</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">)</SPAN> <SPAN class="keyword">result</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">end</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
             
             <SPAN class="identifier">const_iterator</SPAN> <SPAN class="identifier">begin</SPAN><SPAN class="special">()</SPAN> <SPAN class="keyword">const</SPAN>
                 <SPAN class="keyword">postcondition</SPAN><SPAN class="special">(</SPAN> <SPAN class="keyword">result</SPAN> <SPAN class="special">)</SPAN> <SPAN class="special">{</SPAN> <SPAN class="keyword">if</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">empty</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">)</SPAN> <SPAN class="keyword">result</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">end</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
             
             <SPAN class="identifier">iterator</SPAN> <SPAN class="identifier">end</SPAN><SPAN class="special">();</SPAN>
             <SPAN class="identifier">const_iterator</SPAN> <SPAN class="identifier">end</SPAN><SPAN class="special">()</SPAN> <SPAN class="keyword">const</SPAN><SPAN class="special">;</SPAN>
             
             <SPAN class="identifier">reverse_iterator</SPAN> <SPAN class="identifier">rbegin</SPAN><SPAN class="special">()</SPAN>
                 <SPAN class="keyword">postcondition</SPAN><SPAN class="special">(</SPAN> <SPAN class="keyword">result</SPAN> <SPAN class="special">)</SPAN> <SPAN class="special">{</SPAN> <SPAN class="keyword">if</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">empty</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">)</SPAN> <SPAN class="keyword">result</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">rend</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
             
             <SPAN class="identifier">const_reverse_iterator</SPAN> <SPAN class="identifier">rbegin</SPAN><SPAN class="special">()</SPAN> <SPAN class="keyword">const</SPAN>
                 <SPAN class="keyword">postcondition</SPAN><SPAN class="special">(</SPAN> <SPAN class="keyword">result</SPAN> <SPAN class="special">)</SPAN> <SPAN class="special">{</SPAN> <SPAN class="keyword">if</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">empty</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">)</SPAN> <SPAN class="keyword">result</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">rend</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
             
             <SPAN class="identifier">reverse_iterator</SPAN> <SPAN class="identifier">rend</SPAN><SPAN class="special">();</SPAN>
             <SPAN class="identifier">const_reverse_iterator</SPAN> <SPAN class="identifier">rend</SPAN><SPAN class="special">()</SPAN> <SPAN class="keyword">const</SPAN><SPAN class="special">;</SPAN>
             
             <SPAN class="keyword">void</SPAN> <SPAN class="identifier">resize</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">size_type</SPAN> <SPAN class="identifier">newsize</SPAN> <SPAN class="special">)</SPAN>
                 <SPAN class="keyword">postcondition</SPAN> <SPAN class="comment">// version 1: with an if</SPAN>
                 <SPAN class="special">{</SPAN> 
                     <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">newsize</SPAN><SPAN class="special">;</SPAN> 
                     <SPAN class="keyword">if</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">newsize</SPAN> <SPAN class="special">&gt;</SPAN> <SPAN class="identifier">oldof</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">)</SPAN>
                         <SPAN class="identifier">all_equals</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">begin</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">+</SPAN> <SPAN class="identifier">oldof</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">(),</SPAN> <SPAN class="identifier">end</SPAN><SPAN class="special">(),</SPAN> <SPAN class="identifier">T</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">);</SPAN>
                 <SPAN class="special">}</SPAN>
             
             <SPAN class="keyword">void</SPAN> <SPAN class="identifier">resize</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">size_type</SPAN> <SPAN class="identifier">newsize</SPAN><SPAN class="special">,</SPAN> <SPAN class="identifier">T</SPAN> <SPAN class="identifier">val</SPAN> <SPAN class="special">)</SPAN>
                 <SPAN class="keyword">postcondition</SPAN> <SPAN class="comment">// version 2: with ternary operator</SPAN>
                 <SPAN class="special">{</SPAN>
                     <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">newsize</SPAN><SPAN class="special">;</SPAN> 
                     <SPAN class="identifier">newsize</SPAN> <SPAN class="special">&gt;</SPAN> <SPAN class="identifier">oldof</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">())</SPAN> <SPAN class="special">?</SPAN> 
                         <SPAN class="identifier">all_equals</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">begin</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">+</SPAN> <SPAN class="identifier">oldof</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">(),</SPAN> <SPAN class="identifier">end</SPAN><SPAN class="special">(),</SPAN> <SPAN class="identifier">val</SPAN> <SPAN class="special">)</SPAN> <SPAN class="special">:</SPAN> <SPAN class="keyword">true</SPAN><SPAN class="special">;</SPAN>
                 <SPAN class="special">}</SPAN>
         
             <SPAN class="identifier">size_type</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="keyword">const</SPAN>
                 <SPAN class="keyword">postcondition</SPAN><SPAN class="special">(</SPAN> <SPAN class="keyword">result</SPAN> <SPAN class="special">)</SPAN> <SPAN class="special">{</SPAN> <SPAN class="keyword">result</SPAN> <SPAN class="special">&lt;=</SPAN> <SPAN class="identifier">capacity</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
                 
             <SPAN class="identifier">size_type</SPAN> <SPAN class="identifier">max_size</SPAN><SPAN class="special">()</SPAN> <SPAN class="keyword">const</SPAN>
                 <SPAN class="keyword">postcondition</SPAN><SPAN class="special">(</SPAN> <SPAN class="keyword">result</SPAN> <SPAN class="special">)</SPAN> <SPAN class="special">{</SPAN> <SPAN class="keyword">result</SPAN> <SPAN class="special">&gt;=</SPAN> <SPAN class="identifier">capacity</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
             
             <SPAN class="keyword">bool</SPAN> <SPAN class="identifier">empty</SPAN><SPAN class="special">()</SPAN> <SPAN class="keyword">const</SPAN>
                 <SPAN class="keyword">postcondition</SPAN><SPAN class="special">(</SPAN> <SPAN class="keyword">result</SPAN> <SPAN class="special">)</SPAN> <SPAN class="special">{</SPAN> <SPAN class="keyword">result</SPAN> <SPAN class="special">==</SPAN> <SPAN class="special">(</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">==</SPAN> <SPAN class="number">0</SPAN> <SPAN class="special">);</SPAN> <SPAN class="special">}</SPAN>
             
             <SPAN class="identifier">Alloc</SPAN> <SPAN class="identifier">get_allocator</SPAN><SPAN class="special">()</SPAN> <SPAN class="keyword">const</SPAN><SPAN class="special">;</SPAN>
             
             <SPAN class="identifier">reference</SPAN> <SPAN class="identifier">at</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">size_type</SPAN> <SPAN class="identifier">off</SPAN> <SPAN class="special">);</SPAN>
                 <SPAN class="keyword">precondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="identifier">off</SPAN> <SPAN class="special">&lt;</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
             
             <SPAN class="identifier">const_reference</SPAN> <SPAN class="identifier">at</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">size_type</SPAN> <SPAN class="identifier">off</SPAN> <SPAN class="special">)</SPAN> <SPAN class="keyword">const</SPAN><SPAN class="special">;</SPAN>
                 <SPAN class="keyword">precondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="identifier">off</SPAN> <SPAN class="special">&lt;</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
                 
             <SPAN class="identifier">reference</SPAN> <SPAN class="keyword">operator</SPAN><SPAN class="special">[](</SPAN> <SPAN class="identifier">size_type</SPAN> <SPAN class="identifier">off</SPAN> <SPAN class="special">)</SPAN>
                 <SPAN class="keyword">precondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="identifier">off</SPAN> <SPAN class="special">&lt;</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>

             <SPAN class="identifier">const_reference</SPAN> <SPAN class="keyword">operator</SPAN><SPAN class="special">[](</SPAN> <SPAN class="identifier">size_type</SPAN> <SPAN class="identifier">off</SPAN> <SPAN class="special">)</SPAN>
                 <SPAN class="keyword">precondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="identifier">off</SPAN> <SPAN class="special">&lt;</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
    
             <SPAN class="identifier">reference</SPAN> <SPAN class="identifier">front</SPAN><SPAN class="special">();</SPAN>
                 <SPAN class="keyword">precondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="keyword">not</SPAN> <SPAN class="identifier">empty</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
             
             <SPAN class="identifier">const_reference</SPAN> <SPAN class="identifier">front</SPAN><SPAN class="special">()</SPAN> <SPAN class="keyword">const</SPAN><SPAN class="special">;</SPAN>
                 <SPAN class="keyword">precondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="keyword">not</SPAN> <SPAN class="identifier">empty</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
    
             <SPAN class="identifier">reference</SPAN> <SPAN class="identifier">back</SPAN><SPAN class="special">()</SPAN>
                 <SPAN class="keyword">precondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="keyword">not</SPAN> <SPAN class="identifier">empty</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
             
             <SPAN class="identifier">const_reference</SPAN> <SPAN class="identifier">back</SPAN><SPAN class="special">()</SPAN> <SPAN class="keyword">const</SPAN><SPAN class="special">;</SPAN>
                 <SPAN class="keyword">precondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="keyword">not</SPAN> <SPAN class="identifier">empty</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
                 
             <SPAN class="keyword">void</SPAN> <SPAN class="identifier">push_back</SPAN><SPAN class="special">(</SPAN> <SPAN class="keyword">const</SPAN> <SPAN class="identifier">T</SPAN><SPAN class="special">&amp;</SPAN> <SPAN class="identifier">val</SPAN> <SPAN class="special">)</SPAN>
                 <SPAN class="keyword">precondition</SPAN>  <SPAN class="special">{</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">&lt;</SPAN> <SPAN class="identifier">max_size</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
                 <SPAN class="keyword">postcondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="identifier">back</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">val</SPAN><SPAN class="special">;</SPAN> 
                                 <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">oldof</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">+</SPAN> <SPAN class="number">1</SPAN><SPAN class="special">;</SPAN> 
                                 <SPAN class="identifier">capacity</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">&gt;=</SPAN> <SPAN class="identifier">oldof</SPAN> <SPAN class="identifier">capacity</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
                 
             <SPAN class="keyword">void</SPAN> <SPAN class="identifier">pop_back</SPAN><SPAN class="special">()</SPAN>
                 <SPAN class="keyword">precondition</SPAN>  <SPAN class="special">{</SPAN> <SPAN class="keyword">not</SPAN> <SPAN class="identifier">empty</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
                 <SPAN class="keyword">postcondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">oldof</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">-</SPAN> <SPAN class="number">1</SPAN><SPAN class="special">;</SPAN> <SPAN class="special">}</SPAN>
             
             <SPAN class="keyword">template</SPAN><SPAN class="special">&lt;</SPAN> <SPAN class="keyword">class</SPAN> <SPAN class="identifier">InIt</SPAN> <SPAN class="special">&gt;</SPAN>
             <SPAN class="keyword">void</SPAN> <SPAN class="identifier">assign</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">InIt</SPAN> <SPAN class="identifier">first</SPAN><SPAN class="special">,</SPAN> <SPAN class="identifier">InIt</SPAN> <SPAN class="identifier">last</SPAN> <SPAN class="special">)</SPAN>
                 <SPAN class="keyword">precondition</SPAN> <SPAN class="special">{</SPAN><SPAN class="string">"The range [first,last) is not a sub-range of [begin(),end())"</SPAN><SPAN class="special">;</SPAN><SPAN class="special">}</SPAN>
                 <SPAN class="keyword">postcondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="identifier">equal_distance</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">first</SPAN><SPAN class="special">,</SPAN> <SPAN class="identifier">last</SPAN><SPAN class="special">,</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">);</SPAN> <SPAN class="special">}</SPAN>
             
             <SPAN class="keyword">void</SPAN> <SPAN class="identifier">assign</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">size_type</SPAN> <SPAN class="identifier">count</SPAN><SPAN class="special">,</SPAN> <SPAN class="keyword">const</SPAN> <SPAN class="identifier">T</SPAN><SPAN class="special">&amp;</SPAN> <SPAN class="identifier">val</SPAN> <SPAN class="special">)</SPAN>
                 <SPAN class="keyword">precondition</SPAN>  <SPAN class="special">{</SPAN> <SPAN class="identifier">count</SPAN> <SPAN class="special">&lt;=</SPAN> <SPAN class="identifier">max_size</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
                 <SPAN class="keyword">postcondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="identifier">all_equals</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">begin</SPAN><SPAN class="special">(),</SPAN> <SPAN class="identifier">end</SPAN><SPAN class="special">(),</SPAN> <SPAN class="identifier">val</SPAN> <SPAN class="special">);</SPAN> <SPAN class="special">}</SPAN>
                 
             <SPAN class="identifier">iterator</SPAN> <SPAN class="identifier">insert</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">iterator</SPAN> <SPAN class="identifier">where</SPAN><SPAN class="special">,</SPAN> <SPAN class="keyword">const</SPAN> <SPAN class="identifier">T</SPAN><SPAN class="special">&amp;</SPAN> <SPAN class="identifier">val</SPAN> <SPAN class="special">)</SPAN>
                 <SPAN class="keyword">precondition</SPAN>  <SPAN class="special">{</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">&lt;</SPAN> <SPAN class="identifier">max_size</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
                 <SPAN class="keyword">postcondition</SPAN><SPAN class="special">(</SPAN> <SPAN class="keyword">result</SPAN> <SPAN class="special">)</SPAN> 
                 <SPAN class="special">{</SPAN>
                     <SPAN class="special">*</SPAN><SPAN class="keyword">result</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">val</SPAN><SPAN class="special">;</SPAN>
                     <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN>  <SPAN class="special">==</SPAN> <SPAN class="identifier">oldof</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">+</SPAN> <SPAN class="number">1</SPAN><SPAN class="special">;</SPAN>
                     <SPAN class="identifier">capacity</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">&gt;=</SPAN> <SPAN class="identifier">oldof</SPAN> <SPAN class="identifier">capacity</SPAN><SPAN class="special">();</SPAN>
                     
                     <SPAN class="keyword">if</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">capacity</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">&gt;</SPAN> <SPAN class="identifier">oldof</SPAN> <SPAN class="identifier">capacity</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">)</SPAN>
                         <SPAN class="string">"All iterators have been invalidated"</SPAN><SPAN class="special">;</SPAN>
                     <SPAN class="keyword">else</SPAN>
                         <SPAN class="string">"All iterators in the range [where,end()) have been invalidated"</SPAN><SPAN class="special">;</SPAN>
                 <SPAN class="special">}</SPAN>
             
             <SPAN class="keyword">void</SPAN> <SPAN class="identifier">insert</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">iterator</SPAN> <SPAN class="identifier">where</SPAN><SPAN class="special">,</SPAN> <SPAN class="identifier">size_type</SPAN> <SPAN class="identifier">count</SPAN><SPAN class="special">,</SPAN> <SPAN class="keyword">const</SPAN> <SPAN class="identifier">T</SPAN><SPAN class="special">&amp;</SPAN> <SPAN class="identifier">val</SPAN> <SPAN class="special">)</SPAN>
                 <SPAN class="keyword">precondition</SPAN>  <SPAN class="special">{</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">+</SPAN> <SPAN class="identifier">count</SPAN> <SPAN class="special">&lt;=</SPAN> <SPAN class="identifier">max_size</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
                 <SPAN class="keyword">postcondition</SPAN> 
                 <SPAN class="special">{</SPAN>
                     <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">oldof</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">+</SPAN> <SPAN class="identifier">count</SPAN><SPAN class="special">;</SPAN>
                     <SPAN class="identifier">capacity</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">&gt;=</SPAN> <SPAN class="identifier">oldof</SPAN> <SPAN class="identifier">capacity</SPAN><SPAN class="special">();</SPAN>
                     
                     <SPAN class="keyword">if</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">capacity</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">oldof</SPAN> <SPAN class="identifier">capacity</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">)</SPAN>
                     <SPAN class="special">{</SPAN>
                         <SPAN class="identifier">all_equals</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">oldof</SPAN> <SPAN class="identifier">prior</SPAN><SPAN class="special">(</SPAN><SPAN class="identifier">where</SPAN><SPAN class="special">),</SPAN> <SPAN class="identifier">oldof</SPAN> <SPAN class="identifier">prior</SPAN><SPAN class="special">(</SPAN><SPAN class="identifier">where</SPAN><SPAN class="special">)</SPAN> <SPAN class="special">+</SPAN> <SPAN class="identifier">count</SPAN><SPAN class="special">,</SPAN> <SPAN class="identifier">val</SPAN> <SPAN class="special">);</SPAN>
                         <SPAN class="string">"All iterators in the range [where,end()) have been invalidated"</SPAN><SPAN class="special">;</SPAN>
                     <SPAN class="special">}</SPAN>
                     <SPAN class="keyword">else</SPAN>
                         <SPAN class="string">"All iterators have been invalidated"</SPAN><SPAN class="special">;</SPAN>
                 <SPAN class="special">}</SPAN>
                 
             <SPAN class="keyword">template</SPAN><SPAN class="special">&lt;</SPAN> <SPAN class="keyword">class</SPAN> <SPAN class="identifier">InIt</SPAN> <SPAN class="special">&gt;</SPAN>
             <SPAN class="keyword">void</SPAN> <SPAN class="identifier">insert</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">iterator</SPAN> <SPAN class="identifier">where</SPAN><SPAN class="special">,</SPAN> <SPAN class="identifier">InIt</SPAN> <SPAN class="identifier">first</SPAN><SPAN class="special">,</SPAN> <SPAN class="identifier">InIt</SPAN> <SPAN class="identifier">last</SPAN> <SPAN class="special">)</SPAN>
                 <SPAN class="keyword">precondition</SPAN>  
                 <SPAN class="special">{</SPAN> 
                     <SPAN class="string">"The range [first,last) is not a sub-range of [begin(),end())"</SPAN><SPAN class="special">;</SPAN>
                     <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">+</SPAN> <SPAN class="identifier">count</SPAN> <SPAN class="special">&lt;=</SPAN> <SPAN class="identifier">max_size</SPAN><SPAN class="special">();</SPAN> 
                 <SPAN class="special">}</SPAN>
                 <SPAN class="keyword">postcondition</SPAN>
                 <SPAN class="special">{</SPAN>
                     <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">oldof</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">+</SPAN> <SPAN class="identifier">count</SPAN><SPAN class="special">;</SPAN>
                     <SPAN class="identifier">capacity</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">&gt;=</SPAN> <SPAN class="identifier">oldof</SPAN> <SPAN class="identifier">capacity</SPAN><SPAN class="special">();</SPAN>
        
                     <SPAN class="keyword">if</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">capacity</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">oldof</SPAN> <SPAN class="identifier">capacity</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">)</SPAN>
                     <SPAN class="special">{</SPAN>
                         <SPAN class="identifier">all_equals</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">oldof</SPAN> <SPAN class="identifier">prior</SPAN><SPAN class="special">(</SPAN><SPAN class="identifier">where</SPAN><SPAN class="special">),</SPAN> <SPAN class="identifier">oldof</SPAN> <SPAN class="identifier">prior</SPAN><SPAN class="special">(</SPAN><SPAN class="identifier">where</SPAN><SPAN class="special">)</SPAN> <SPAN class="special">+</SPAN> <SPAN class="identifier">count</SPAN><SPAN class="special">,</SPAN> <SPAN class="identifier">val</SPAN> <SPAN class="special">);</SPAN>
                         <SPAN class="string">"All iterators in the range [where,end()) have been invalidated"</SPAN><SPAN class="special">;</SPAN>
                     <SPAN class="special">}</SPAN>
                     <SPAN class="keyword">else</SPAN>
                         <SPAN class="string">"All iterators have been invalidated"</SPAN><SPAN class="special">;</SPAN>
                 <SPAN class="special">}</SPAN>

             <SPAN class="identifier">iterator</SPAN> <SPAN class="identifier">erase</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">iterator</SPAN> <SPAN class="identifier">where</SPAN> <SPAN class="special">);</SPAN>
                 <SPAN class="keyword">precondition</SPAN>  
                 <SPAN class="special">{</SPAN> 
                     <SPAN class="keyword">not</SPAN> <SPAN class="identifier">empty</SPAN><SPAN class="special">();</SPAN> 
                     <SPAN class="identifier">where</SPAN> <SPAN class="special">!=</SPAN> <SPAN class="identifier">end</SPAN><SPAN class="special">();</SPAN>
                 <SPAN class="special">}</SPAN>
                 <SPAN class="keyword">postcondition</SPAN><SPAN class="special">(</SPAN> <SPAN class="keyword">result</SPAN> <SPAN class="special">)</SPAN> 
                 <SPAN class="special">{</SPAN>
                      <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">oldof</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">-</SPAN> <SPAN class="number">1</SPAN><SPAN class="special">;</SPAN> 
                      <SPAN class="keyword">if</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">empty</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">)</SPAN>
                          <SPAN class="keyword">result</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">end</SPAN><SPAN class="special">();</SPAN>
                      <SPAN class="string">"All iterators in the range [where,end()) have been invalidated"</SPAN><SPAN class="special">;</SPAN>
                 <SPAN class="special">}</SPAN>
                 
             <SPAN class="identifier">iterator</SPAN> <SPAN class="identifier">erase</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">iterator</SPAN> <SPAN class="identifier">first</SPAN><SPAN class="special">,</SPAN> <SPAN class="identifier">iterator</SPAN> <SPAN class="identifier">last</SPAN> <SPAN class="special">)</SPAN>
                 <SPAN class="keyword">precondition</SPAN>  <SPAN class="special">{</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">&gt;=</SPAN> <SPAN class="identifier">std</SPAN><SPAN class="special">::</SPAN><SPAN class="identifier">distance</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">first</SPAN><SPAN class="special">,</SPAN> <SPAN class="identifier">last</SPAN> <SPAN class="special">);</SPAN> <SPAN class="special">}</SPAN>
                 <SPAN class="keyword">postcondition</SPAN><SPAN class="special">(</SPAN> <SPAN class="keyword">result</SPAN> <SPAN class="special">)</SPAN> 
                 <SPAN class="special">{</SPAN>
                      <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">oldof</SPAN> <SPAN class="identifier">size</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">-</SPAN> <SPAN class="identifier">std</SPAN><SPAN class="special">::</SPAN><SPAN class="identifier">distance</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">first</SPAN><SPAN class="special">,</SPAN> <SPAN class="identifier">last</SPAN> <SPAN class="special">);</SPAN> 
                      <SPAN class="keyword">if</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">empty</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">)</SPAN>
                          <SPAN class="keyword">result</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">end</SPAN><SPAN class="special">();</SPAN>
                      <SPAN class="string">"All iterators in the range [first,end()) have been invalidated"</SPAN><SPAN class="special">;</SPAN>
                 <SPAN class="special">}</SPAN>

             <SPAN class="keyword">void</SPAN> <SPAN class="identifier">clear</SPAN><SPAN class="special">();</SPAN>
                 <SPAN class="keyword">postcondition</SPAN> <SPAN class="special">{</SPAN> <SPAN class="identifier">empty</SPAN><SPAN class="special">();</SPAN> <SPAN class="special">}</SPAN>
                 
             <SPAN class="keyword">void</SPAN> <SPAN class="identifier">swap</SPAN><SPAN class="special">(</SPAN> <SPAN class="identifier">vector</SPAN><SPAN class="special">&amp;</SPAN> <SPAN class="identifier">right</SPAN> <SPAN class="special">)</SPAN>
                 <SPAN class="keyword">postcondition</SPAN> 
                 <SPAN class="special">{</SPAN> 
                     <SPAN class="identifier">oldof</SPAN> <SPAN class="special">*</SPAN><SPAN class="keyword">this</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">right</SPAN><SPAN class="special">;</SPAN>
                     <SPAN class="identifier">oldof</SPAN> <SPAN class="identifier">right</SPAN> <SPAN class="special">==</SPAN> <SPAN class="special">*</SPAN><SPAN class="keyword">this</SPAN><SPAN class="special">;</SPAN>
                 <SPAN class="special">}</SPAN>
             
<SPAN class="special">};</SPAN> <SPAN class="comment">// class 'vector'</SPAN>

</PRE>


</DIV>
<DIV class="section">
<H2><A class="toc-backref" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#id72" id="subcontracting-example-hpp" name="subcontracting-example-hpp">10.2&nbsp;&nbsp;&nbsp;subcontracting_example.hpp</A></H2>




<LINK rel="stylesheet" href="./Ottosen2006_Proposal_Rev4-n1962_files/style.css" type="text/css">




<PRE><SPAN class="comment">//
// This example shows how Contract Programming 
// allows one to keep the virtual function public 
// and still enforce the contract of the function
//</SPAN>

<SPAN class="keyword">class</SPAN> <SPAN class="identifier">shape</SPAN>
<SPAN class="special">{</SPAN>
<SPAN class="keyword">public</SPAN><SPAN class="special">:</SPAN>
    <SPAN class="keyword">virtual</SPAN> <SPAN class="special">~</SPAN><SPAN class="identifier">shape</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">{}</SPAN>
    
    <SPAN class="keyword">virtual</SPAN> <SPAN class="keyword">int</SPAN> <SPAN class="identifier">compute_area</SPAN><SPAN class="special">()</SPAN> <SPAN class="keyword">const</SPAN> <SPAN class="special">=</SPAN> <SPAN class="number">0</SPAN>
        <SPAN class="keyword">postcondition</SPAN><SPAN class="special">(</SPAN> <SPAN class="keyword">result</SPAN> <SPAN class="special">)</SPAN> 
        <SPAN class="special">{</SPAN>
            <SPAN class="keyword">result</SPAN> <SPAN class="special">&gt;</SPAN> <SPAN class="number">0</SPAN><SPAN class="special">;</SPAN>
        <SPAN class="special">}</SPAN>
<SPAN class="special">};</SPAN>

<SPAN class="keyword">class</SPAN> <SPAN class="identifier">circle</SPAN> <SPAN class="special">:</SPAN> <SPAN class="keyword">public</SPAN> <SPAN class="identifier">shape</SPAN>
<SPAN class="special">{</SPAN>
<SPAN class="keyword">public</SPAN><SPAN class="special">:</SPAN>
    <SPAN class="keyword">int</SPAN> <SPAN class="identifier">radius</SPAN><SPAN class="special">()</SPAN> <SPAN class="keyword">const</SPAN><SPAN class="special">;</SPAN>
    
    <SPAN class="keyword">virtual</SPAN> <SPAN class="keyword">int</SPAN> <SPAN class="identifier">compute_area</SPAN><SPAN class="special">()</SPAN> <SPAN class="keyword">const</SPAN>
        <SPAN class="keyword">postcondition</SPAN><SPAN class="special">(</SPAN> <SPAN class="keyword">result</SPAN> <SPAN class="special">)</SPAN>
        <SPAN class="special">{</SPAN>
            <SPAN class="keyword">result</SPAN> <SPAN class="special">==</SPAN> <SPAN class="identifier">pi</SPAN> <SPAN class="special">*</SPAN> <SPAN class="identifier">radius</SPAN><SPAN class="special">()</SPAN> <SPAN class="special">*</SPAN> <SPAN class="identifier">radius</SPAN><SPAN class="special">();</SPAN>
        <SPAN class="special">}</SPAN>
<SPAN class="special">};</SPAN>
</PRE>







</DIV>
<DIV class="section">
<H2><A class="toc-backref" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#id73" id="recursion-example" name="recursion-example">10.3&nbsp;&nbsp;&nbsp;recursion example</A></H2>
<P>Consider the relationship between these two comparison operators:</P>
<PRE class="literal-block">bool operator==( T l, T r )
    postcondition( result )
    {
        result == !( l != r );
    }
        
bool operator!=( T l, T r )
    postcondition( result )
    {
        result == !( l == r );
    }
</PRE>
<P>There is no easy way we can express that using an <TT class="docutils literal"><SPAN class="pre">assert()</SPAN></TT>
in the body of the functions.</P>
</DIV>
</DIV>
<DIV class="section">
<H1><A class="toc-backref" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#id74" id="comparison-of-contract-programming-in-d-eiffel-and-c" name="comparison-of-contract-programming-in-d-eiffel-and-c">11&nbsp;&nbsp;&nbsp;Comparison of Contract Programming in D, Eiffel and C++</A></H1>
<P>The table below contains a comparison of how Contract
Programming is implemented in D, Eiffel and C++.</P>
<TABLE border="1" class="docutils">
<COLGROUP>
<COL width="25%">
<COL width="21%">
<COL width="20%">
<COL width="34%">
</COLGROUP>
<TBODY valign="top">
<TR><TD><STRONG>Feature</STRONG></TD>
<TD><STRONG>ISE Eiffel 5.4</STRONG></TD>
<TD><STRONG>D</STRONG></TD>
<TD><STRONG>C++ Proposal</STRONG></TD>
</TR>
<TR><TD><EM>keywords</EM></TD>
<TD><TT class="docutils literal"><SPAN class="pre">require</SPAN></TT>, <TT class="docutils literal"><SPAN class="pre">ensure</SPAN></TT>,
<TT class="docutils literal"><SPAN class="pre">do</SPAN></TT>, <TT class="docutils literal"><SPAN class="pre">require</SPAN> <SPAN class="pre">else</SPAN></TT>,
<TT class="docutils literal"><SPAN class="pre">ensure</SPAN> <SPAN class="pre">then</SPAN></TT>, <TT class="docutils literal"><SPAN class="pre">invariant</SPAN></TT>,
<TT class="docutils literal"><SPAN class="pre">old</SPAN></TT>, <TT class="docutils literal"><SPAN class="pre">result</SPAN></TT>,
<TT class="docutils literal"><SPAN class="pre">variant</SPAN></TT></TD>
<TD><TT class="docutils literal"><SPAN class="pre">in</SPAN></TT>, <TT class="docutils literal"><SPAN class="pre">out</SPAN></TT>, <TT class="docutils literal"><SPAN class="pre">body</SPAN></TT>,
<TT class="docutils literal"><SPAN class="pre">invariant</SPAN></TT>, <TT class="docutils literal"><SPAN class="pre">assert</SPAN></TT>,
<TT class="docutils literal"><SPAN class="pre">static</SPAN></TT></TD>
<TD><TT class="docutils literal"><SPAN class="pre">precondition</SPAN></TT>,
<TT class="docutils literal"><SPAN class="pre">postcondition</SPAN></TT>,
<TT class="docutils literal"><SPAN class="pre">invariant</SPAN></TT>, <TT class="docutils literal"><SPAN class="pre">oldof</SPAN></TT></TD>
</TR>
<TR><TD><EM>on failure</EM></TD>
<TD>throws exception</TD>
<TD>throws exception</TD>
<TD>defaults to <TT class="docutils literal"><SPAN class="pre">terminate()</SPAN></TT>,
defaults can be customized,
might throw</TD>
</TR>
<TR><TD><EM>expression copying in postconditions</EM></TD>
<TD>yes, <TT class="docutils literal"><SPAN class="pre">old</SPAN></TT> keyword</TD>
<TD>no</TD>
<TD>yes, <TT class="docutils literal"><SPAN class="pre">oldof</SPAN></TT> keyword</TD>
</TR>
<TR><TD><EM>subcontracting</EM></TD>
<TD>yes</TD>
<TD>yes</TD>
<TD>yes, but only considers
postconditions</TD>
</TR>
<TR><TD><EM>contracts on abstract functions</EM></TD>
<TD>yes</TD>
<TD>no (planned)</TD>
<TD>yes</TD>
</TR>
<TR><TD><EM>arbitrary code contracts</EM></TD>
<TD>yes</TD>
<TD>yes</TD>
<TD>no, must be const correct</TD>
</TR>
<TR><TD><EM>function code ordering</EM></TD>
<TD>pre -&gt; body -&gt; post</TD>
<TD>pre -&gt; post -&gt; body</TD>
<TD>pre -&gt; post -&gt; body</TD>
</TR>
<TR><TD><EM>compile-time assertions</EM></TD>
<TD>no</TD>
<TD>yes</TD>
<TD>no</TD>
</TR>
<TR><TD><EM>loop invariants</EM></TD>
<TD>yes</TD>
<TD>no</TD>
<TD>no</TD>
</TR>
<TR><TD><EM>loop variants</EM></TD>
<TD>yes</TD>
<TD>no</TD>
<TD>no</TD>
</TR>
<TR><TD><EM>const-correct</EM></TD>
<TD>no</TD>
<TD>no</TD>
<TD>yes</TD>
</TR>
<TR><TD><EM>invariant calls</EM></TD>
<TD><UL class="first last simple">
<LI>end of "constructor"</LI>
<LI>around public functions</LI>
</UL>
</TD>
<TD><UL class="first last simple">
<LI>end of constructor</LI>
<LI>around public functions</LI>
<LI>start of destructor</LI>
</UL>
</TD>
<TD><UL class="first last simple">
<LI>as in D</LI>
<LI>when a function exits due to an exception</LI>
</UL>
</TD>
</TR>
<TR><TD><EM>disabling of checks during assertions</EM></TD>
<TD>yes</TD>
<TD>no</TD>
<TD>yes, but not in preconditions</TD>
</TR>
<TR><TD><EM>when public func. call public func.</EM></TD>
<TD>disable all checks</TD>
<TD>disable nothing</TD>
<TD>disable nothing</TD>
</TR>
<TR><TD><EM>removable from object code</EM></TD>
<TD>yes</TD>
<TD>yes</TD>
<TD>yes</TD>
</TR>
</TBODY>
</TABLE>
</DIV>
<DIV class="section">
<H1><A class="toc-backref" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#id75" id="list-of-contract-programming-resources" name="list-of-contract-programming-resources">12&nbsp;&nbsp;&nbsp;List of Contract Programming resources</A></H1>
<P>This section provides links to a few of the many resources
on Contract Programming.</P>
<P>Earlier proposals:</P>
<UL class="simple">
<LI><A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1866.html">n1866</A> (revision 3)</LI>
</UL>
<!--  -->
<UL class="simple">
<LI><A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1800.pdf">n1800</A> (motivation slides)</LI>
</UL>
<UL class="simple">
<LI><A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1773.html">n1773</A> (revision 2)</LI>
</UL>
<!--  -->
<UL class="simple">
<LI><A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2004/n1669.html">n1669</A> (revision 1)</LI>
</UL>
<!--  -->
<UL class="simple">
<LI><A class="reference" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2004/n1613.pdf">n1613</A> (initial paper)</LI>
</UL>
<P>C++ Contract Programming:</P>
<UL class="simple">
<LI><A class="reference" href="http://www.digitalmars.com/ctg/contract.html">Contracts in the Digital Mars C++ compiler</A></LI>
</UL>
<UL class="simple">
<LI>Beman Dave's <A class="reference" href="http://www.esva.net/~beman/early_program_error_detection.html">Early Program Error Detection</A></LI>
</UL>
<UL class="simple">
<LI>Matthew Wilson's <A class="reference" href="http://www.artima.com/cppsource/deepspace.html">Contract Programming 101</A></LI>
</UL>
<UL class="simple">
<LI>The <A class="reference" href="http://www.aechmea.de/html/german/home_00_index_e.htm">C^2 Contract Programming add-on for C++</A></LI>
</UL>
<P>Contract Programming in other languages:</P>
<UL class="simple">
<LI><A class="reference" href="http://www.digitalmars.com/d/dbc.html">Contracts in D</A></LI>
</UL>
<UL class="simple">
<LI><A class="reference" href="http://research.microsoft.com/specsharp/">The Spec# programming system</A> (C# extension)</LI>
</UL>
<UL class="simple">
<LI>Parasoft's <A class="reference" href="http://www.parasoft.com/jsp/products/home.jsp?product=Jcontract&itemId=30">Jcontract</A> (Java preprocessor)</LI>
</UL>
<UL class="simple">
<LI>RemObject's <A class="reference" href="http://www.chromesville.com/page.asp?id={DFA00D71-D5A4-40A3-9FD0-251899EB30D8}">Contracts in Chrome</A> (Object pascal for .NET)</LI>
</UL>
<UL class="simple">
<LI>SparkAda's <A class="reference" href="http://www.praxis-his.com/sparkada/language.asp">Proof Contexts</A></LI>
</UL>
</DIV>
<DIV class="section">
<H1><A class="toc-backref" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#id76" id="acknowledgements" name="acknowledgements">13&nbsp;&nbsp;&nbsp;Acknowledgements</A></H1>
<P>The following people has been provided feedback and comments throughout the proposals
history: Reece Dunn, Douglas Gregor, Alf Steinbach, Matthew Wilson, 
Berend de Boer, Darren Cook, Pavel Vozenilek, Scott Meyers, Attila Fehr, Walter Bright,
Per Madsen, Kevlin Henney, Sergey Vlasov, Bob Bell, John Nagle, Daveed Vandevoorde,
Jaakko Jarvi, Christopher Diggins, John Torjo, Robert Kawulak, Dave Harris, Michael Wong, 
Thomas Witt, Tim Rowe, Scott Meyers and Andrei Alexandrescu.</P>
<P>Special thanks goes to David Abrahams and James Widman.</P>
<!-- ############################################### -->
<!-- ################## Links ###################### -->
<!-- ############################################### -->
</DIV>
<DIV class="section">
<H1><A class="toc-backref" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#id77" id="footnotes" name="footnotes">14&nbsp;&nbsp;&nbsp;Footnotes</A></H1>
<!-- ############################################### -->
<!-- ################## Footnotes ################## -->
<!-- ############################################### -->
<TABLE class="docutils footnote" frame="void" id="id35" rules="none">
<COLGROUP><COL class="label"><COL></COLGROUP>
<TBODY valign="top">
<TR><TD class="label"><A class="fn-backref" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#id1" name="id35">[0]</A></TD><TD>For example, if the compiler can determine that a precondition is satisfied,
it can call a function where the precondition is not checked. Also, the 
compiler can always assume contracts to be true; hence the compiler can take
advantage of the precondition in the function body.</TD></TR>
</TBODY>
</TABLE>
<TABLE class="docutils footnote" frame="void" id="id36" rules="none">
<COLGROUP><COL class="label"><COL></COLGROUP>
<TBODY valign="top">
<TR><TD class="label"><A class="fn-backref" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#id3" name="id36">[1]</A></TD><TD><P class="first">Even experienced programmers can choke on the word "invariant" and what it
means for a class to have one. There are a few simple rules we want  
all programmers to learn:</P>
<OL class="last arabic simple">
<LI>that classes can have invariants and that subclasses have stronger or equally strong invariants,</LI>
<LI>that functions have pre- and postconditions: the implementer has as his obligation to fulfill the 
postcondition assuming the precondition holds; the user has as his obligation to fulfill the precondition
and receives the benefits of the postcondition in return,</LI>
<LI>that public functions cannot break the class invariant.</LI>
</OL>
</TD></TR>
</TBODY>
</TABLE>
<TABLE class="docutils footnote" frame="void" id="id37" rules="none">
<COLGROUP><COL class="label"><COL></COLGROUP>
<TBODY valign="top">
<TR><TD class="label"><A name="id37">[2]</A></TD><TD>A good compiler will emit warnings whenever a mutation is detected within a contract. This is 
a major advantage compared to the ad hoc solutions programmers use today; there is no special
scope and hence no way the compiler can emit those warnings.</TD></TR>
</TBODY>
</TABLE>
<TABLE class="docutils footnote" frame="void" id="id38" rules="none">
<COLGROUP><COL class="label"><COL></COLGROUP>
<TBODY valign="top">
<TR><TD class="label"><A class="fn-backref" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#id14" name="id38">[3]</A></TD><TD>A weaker precondition can be taken advantage of if we know the particular type
of the object. If weaker preconditions should be allowed, then there exists two
alternatives: to allow reuse of an existing contract or to require a complete
redefinition. The former favours expressiveness, the latter favours
overview.</TD></TR>
</TBODY>
</TABLE>
<TABLE class="docutils footnote" frame="void" id="id39" rules="none">
<COLGROUP><COL class="label"><COL></COLGROUP>
<TBODY valign="top">
<TR><TD class="label"><A class="fn-backref" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#id15" name="id39">[4]</A></TD><TD>In some cases the compiler will be able to determine overlapping expression and hence
optimize some assertions away.</TD></TR>
</TBODY>
</TABLE>
<TABLE class="docutils footnote" frame="void" id="id40" rules="none">
<COLGROUP><COL class="label"><COL></COLGROUP>
<TBODY valign="top">
<TR><TD class="label"><A class="fn-backref" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#id18" name="id40">[5]</A></TD><TD>To ensure that the function gives the basic guarantee of exception-safety.</TD></TR>
</TBODY>
</TABLE>
<TABLE class="docutils footnote" frame="void" id="id41" rules="none">
<COLGROUP><COL class="label"><COL></COLGROUP>
<TBODY valign="top">
<TR><TD class="label"><A class="fn-backref" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#id19" name="id41">[6]</A></TD><TD>One can imagine an approach where exceptions could escape from an invariant by not checking
invariants when functions exit via an exception. The benefits of such an approach are not
obvious and it will complicate flow analysis unnecessarily.</TD></TR>
</TBODY>
</TABLE>
<TABLE class="docutils footnote" frame="void" id="id42" rules="none">
<COLGROUP><COL class="label"><COL></COLGROUP>
<TBODY valign="top">
<TR><TD class="label"><A class="fn-backref" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#id20" name="id42">[7]</A></TD><TD>During construction means until the post-condition of the constructor has ended.</TD></TR>
</TBODY>
</TABLE>
<TABLE class="docutils footnote" frame="void" id="id43" rules="none">
<COLGROUP><COL class="label"><COL></COLGROUP>
<TBODY valign="top">
<TR><TD class="label"><A class="fn-backref" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#id2" name="id43">[8]</A></TD><TD><P class="first">An unfortunate problem is in OO-programming is
that a newly added virtual function in a base class <TT class="docutils literal"><SPAN class="pre">B</SPAN></TT> may suddenly be overridden by an
otherwise non-virtual member function in the derived class <TT class="docutils literal"><SPAN class="pre">D</SPAN></TT>. With a contract-enabled compiler we 
can avoid some of these problems:</P>
<UL class="last simple">
<LI>If the virtual function <TT class="docutils literal"><SPAN class="pre">B::foo(...)</SPAN></TT> specifies a precondition, it is illegal for
<TT class="docutils literal"><SPAN class="pre">D::foo(...)</SPAN></TT> to also specify one. In this case we get a compile error.</LI>
<LI>If the virtual function <TT class="docutils literal"><SPAN class="pre">B::foo(...)</SPAN></TT> specifies pre- and/or postconditions and
<TT class="docutils literal"><SPAN class="pre">D::foo(...)</SPAN></TT> does  not have any contracts, the code compiles. However, if 
<TT class="docutils literal"><SPAN class="pre">D::foo(...)</SPAN></TT> is unsuited for overriding <TT class="docutils literal"><SPAN class="pre">B::foo(...)</SPAN></TT> with, we will quickly
get a runtime error when either the pre- or postconditions fails.</LI>
<LI>If <TT class="docutils literal"><SPAN class="pre">B::foo(...)</SPAN></TT> does not enforce any contract, we do not get any help.</LI>
</UL>
</TD></TR>
</TBODY>
</TABLE>
<TABLE class="docutils footnote" frame="void" id="id44" rules="none">
<COLGROUP><COL class="label"><COL></COLGROUP>
<TBODY valign="top">
<TR><TD class="label"><A class="fn-backref" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#id13" name="id44">[9]</A></TD><TD>Strictly speaking the invariant needs to hold <EM>before</EM> the precondition is executed
because the contracts might call public functions of the class which require the invariant to be established.
Currently we do not expect that to be a practical problem though, and the current specification
is easier to implement.</TD></TR>
</TBODY>
</TABLE>
<!-- However, after an object has been constructed, we know that the invariant holds and so the
check is completely redundant. An implementation might insert the
check anyway merely as an additional debugging help.  -->
<TABLE class="docutils footnote" frame="void" id="id45" rules="none">
<COLGROUP><COL class="label"><COL></COLGROUP>
<TBODY valign="top">
<TR><TD class="label"><A name="id45">[10]</A></TD><TD><EM>(<A class="fn-backref" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#id5">1</A>, <A class="fn-backref" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#id21">2</A>)</EM> In many contexts it is useful to inform the compiler of certain properties. This is true for
efficient garbage collection as well as Contract Programming. The same mechanism may be reused
to tag a piece of code with some property; in this case we would like to tag individual
assertions.</TD></TR>
</TBODY>
</TABLE>
<TABLE class="docutils footnote" frame="void" id="id46" rules="none">
<COLGROUP><COL class="label"><COL></COLGROUP>
<TBODY valign="top">
<TR><TD class="label"><A class="fn-backref" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html#id12" name="id46">[11]</A></TD><TD>Note that if an exception is thrown in the function body, the postcondition is not
evaluated.</TD></TR>
</TBODY>
</TABLE>
</DIV>
</DIV>


</BODY></HTML>