<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Tutorial</title>
<link rel="stylesheet" href="../doc/html/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.73.2">
<link rel="start" href="../index.html" title="Contract++ 0.3.469">
<link rel="up" href="../index.html" title="Contract++ 0.3.469">
<link rel="prev" href="getting_started.html" title="Getting Started">
<link rel="next" href="without_the_macros.html" title="Without the Macros">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="spirit-nav">
<a accesskey="p" href="getting_started.html"><img src=".././doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src=".././doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src=".././doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="without_the_macros.html"><img src=".././doc/html/images/next.png" alt="Next"></a>
</div>
<hr>
<div class="section" lang="en">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="contract__.tutorial"></a><a class="link" href="tutorial.html" title="Tutorial">Tutorial</a>
</h2></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="tutorial.html#contract__.tutorial.contract_programming_overview">Contract
      Programming Overview</a></span></dt>
<dt><span class="section"><a href="tutorial.html#contract__.tutorial.checking_contracts">Checking Contracts</a></span></dt>
<dt><span class="section"><a href="tutorial.html#contract__.tutorial.writing_contracts">Writing Contracts</a></span></dt>
<dt><span class="section"><a href="tutorial.html#contract__.tutorial.signature_sequence">Signature Sequence</a></span></dt>
<dt><span class="section"><a href="tutorial.html#contract__.tutorial.deferring_the_body">Deferring the
      Body</a></span></dt>
<dt><span class="section"><a href="tutorial.html#contract__.tutorial.blocks_and_loops">Blocks and Loops</a></span></dt>
<dt><span class="section"><a href="tutorial.html#contract__.tutorial.commas_within_macro_parameters">Commas
      Within Macro Parameters</a></span></dt>
<dt><span class="section"><a href="tutorial.html#contract__.tutorial.a_fully_working_example">A Fully
      Working Example</a></span></dt>
</dl></div>
<p>
      This section gives an overview of Contract Programming and explains how this
      library can be used to write contracts. At the end of the section there is
      a fully working example that can be compiled and executed.
    </p>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="contract__.tutorial.contract_programming_overview"></a><a class="link" href="tutorial.html#contract__.tutorial.contract_programming_overview" title="Contract Programming Overview">Contract
      Programming Overview</a>
</h3></div></div></div>
<p>
        Contract Programming is characterized at least by the following assertion
        mechanisms (see <a class="link" href="bibliography.html" title="Bibliography">[Meyer1997]</a>,
        <a class="link" href="bibliography.html" title="Bibliography">[Ottosen2004]</a>, or <a class="link" href="bibliography.html" title="Bibliography">[Crowl2006]</a>):
      </p>
<div class="orderedlist"><ol type="1">
<li>
          It is possible to describe <span class="bold"><strong>class invariants</strong></span>.
          These are logical conditions that programmers expect to be true after the
          constructor has been executed successfully, before and after the execution
          of every non-static member function with a contract, and before the destructor
          is executed (e.g., class invariants can define a valid state for all objects
          of a class). It is possible to describe <span class="bold"><strong>static class
          invariants</strong></span> also which are expected to be true before and after
          the execution of any member function with a contract (including static
          member functions, constructor entry, and destructor exit).
        </li>
<li>
          It is possible to describe function <span class="bold"><strong>preconditions</strong></span>.
          These are logical conditions that programmers except to be true when the
          function is called (e.g., to check constraints on input function arguments).
        </li>
<li>
          It is possible to describe function <span class="bold"><strong>postconditions</strong></span>.
          These are logical conditions that programmers expect to be true when the
          function has ended normally (e.g., to check the result and any side effect
          that a function might have).
        </li>
<li>
          It is possible to formalize the notion of overriding a virtual member function
          via <span class="bold"><strong>subcontracting</strong></span>. Subcontracting can
          be justified by substitution principles and it consists of the following
          rules that the overriding function must obey:
          <div class="orderedlist"><ol type="a">
<li>
              Preconditions cannot be strengthen.
            </li>
<li>
              Postconditions cannot be weaken.
            </li>
<li>
              Class invariants cannot be weaken.
            </li>
</ol></div>
</li>
<li>
          It is possible to describe <span class="bold"><strong>block invariants</strong></span>.
          These are logical conditions that programmes except to be true every time
          the execution reaches the point where the condition is asserted. When used
          within a loop (i.e., a block of code that can be executed in iteration),
          block invariants function like <span class="emphasis"><em>loop invariants</em></span> asserting
          conditions that are excepted to be true for every loop iteration.
        </li>
<li>
          It is possible to describe a <span class="bold"><strong>loop variant</strong></span>.
          This a positive integer expression with a value that is expected to decrease
          at every subsequent loop iteration.
        </li>
</ol></div>
<p>
        Based on these definitions of invariants, preconditions, postconditions,
        and subcontracting it is possible to specify the semantics of the invocation
        of a function for which a contract has been specified.
      </p>
<a name="contract__.tutorial.contract_programming_overview.non_member_function_call_semantics"></a><h6>
<a name="id2605085"></a>
        <a class="link" href="tutorial.html#contract__.tutorial.contract_programming_overview.non_member_function_call_semantics">Non-Member
        Function Call Semantics</a>
      </h6>
<p>
        A non-member function call should execute the following steps:
      </p>
<div class="orderedlist"><ol type="1">
<li>
          Check preconditions.
        </li>
<li>
          Execute function body.
        </li>
<li>
          Check postconditions.
        </li>
</ol></div>
<a name="contract__.tutorial.contract_programming_overview.member_function_call_semantics"></a><h6>
<a name="id2605132"></a>
        <a class="link" href="tutorial.html#contract__.tutorial.contract_programming_overview.member_function_call_semantics">Member
        Function Call Semantics</a>
      </h6>
<p>
        A member function call should execute the following steps:
      </p>
<div class="orderedlist"><ol type="1">
<li>
          Check static class invariants.
        </li>
<li>
          Check non-static class invariants <span class="emphasis"><em>AND</em></span>, when subcontracting,
          check the base class invariants (for non-static member functions only
          <sup>[<a name="id2605169" href="#ftn.id2605169" class="footnote">2</a>]</sup>
          ).
        </li>
<li>
          Check preconditions <span class="emphasis"><em>OR</em></span>, when subcontracting, check
          the overridden function preconditions.
        </li>
<li>
          Execute function body.
        </li>
<li>
          Check static class invariants (even if body throws an exception).
        </li>
<li>
          Check non-static class invariants <span class="emphasis"><em>AND</em></span>, when subcontracting,
          check base class invariants (for non-static member functions only plus
          checked even if body throws an exception).
        </li>
<li>
          Check postconditions <span class="emphasis"><em>AND</em></span>, when subcontracting, check
          overridden function postconditions (only if body did not throw an exception).
        </li>
</ol></div>
<p>
        Where <span class="emphasis"><em>AND</em></span> and <span class="emphasis"><em>OR</em></span> are the logical
        "and" and "or" operators evaluated in short-circuit (i.e.,
        A <span class="emphasis"><em>AND</em></span> B evaluates B only if A is evaluated to be true,
        A <span class="emphasis"><em>OR</em></span> B evaluates B only if A is evaluated to be false).
      </p>
<p>
        When a member function overrides more than one virtual function due to multiple
        inheritance:
      </p>
<div class="itemizedlist"><ul type="disc">
<li>
          Class invariants are checked in <span class="emphasis"><em>AND</em></span> with the invariants
          of <span class="emphasis"><em>all</em></span> the base classes (following the inheritance
          order).
        </li>
<li>
          Preconditions are checked in <span class="emphasis"><em>OR</em></span> with the preconditions
          of <span class="emphasis"><em>all</em></span> the overridden functions (following the inheritance
          order).
        </li>
<li>
          Postconditions are checked in <span class="emphasis"><em>AND</em></span> with the postconditions
          of <span class="emphasis"><em>all</em></span> the overridden functions (following the inheritance
          order).
        </li>
</ul></div>
<a name="contract__.tutorial.contract_programming_overview.constructor_call_semantics"></a><h6>
<a name="id2605291"></a>
        <a class="link" href="tutorial.html#contract__.tutorial.contract_programming_overview.constructor_call_semantics">Constructor
        Call Semantics</a>
      </h6>
<p>
        A constructor call should execute the following steps:
      </p>
<div class="orderedlist"><ol type="1">
<li>
          Initialize member variables via the constructor member initialization list
          (if such a list is specified).
        </li>
<li>
          Check static class invariants (but not the non-static class invariants).
        </li>
<li>
          Check preconditions.
        </li>
<li>
          Execute constructor body.
        </li>
<li>
          Check static class invariants (even if body throws an exception).
        </li>
<li>
          Check class invariants (even if body throws an exception).
        </li>
<li>
          Check postconditions (only if body did not throw an exception).
        </li>
</ol></div>
<p>
        Before constructor body execution, there is no object therefore:
      </p>
<div class="itemizedlist"><ul type="disc">
<li>
          Non-static class invariants do not have to hold true and they are not checked
          at constructor entry.
        </li>
<li>
          Preconditions cannot access the object.
        </li>
<li>
          Postconditions cannot access the old object value (as it was before body
          execution).
        </li>
</ul></div>
<a name="contract__.tutorial.contract_programming_overview.destructor_call_semantics"></a><h6>
<a name="id2605380"></a>
        <a class="link" href="tutorial.html#contract__.tutorial.contract_programming_overview.destructor_call_semantics">Destructor
        Call Semantics</a>
      </h6>
<p>
        A destructor call should execute the following steps:
      </p>
<div class="orderedlist"><ol type="1">
<li>
          Check static class invariants.
        </li>
<li>
          Check class invariants.
        </li>
<li>
          Execute destructor body.
        </li>
<li>
          Check static class invariants (but not the non-static class invariants
          plus checked even if body throws an exception
          <sup>[<a name="id2605422" href="#ftn.id2605422" class="footnote">3</a>]</sup>
          ).
        </li>
</ol></div>
<p>
        Note that:
      </p>
<div class="itemizedlist"><ul type="disc">
<li>
          Destructors have no arguments so they have no preconditions.
        </li>
<li>
          After destructor body execution, there is no object anymore (because it
          has been destroyed) so non-static class invariants do not have to hold
          true and they are not checked at destructor exit.
        </li>
<li>
          Destructors have no postconditions as there is no function argument and
          after body execution there is no object.
        </li>
</ul></div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="contract__.tutorial.checking_contracts"></a><a class="link" href="tutorial.html#contract__.tutorial.checking_contracts" title="Checking Contracts">Checking Contracts</a>
</h3></div></div></div>
<p>
        After programmers specify contracts, this library provides a mechanism to
        automatically check if class invariants, preconditions, postconditions, block
        invariants, and loop variants hold true at run-time or not.
      </p>
<p>
        If a class invariant, precondition, postcondition, block invariant, or loop
        variant asserted via <code class="computeroutput"><a href="../CONTRACT_ASSERT.html" target="_top">CONTRACT_ASSERT</a><span class="special">()</span></code>, <code class="computeroutput"><a href="../CONTRACT_ASSERT_BLOCK_INVARIANT.html" target="_top">CONTRACT_ASSERT_BLOCK_INVARIANT</a><span class="special">()</span></code>, or <code class="computeroutput"><a href="../CONTRACT_ASSERT_LOOP_VARIANT.html" target="_top">CONTRACT_ASSERT_LOOP_VARIANT</a><span class="special">()</span></code> is checked to be false, the library invokes
        the <code class="computeroutput"><span class="identifier">contract</span><span class="special">::</span><a href="../contract/class_invariant_failed.html" target="_top">class_invariant_failed</a><span class="special">()</span></code>, <code class="computeroutput"><span class="identifier">contract</span><span class="special">::</span><a href="../contract/precondition_failed.html" target="_top">precondition_failed</a><span class="special">()</span></code>, <code class="computeroutput"><span class="identifier">contract</span><span class="special">::</span><a href="../contract/postcondition_failed.html" target="_top">postcondition_failed</a><span class="special">()</span></code>, <code class="computeroutput"><span class="identifier">contract</span><span class="special">::</span><a href="../contract/block_invariant_failed.html" target="_top">block_invariant_failed</a><span class="special">()</span></code> (for both block invariant and loop variant
        failures) function respectively. These functions invoke <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">terminate</span><span class="special">()</span></code> by default but programmers can redefine
        them to take a different action using <code class="computeroutput"><span class="identifier">contract</span><span class="special">::</span><a href="../contract/set_class_invariant_failed.html" target="_top">set_class_invariant_failed</a><span class="special">()</span></code>, <code class="computeroutput"><span class="identifier">contract</span><span class="special">::</span><a href="../contract/set_precondition_failed.html" target="_top">set_precondition_failed</a><span class="special">()</span></code>, <code class="computeroutput"><span class="identifier">contract</span><span class="special">::</span><a href="../contract/set_postcondition_failed.html" target="_top">set_postcondition_failed</a><span class="special">()</span></code>, and <code class="computeroutput"><span class="identifier">contract</span><span class="special">::</span><a href="../contract/set_block_invariant_failed.html" target="_top">set_block_invariant_failed</a><span class="special">()</span></code>.
      </p>
<p>
        This mechanism is similarly to the one of C++ <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">set_terminate</span><span class="special">()</span></code> (see <a class="link" href="throw_on_failure.html" title="Annex: Throw on Failure">Throw
        on Failure</a> for an example).
      </p>
<a name="contract__.tutorial.checking_contracts.exceptions"></a><h6>
<a name="id2605771"></a>
        <a class="link" href="tutorial.html#contract__.tutorial.checking_contracts.exceptions">Exceptions</a>
      </h6>
<p>
        When an exception if thrown while checking invariants, preconditions, or
        postconditions then the contract condition is considered failed (because
        it was not possible to check it as being true) and the relative contract
        failure handler function is invoked.
      </p>
<p>
        When an exception if thrown while executing the body then the class invariants
        are checked (for member functions only) and, if they hold true, the exception
        is passed up to the caller as usual (otherwise the class invariant failed
        handler function is invoked). Therefore, exception specifications will work
        as usual as long as the member function body does not fail the class invariant
        when it throws the exception.
      </p>
<a name="contract__.tutorial.checking_contracts.constant_correctness"></a><h6>
<a name="id2605808"></a>
        <a class="link" href="tutorial.html#contract__.tutorial.checking_contracts.constant_correctness">Constant-Correctness</a>
      </h6>
<p>
        Contracts are only supposed to <span class="emphasis"><em>check</em></span> the object state
        in order to ensure its compliance with the software specifications. Therefore,
        contract checking should not be allowed to modify the object state and exclusively
        "read-only" operations (or <span class="emphasis"><em>queries</em></span>) should
        be used to specify contracts.
      </p>
<p>
        This library enforces
        <sup>[<a name="id2605838" href="#ftn.id2605838" class="footnote">4</a>]</sup>
        this constraint at compile-time using the C++ <code class="computeroutput"><span class="keyword">const</span></code>
        qualifier. Contracts only have access to the object, function arguments,
        and return value via constant references thus only constant members can be
        accessed when checking contracts. Furthermore, pointers are passed as <code class="computeroutput"><span class="keyword">const</span> <span class="identifier">T</span><span class="special">*</span></code> so the pointed object is constants and cannot
        be changed (note that the pointer value itself is not constant, because it
        is not passed as <code class="computeroutput"><span class="keyword">const</span> <span class="identifier">T</span><span class="special">*</span> <span class="keyword">const</span></code>, and
        it could be changed by the contract but such a change will be local to the
        contract function therefore still ensuring the const-correctness of the contract).
      </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="contract__.tutorial.writing_contracts"></a><a class="link" href="tutorial.html#contract__.tutorial.writing_contracts" title="Writing Contracts">Writing Contracts</a>
</h3></div></div></div>
<p>
        The following overview of the contract macros and their usages should be
        enough to understand the working example at the end of this section, most
        of the examples in the <a class="link" href="examples.html" title="Examples">Examples</a>
        annex, and to start writing contracts on your own. Consult the library <a href="../reference.html" target="_top">Reference</a> documentation for more information.
      </p>
<a name="contract__.tutorial.writing_contracts.contract_macros"></a><h6>
<a name="id2605968"></a>
        <a class="link" href="tutorial.html#contract__.tutorial.writing_contracts.contract_macros">Contract
        Macros</a>
      </h6>
<p>
        This is a summary of the macros provided by this library to program contracts
        <sup>[<a name="id2605984" href="#ftn.id2605984" class="footnote">5</a>]</sup>
        .
      </p>
<p>
        <span class="bold"><strong><code class="literal"><a href="../CONTRACT_INVARIANT.html" target="_top">CONTRACT_INVARIANT</a>(
        (static)({ ... }) ({ ... }) )</code></strong></span>
      </p>
<p>
        This macro is used to program class invariants. It should appear within a
        private section at the very beginning of the class declaration. It takes
        one parameter which is a <a href="http://www.boost.org/libs/preprocessor/doc/index.html" target="_top">Boost.Preprocessor</a>
        sequence of the following elements:
      </p>
<div class="itemizedlist"><ul type="disc">
<li>
<code class="computeroutput"><span class="special">(</span><span class="keyword">static</span><span class="special">)</span> <span class="special">({</span> <span class="special">...</span>
          <span class="special">})</span></code>: The code block <code class="computeroutput"><span class="special">{</span> <span class="special">...</span> <span class="special">}</span></code><sup>[<a name="id2606276" href="#ftn.id2606276" class="footnote">6</a>]</sup>
          asserting static class invariants. This is optional and it can be omitted.
        </li>
<li>
<code class="computeroutput"><span class="special">({</span> <span class="special">...</span>
          <span class="special">})</span></code>: A secondary code block <code class="computeroutput"><span class="special">{</span> <span class="special">...</span> <span class="special">}</span></code>
          asserting non-static class invariants. This is mandatory but an empty code
          block <code class="computeroutput"><span class="special">({})</span></code> can be specified
          if there are no class invariants (using <code class="computeroutput"><a href="../CONTRACT_INVARIANT.html" target="_top">CONTRACT_INVARIANT</a><span class="special">()</span></code> instead of <code class="computeroutput"><a href="../CONTRACT_INVARIANT.html" target="_top">CONTRACT_INVARIANT</a><span class="special">(</span> <span class="special">({})</span> <span class="special">)</span></code> will generate a preprocessor error).
        </li>
</ul></div>
<p>
        If contract compilation is turned off, this macro expands to nothing (and
        no contract overhead is added). Otherwise, it expands to code that checks
        the class invariants (see <a class="link" href="without_the_macros.html" title="Without the Macros">Without
        the Macros</a> for details).
      </p>
<p>
        <span class="bold"><strong><code class="literal"><a href="../CONTRACT_FUNCTION.html" target="_top">CONTRACT_FUNCTION</a>(
        <span class="emphasis"><em>signature-sequence</em></span> (precondition)({ ... }) (postcondition)(<span class="emphasis"><em>result-name</em></span>)({
        ... }) (body)({ ... }) )</code></strong></span>
      </p>
<p>
        <span class="bold"><strong><code class="literal"><a href="../CONTRACT_CONSTRUCTOR.html" target="_top">CONTRACT_CONSTRUCTOR</a>(
        <span class="emphasis"><em>signature-sequence</em></span> (precondition)({ ... }) (postcondition)({
        ... }) (body)({ ... }) )</code></strong></span>
      </p>
<p>
        These macros are used to program preconditions and postconditions for functions
        (members and non) and constructors respectively. They should appear right
        after the function and constructor declaration, and after the constructor
        members initialization list when such a list is specified. They both take
        the following parameters:
      </p>
<div class="itemizedlist"><ul type="disc">
<li>
<span class="emphasis"><em>signature-sequence</em></span>: A <a href="http://www.boost.org/libs/preprocessor/doc/index.html" target="_top">Boost.Preprocessor</a>
          sequence with the function or constructor signature tokens (see subsections
          below).
        </li>
<li>
<code class="computeroutput"><span class="special">(</span><span class="identifier">precondition</span><span class="special">)</span> <span class="special">({</span> <span class="special">...</span>
          <span class="special">})</span></code>: An optional code block <code class="computeroutput"><span class="special">{</span> <span class="special">...</span> <span class="special">}</span></code>
          asserting the preconditions.
        </li>
<li>
<code class="computeroutput"><span class="special">(</span><span class="identifier">postcondition</span><span class="special">)</span> <span class="special">(</span></code><span class="emphasis"><em>result-name</em></span><code class="computeroutput"><span class="special">)</span> <span class="special">({</span> <span class="special">...</span>
          <span class="special">})</span></code>: An optional code block <code class="computeroutput"><span class="special">{</span> <span class="special">...</span> <span class="special">}</span></code>
          asserting the postconditions. The <code class="computeroutput"><span class="special">(</span></code><span class="emphasis"><em>result-name</em></span><code class="computeroutput"><span class="special">)</span></code> element is only specified for non-void
          functions (so never for constructors) and it names the variable used to
          access the return value within postconditions (e.g., <code class="computeroutput"><span class="identifier">result</span></code>).
        </li>
<li>
<code class="computeroutput"><span class="special">(</span><span class="identifier">body</span><span class="special">)({</span> <span class="special">...</span> <span class="special">})</span></code>: A mandatory code block <code class="computeroutput"><span class="special">{</span> <span class="special">...</span> <span class="special">}</span></code>
          implementing the function or constructor body.
        </li>
</ul></div>
<p>
        If contract compilation is turned off, these macros simply expand to the
        body code block (and no contract overhead is added). Otherwise, they expand
        to code that implements the <a class="link" href="tutorial.html#contract__.tutorial.contract_programming_overview.member_function_call_semantics">Member
        Function Call Semantics</a> and <a class="link" href="tutorial.html#contract__.tutorial.contract_programming_overview.constructor_call_semantics">Constructor
        Call Semantics</a> respectively thus checking class invariants, preconditions,
        and postconditions (see <a class="link" href="without_the_macros.html" title="Without the Macros">Without
        the Macros</a> for details).
      </p>
<p>
        <span class="bold"><strong><code class="literal"><a href="../CONTRACT_DESTRUCTOR.html" target="_top">CONTRACT_DESTRUCTOR</a>(
        <span class="emphasis"><em>signature-sequence</em></span> (body)({ ... }) )</code></strong></span>
      </p>
<p>
        This macro is used to program destructor contracts. It should appear right
        after the destructor declaration. It takes the following parameters:
      </p>
<div class="itemizedlist"><ul type="disc">
<li>
<span class="emphasis"><em>signature-sequence</em></span>: The destructor signature tokens
          (see below).
        </li>
<li>
<code class="computeroutput"><span class="special">(</span><span class="identifier">body</span><span class="special">)</span> <span class="special">({</span> <span class="special">...</span>
          <span class="special">})</span></code>: A mandatory code block <code class="computeroutput"><span class="special">{</span> <span class="special">...</span> <span class="special">}</span></code>
          implementing the destructor body.
        </li>
</ul></div>
<p>
        If contract compilation is turned off, this macro simply expands to the body
        code block (and no contract overhead is added). Otherwise, it expands to
        code that implements the <a class="link" href="tutorial.html#contract__.tutorial.contract_programming_overview.destructor_call_semantics">Destructor
        Call Semantics</a> checking the class invariants (see <a class="link" href="without_the_macros.html" title="Without the Macros">Without
        the Macros</a> for details).
      </p>
<p>
        <span class="bold"><strong><code class="literal"><a href="../CONTRACT_OLDOF.html" target="_top">CONTRACT_OLDOF</a>(
        variable_name )</code></strong></span>
      </p>
<p>
        This macro is used to access the old value for the variable with the specified
        name in postconditions. It takes the following parameter:
      </p>
<div class="itemizedlist"><ul type="disc"><li>
<code class="computeroutput"><span class="identifier">name</span></code>: The name of the variable.
          As usual, <code class="computeroutput"><span class="keyword">this</span></code> can be used
          as the variable name for the object so <code class="computeroutput"><span class="identifier">CONTRACT_OLDOF</span><span class="special">(</span><span class="keyword">this</span><span class="special">)</span></code>
          is used to access the object old value. Otherwise, any of the function
          argument variable names can be specified. The variable type (class or argument
          type) must be tagged copyable in the signature sequence for the variable
          old value to be available (see below). The library generates a compile-time
          error (containing the text <code class="computeroutput"><span class="identifier">contract</span><span class="special">::</span><span class="identifier">noold</span></code>)
          if this macro is used on a variable name of a type which was not tagged
          copyable.
        </li></ul></div>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src=".././doc/html/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
          This library does not support old values for <span class="emphasis"><em>any</em></span> expression
          that can be evaluated in postcondition as supported by Eiffel and required
          <a class="link" href="bibliography.html" title="Bibliography">[Crowl2006]</a> instead. The
          library supports old values for the object and all the function argument
          types, and this is a subset of the old values supported by Eiffel and required
          by <a class="link" href="bibliography.html" title="Bibliography">[Crowl2006]</a>. However,
          the old values supported by the library are usually enough to program the
          postconditions (e.g., all Eiffel examples from <a class="link" href="bibliography.html" title="Bibliography">[Meyer1997]</a>,
          <a class="link" href="bibliography.html" title="Bibliography">[Mitchell2002]</a>, and all
          C++ examples from <a class="link" href="bibliography.html" title="Bibliography">[Crowl2006]</a>
          were successfully programmed using just these old values, see the <a class="link" href="examples.html" title="Examples">Examples</a> section).
        </p></td></tr>
</table></div>
<p>
        The old value variable are only declared locally within postconditions therefore
        they cannot be mistakenly accessed outside the related postcondition code
        block (see <a class="link" href="without_the_macros.html" title="Without the Macros">Without the Macros</a>
        for details).
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src=".././doc/html/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top">
<p>
          If pointer types are tagged copyable, then the pointer value, and <span class="emphasis"><em>not</em></span>
          the pointed value, is copied. Therefore the old pointer value will be available
          in postconditions via <code class="computeroutput"><a href="../CONTRACT_OLDOF.html" target="_top">CONTRACT_OLDOF</a><span class="special">()</span></code> and <span class="emphasis"><em>not</em></span> the old
          pointed value. In other words, as usual, shallow copies are performed for
          pointers (unless the pointed type defines a different copy operation).
          Be careful as this might not be what you intended when using <code class="computeroutput"><a href="../CONTRACT_OLDOF.html" target="_top">CONTRACT_OLDOF</a><span class="special">()</span></code>
          on a pointer
          <sup>[<a name="id2607079" href="#ftn.id2607079" class="footnote">7</a>]</sup>
          .
        </p>
<p>
          The notable exception is the object <code class="computeroutput"><span class="keyword">this</span></code>
          which is passed to the contract functions by pointer but its old value
          is automatically deep copied by the library.
        </p>
</td></tr>
</table></div>
<p>
        <span class="bold"><strong><code class="literal"><a href="../CONTRACT_ASSERT.html" target="_top">CONTRACT_ASSERT</a>(
        boolean_condition )</code></strong></span>
      </p>
<p>
        This macro is used to assert conditions within the class invariant, precondition,
        and postcondition code blocks (see also <a href="../CONTRACT_ASSERT_MSG.html" target="_top">CONTRACT_ASSERT_MSG</a>()).
        It takes the following parameter:
      </p>
<div class="itemizedlist"><ul type="disc"><li>
<code class="computeroutput"><span class="identifier">boolean_condition</span></code>: The
          boolean condition being asserted.
        </li></ul></div>
<p>
        If contract compilation is turned off, this macro expands to nothing (and
        no contract overhead is added). Otherwise, this macro expands to code that
        triggers the invocation of <code class="computeroutput"><span class="identifier">contract</span><span class="special">::</span><a href="../contract/class_invariant_failed.html" target="_top">class_invariant_failed</a><span class="special">()</span></code>, <code class="computeroutput"><span class="identifier">contract</span><span class="special">::</span><a href="../contract/precondition_failed.html" target="_top">precondition_failed</a><span class="special">()</span></code>, or <code class="computeroutput"><span class="identifier">contract</span><span class="special">::</span><a href="../contract/postcondition_failed.html" target="_top">postcondition_failed</a><span class="special">()</span></code> in case the asserted boolean condition
        is evaluated to be false at run-time from within invariants, preconditions,
        or postconditions respectively (see <a class="link" href="without_the_macros.html" title="Without the Macros">Without
        the Macros</a> for details).
      </p>
<p>
        <span class="bold"><strong><code class="literal"><a href="../CONTRACT_ASSERT_BLOCK_INVARIANT.html" target="_top">CONTRACT_ASSERT_BLOCK_INVARIANT</a>(
        boolean_condition )</code></strong></span>
      </p>
<p>
        This macro is used to assert invariant within a generic code block (see also
        <a href="../CONTRACT_ASSERT_BLOCK_INVARIANT_MSG.html" target="_top">CONTRACT_ASSERT_BLOCK_INVARIANT_MSG</a>()).
        This macro can also be used within loops to assert loop invariants. It takes
        the following parameter:
      </p>
<div class="itemizedlist"><ul type="disc"><li>
<code class="computeroutput"><span class="identifier">boolean_condition</span></code>: The
          boolean condition being asserted.
        </li></ul></div>
<p>
        If contract compilation is turned off, this macro expands to nothing (and
        no contract overhead is added). Otherwise, this macro expands to code that
        triggers the invocation of <code class="computeroutput"><span class="identifier">contract</span><span class="special">::</span><a href="../contract/block_invariant_failed.html" target="_top">block_invariant_failed</a><span class="special">()</span></code> in case the asserted boolean condition
        is evaluated to be false at run-time (see <a class="link" href="without_the_macros.html" title="Without the Macros">Without
        the Macros</a> for details).
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src=".././doc/html/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
          This macro is similar to the C <code class="computeroutput"><span class="identifier">assert</span><span class="special">()</span></code> macro as it can be used at any point
          within a block of code. However, in case the asserted condition either
          throws an exception or it is evaluated to be <code class="computeroutput"><span class="keyword">false</span></code>,
          this macro invokes <code class="computeroutput"><span class="identifier">contract</span><span class="special">::</span><a href="../contract/block_invariant_failed.html" target="_top">block_invariant_failed</a><span class="special">()</span></code> instead of calling <code class="computeroutput"><span class="identifier">abort</span><span class="special">()</span></code>.
        </p></td></tr>
</table></div>
<p>
        <span class="bold"><strong><code class="literal"><a href="../CONTRACT_ASSERT_LOOP_VARIANT.html" target="_top">CONTRACT_ASSERT_LOOP_VARIANT</a>(
        integer_expression )</code></strong></span>
      </p>
<p>
        <span class="bold"><strong><code class="literal"><a href="../CONTRACT_INIT_LOOP_VARIANT.html" target="_top">CONTRACT_INIT_LOOP_VARIANT</a></code></strong></span>
      </p>
<p>
        This macro is used to assert loop variants (see also <a href="../CONTRACT_ASSERT_LOOP_VARIANT_MSG.html" target="_top">CONTRACT_ASSERT_LOOP_VARIANT_MSG</a>()).
        It must be used <span class="emphasis"><em>after</em></span> <code class="computeroutput"><a href="../CONTRACT_INIT_LOOP_VARIANT.html" target="_top">CONTRACT_INIT_LOOP_VARIANT</a></code>
        has been called once within the same code block scope (see below).
      </p>
<div class="itemizedlist"><ul type="disc"><li>
<code class="computeroutput"><span class="identifier">integer_expression</span></code>: An
          integer expression which is evaluated at each loop iteration as the loop
          variant. It must be always positive (not negative and not zero) and it
          must strictly decrease at each subsequent loop iteration (of <code class="computeroutput"><span class="number">1</span></code> or more).
        </li></ul></div>
<p>
        If contract compilation is turned off, this macro expands to nothing (and
        no contract overhead is added). Otherwise, this macro expands to code that
        triggers the invocation of <code class="computeroutput"><span class="identifier">contract</span><span class="special">::</span><a href="../contract/block_invariant_failed.html" target="_top">block_invariant_failed</a><span class="special">()</span></code> at run-time in case the specified variant
        expression is either not positive or it does not decrease from one loop iteration
        to the next (see <a class="link" href="without_the_macros.html" title="Without the Macros">Without the
        Macros</a> for details).
      </p>
<a name="contract__.tutorial.writing_contracts.step_by_step_example"></a><h6>
<a name="id2607549"></a>
        <a class="link" href="tutorial.html#contract__.tutorial.writing_contracts.step_by_step_example">Step-by-Step
        Example</a>
      </h6>
<p>
        Let's assume we want to write a <code class="computeroutput"><span class="identifier">myvector</span></code>
        class template that wraps the C++ STL vector template <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span></code>
        adding contracts to it. Here we show, step-by-step, how to program a contract
        for the <code class="computeroutput"><span class="identifier">push_back</span><span class="special">()</span></code>
        function.
      </p>
<p>
        <span class="bold"><strong>Step 1)</strong></span> First, we implement <code class="computeroutput"><span class="identifier">myvector</span><span class="special">::</span><span class="identifier">push_back</span><span class="special">()</span></code>
        to call <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">::</span><span class="identifier">push_back</span><span class="special">()</span></code>
        and we can sketch the contract using comments.
      </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">myvector</span> <span class="special">{</span>
    <span class="comment">// Invariant: (size() == 0) == empty()
</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="comment">// Precondition: size() &lt; max_size()
</span>    <span class="comment">// Postcondition: size() == (oldof size() + 1)
</span>    <span class="keyword">void</span> <span class="identifier">push_back</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">element</span><span class="special">)</span> <span class="special">{</span> <span class="identifier">vector_</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">element</span><span class="special">);</span> <span class="special">}</span>

    <span class="special">...</span> <span class="comment">// Rest of the class.
</span><span class="keyword">private</span><span class="special">:</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span> <span class="identifier">vector_</span><span class="special">;</span>        
<span class="special">};</span>
</pre>
<p>
        Where "<code class="computeroutput"><span class="identifier">oldof</span> <span class="identifier">size</span><span class="special">()</span></code>" indicates the value <code class="computeroutput"><span class="identifier">size</span><span class="special">()</span></code>
        has before the <code class="computeroutput"><span class="identifier">push_back</span><span class="special">()</span></code> function is executed.
      </p>
<p>
        To keep this example simple, we intentionally did not write the full contract
        but we only wrote one invariant, one precondition, and one postcondition
        (see the STL Vector <a class="link" href="examples.html" title="Examples">Example</a> for
        the complete <code class="computeroutput"><span class="identifier">push_back</span><span class="special">()</span></code>
        contract). These contract conditions specify the followings:
      </p>
<div class="orderedlist"><ol type="1">
<li>
          The class invariant asserts that the vector is empty if and only if its
          size is zero.
        </li>
<li>
          The precondition asserts that the vector size must be smaller than the
          maximum size when <code class="computeroutput"><span class="identifier">push_back</span><span class="special">()</span></code> is called (so there is available space
          to add one extra vector element).
        </li>
<li>
          The postcondition asserts that the vector size must increase by 1 after
          <code class="computeroutput"><span class="identifier">push_back</span><span class="special">()</span></code>
          has been executed (to reflect the newly added vector element).
        </li>
</ol></div>
<p>
        <span class="bold"><strong>Step 2)</strong></span> The library provides the <code class="computeroutput"><a href="../CONTRACT_FUNCTION.html" target="_top">CONTRACT_FUNCTION</a><span class="special">()</span></code>
        macro to write member function contracts. This macro must be used <span class="emphasis"><em>right
        after</em></span> the <code class="computeroutput"><span class="identifier">push_back</span><span class="special">()</span></code> function declaration. The <code class="computeroutput"><span class="identifier">push_back</span><span class="special">()</span></code>
        function definition <code class="computeroutput"><span class="special">{</span> <span class="identifier">vector_</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">();</span> <span class="special">}</span></code> is moved
        within the macro becoming the last element of the <a href="http://www.boost.org/libs/preprocessor/doc/index.html" target="_top">Boost.Preprocessor</a>
        sequence passed as the macro parameter:
      </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">myvector</span> <span class="special">{</span>
    <span class="comment">// Invariant: (size() == 0) == empty()
</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="comment">// Precondition: size() &lt; max_size()
</span>    <span class="comment">// Postcondition: size() == (old size()) + 1
</span>    <span class="keyword">void</span> <span class="identifier">push_back</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">element</span><span class="special">)</span>
    <span class="bold"><strong>CONTRACT_FUNCTION</strong></span><span class="special">(</span> <span class="emphasis"><em>signature-sequence</em></span>
    <span class="emphasis"><em>precondition-sequence</em></span>
    <span class="emphasis"><em>postcondition-sequence</em></span>
    <span class="bold"><strong>(body) ({
        vector_.push_back(element);
    })</strong></span> ) <span class="comment">// No need for ";" after the macro closing parenthesis ")".
</span>
    <span class="special">...</span> <span class="comment">// Rest of the class.
</span><span class="keyword">private</span><span class="special">:</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span> <span class="identifier">vector_</span><span class="special">;</span>        
<span class="special">};</span>
</pre>
<p>
        There is no need for "<code class="computeroutput"><span class="special">;</span></code>"
        after the macro closing parenthesis "<code class="computeroutput"><span class="special">)</span></code>".
      </p>
<p>
        <span class="bold"><strong>Step 3)</strong></span> We now program the postconditions
        using <code class="computeroutput"><a href="../CONTRACT_ASSERT.html" target="_top">CONTRACT_ASSERT</a><span class="special">()</span></code> inside a code block <code class="computeroutput"><span class="special">{</span>
        <span class="special">...</span> <span class="special">}</span></code>
        specifying the <span class="emphasis"><em>postcondition-sequence</em></span> elements:
      </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">myvector</span> <span class="special">{</span>
    <span class="comment">// Invariant: (size() == 0) == empty()
</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="comment">// Precondition: size() &lt; max_size()
</span>    <span class="keyword">void</span> <span class="identifier">push_back</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">element</span><span class="special">)</span>
    <span class="identifier">CONTRACT_FUNCTION</span><span class="special">(</span> <span class="emphasis"><em>signature-sequence</em></span>
    <span class="emphasis"><em>precondition-sequence</em></span>
    <span class="bold"><strong>(postcondition) ({
        CONTRACT_ASSERT( size() == (CONTRACT_OLDOF(this)-&gt;size() + 1) );
    })</strong></span>
    <span class="special">(</span><span class="identifier">body</span><span class="special">)</span> <span class="special">({</span>
        <span class="identifier">vector_</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">element</span><span class="special">);</span>
    <span class="special">})</span> <span class="special">)</span>

    <span class="special">...</span> <span class="comment">// Rest of the class.
</span><span class="keyword">private</span><span class="special">:</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span> <span class="identifier">vector_</span><span class="special">;</span>        
<span class="special">};</span>
</pre>
<p>
        Note how <code class="computeroutput"><span class="identifier">CONTRACT_OLDOF</span><span class="special">(</span><span class="keyword">this</span><span class="special">)</span></code> is used
        to access the old object value as it was before body execution.
      </p>
<p>
        <span class="bold"><strong>Step 4)</strong></span> Similarly, we program the preconditions
        in a code block <code class="computeroutput"><span class="special">{</span> <span class="special">...</span>
        <span class="special">}</span></code> specifying the <span class="emphasis"><em>precondition-sequence</em></span>
        elements:
      </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">myvector</span> <span class="special">{</span>
    <span class="comment">// Invariant: (size() == 0) == empty()
</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">void</span> <span class="identifier">push_back</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">element</span><span class="special">)</span>
    <span class="identifier">CONTRACT_FUNCTION</span><span class="special">(</span> <span class="emphasis"><em>signature-sequence</em></span>
    <span class="bold"><strong>(precondition) ({
        CONTRACT_ASSERT( size() &lt; max_size() );
    })</strong></span>
    <span class="special">(</span><span class="identifier">postcondition</span><span class="special">)</span> <span class="special">({</span>
        <span class="identifier">CONTRACT_ASSERT</span><span class="special">(</span> <span class="identifier">size</span><span class="special">()</span> <span class="special">==</span> <span class="special">(</span><span class="identifier">CONTRACT_OLDOF</span><span class="special">(</span><span class="keyword">this</span><span class="special">)-&gt;</span><span class="identifier">size</span><span class="special">()</span> <span class="special">+</span> <span class="number">1</span><span class="special">)</span> <span class="special">);</span>

    <span class="special">})</span>
    <span class="special">(</span><span class="identifier">body</span><span class="special">)</span> <span class="special">({</span>
        <span class="identifier">vector_</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">element</span><span class="special">);</span>
    <span class="special">})</span> <span class="special">)</span>

    <span class="special">...</span> <span class="comment">// Rest of the class.
</span><span class="keyword">private</span><span class="special">:</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span> <span class="identifier">vector_</span><span class="special">;</span>        
<span class="special">};</span>
</pre>
<p>
        <span class="bold"><strong>Step 5)</strong></span> The <span class="emphasis"><em>signature-sequence</em></span>
        elements are discussed separately (see below) and for now we will leave them
        unresolved.
      </p>
<p>
        <span class="bold"><strong>Step 6)</strong></span> Similarly to what we did with for
        preconditions and postconditions, we program the class invariants in a code
        block <code class="computeroutput"><span class="special">{</span> <span class="special">...</span>
        <span class="special">}</span></code> specifying sequence elements passed
        to the <code class="computeroutput"><a href="../CONTRACT_INVARIANT.html" target="_top">CONTRACT_INVARIANT</a><span class="special">()</span></code> macro:
      </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">myvector</span> <span class="special">{</span>
    
    <span class="bold"><strong>CONTRACT_INVARIANT( ({
        CONTRACT_ASSERT( (size() == 0) == empty() );
    }) )</strong></span> <span class="comment">// Again, no need for ";" after the macro closing parenthesis ")".
</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">void</span> <span class="identifier">push_back</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">element</span><span class="special">)</span>
    <span class="identifier">CONTRACT_FUNCTION</span><span class="special">(</span> <span class="emphasis"><em>signature-sequence</em></span>
    <span class="special">(</span><span class="identifier">precondition</span><span class="special">)</span> <span class="special">({</span>
        <span class="identifier">CONTRACT_ASSERT</span><span class="special">(</span> <span class="identifier">size</span><span class="special">()</span> <span class="special">&lt;</span> <span class="identifier">max_size</span><span class="special">()</span> <span class="special">);</span>
    <span class="special">})</span>
    <span class="special">(</span><span class="identifier">postcondition</span><span class="special">)</span> <span class="special">({</span>
        <span class="identifier">CONTRACT_ASSERT</span><span class="special">(</span> <span class="identifier">size</span><span class="special">()</span> <span class="special">==</span> <span class="special">(</span><span class="identifier">CONTRACT_OLDOF</span><span class="special">(</span><span class="keyword">this</span><span class="special">)-&gt;</span><span class="identifier">size</span><span class="special">()</span> <span class="special">+</span> <span class="number">1</span><span class="special">)</span> <span class="special">);</span>

    <span class="special">})</span>
    <span class="special">(</span><span class="identifier">body</span><span class="special">)</span> <span class="special">({</span>
        <span class="identifier">vector_</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">element</span><span class="special">);</span>
    <span class="special">})</span> <span class="special">)</span>

    <span class="special">...</span> <span class="comment">// Rest of the class.
</span><span class="keyword">private</span><span class="special">:</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span> <span class="identifier">vector_</span><span class="special">;</span>        
<span class="special">};</span>
</pre>
<p>
        Again, there is no need for "<code class="computeroutput"><span class="special">;</span></code>"
        after the macro closing parenthesis "<code class="computeroutput"><span class="special">)</span></code>".
      </p>
<p>
        <span class="bold"><strong>Step 7)</strong></span> The same step-by-step process can
        be applied to understand the usage of <code class="computeroutput"><a href="../CONTRACT_CONSTRUCTOR.html" target="_top">CONTRACT_CONSTRUCTOR</a><span class="special">()</span></code> and <code class="computeroutput"><a href="../CONTRACT_DESTRUCTOR.html" target="_top">CONTRACT_DESTRUCTOR</a><span class="special">()</span></code> (see the example at the very end of this
        section).
      </p>
<a name="contract__.tutorial.writing_contracts.contract_code_blocks"></a><h6>
<a name="id2609497"></a>
        <a class="link" href="tutorial.html#contract__.tutorial.writing_contracts.contract_code_blocks">Contract
        Code Blocks</a>
      </h6>
<p>
        This library allows for arbitrary constant-correct code within the class
        invariant, precondition, and postcondition code blocks <code class="computeroutput"><span class="special">({</span>
        <span class="special">...</span> <span class="special">})</span></code>.
      </p>
<p>
        In other words, the class invariant, precondition, and postcondition code
        blocks can contain any legal C++ code and they can access any constant class
        member (private, protected, or public). However, writing complex code in
        the contracts will increase the probability of introducing bugs in the contracts
        themselves so it is better to limit the contract code to a simple list of
        assertions with occasional if-statements to guard them. Furthermore, if non-public
        members are used in preconditions then the callers will not be able to fully
        check the preconditions to make sure the contract is satisfied before calling
        the function so it is best to only use public members at least in preconditions
        <sup>[<a name="id2552836" href="#ftn.id2552836" class="footnote">8</a>]</sup>
        .
      </p>
<p>
        In addition, this library checks class invariants (as well as preconditions
        and postconditions) only for functions that have a contract. For example,
        if a private member function is allowed to <span class="emphasis"><em>temporarily</em></span>
        brake the class invariants, you can omit the contract for that one private
        function so no invariants (as well as no preconditions and no postconditions)
        will be checked when that function is called. However, it should never be
        the case that public member functions can brake class invariants. It is recommended
        to write contracts for all functions (public and non) with the rare exceptions
        of a private member function that cannot be programmed without allowing for
        it to temporarily brake the class invariants.
      </p>
<div class="important"><table border="0" summary="Important">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src=".././doc/html/images/important.png"></td>
<th align="left">Important</th>
</tr>
<tr><td align="left" valign="top">
<p>
          <span class="bold"><strong>Recommended Practices</strong></span>
        </p>
<p>
          1. Limit the contract code to a list of assertions with occasional if-statements
          to guard them.
        </p>
<p>
          2. Only access public class members when asserting preconditions.
        </p>
<p>
          3. Write contracts at least for all public member functions (even if they
          have no preconditions and no postconditions) so they check the class invariants.
        </p>
</td></tr>
</table></div>
<p>
        These practices are followed by all the examples of this documentation.
      </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="contract__.tutorial.signature_sequence"></a><a class="link" href="tutorial.html#contract__.tutorial.signature_sequence" title="Signature Sequence">Signature Sequence</a>
</h3></div></div></div>
<p>
        The very first elements of the <a href="http://www.boost.org/libs/preprocessor/doc/index.html" target="_top">Boost.Preprocessor</a>
        sequence passed to the macros <code class="computeroutput"><a href="../CONTRACT_CONSTRUCTOR.html" target="_top">CONTRACT_CONSTRUCTOR</a><span class="special">()</span></code>, <code class="computeroutput"><a href="../CONTRACT_DESTRUCTOR.html" target="_top">CONTRACT_DESTRUCTOR</a><span class="special">()</span></code>, and <code class="computeroutput"><a href="../CONTRACT_FUNCTION.html" target="_top">CONTRACT_FUNCTION</a><span class="special">()</span></code> are the elements of the <span class="emphasis"><em>signature-sequence</em></span>
        <sup>[<a name="id2609836" href="#ftn.id2609836" class="footnote">9</a>]</sup>
        . The <span class="emphasis"><em>signature-sequence</em></span> repeats the syntactic elements
        of the function declaration.
      </p>
<p>
        The syntax of <span class="emphasis"><em>signature-sequence</em></span> is somewhat unusual
        (even if it is all legal ISO standard C++). However, there is a convenient
        rule for remembering this syntax:
      </p>
<div class="important"><table border="0" summary="Important">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src=".././doc/html/images/important.png"></td>
<th align="left">Important</th>
</tr>
<tr><td align="left" valign="top">
<p>
          <span class="bold"><strong>Signature Sequence Mnemonic</strong></span>
        </p>
<p>
          The tokens in the signature sequence appear in the exact same order as
          they appear in the relative function declaration.
        </p>
</td></tr>
</table></div>
<a name="contract__.tutorial.signature_sequence.an_example"></a><h6>
<a name="id2610067"></a>
        <a class="link" href="tutorial.html#contract__.tutorial.signature_sequence.an_example">An Example</a>
      </h6>
<p>
        Let's consider the following example (with respect to the <code class="computeroutput"><span class="identifier">myvector</span></code>
        example above, we have added the base class <code class="computeroutput"><span class="identifier">pushable</span></code>
        to show how to subcontract):
      </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="bold"><strong>class myvector:</strong></span> <span class="keyword">public</span> <span class="bold"><strong>pushable&lt;T&gt;</strong></span> <span class="special">{</span>
<span class="bold"><strong>public</strong></span><span class="special">:</span>
    <span class="bold"><strong>void push_back(const T&amp; element)</strong></span>
    <span class="identifier">CONTRACT_FUNCTION</span><span class="special">(</span> <span class="emphasis"><em>signature-sequence</em></span> <span class="special">...</span> <span class="special">)</span>
    <span class="special">...</span>
<span class="special">};</span>
</pre>
<p>
        Applying the mnemonic rule, we read the declaration of <code class="computeroutput"><span class="identifier">push_back</span><span class="special">()</span></code> from top to bottom and we find the following
        tokens in the listed order (we have to start all the way up to the top of
        the <code class="computeroutput"><span class="identifier">myvector</span></code> class declaration):
      </p>
<div class="orderedlist"><ol type="1">
<li>
          The <span class="bold"><strong><code class="literal">class</code></strong></span> keyword for
          <code class="computeroutput"><span class="identifier">myvector</span></code> (this indicates
          that <code class="computeroutput"><span class="identifier">push_back</span></code> is a member
          function).
        </li>
<li>
          The <span class="bold"><strong><code class="literal">myvector</code></strong></span> class
          type (this indicates that <code class="computeroutput"><span class="identifier">push_back</span></code>
          is a member function of <code class="computeroutput"><span class="identifier">myvector</span></code>).
        </li>
<li>
          The <span class="bold"><strong><code class="literal">pushable&lt;T&gt;</code></strong></span>
          base class which is repeated in <span class="emphasis"><em>signature-sequence</em></span>
          as <code class="computeroutput"><span class="special">(</span><span class="identifier">inherit</span><span class="special">)(</span><span class="identifier">pushable</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;)</span></code> but only when the function is subcontracting
          from the specified base class (because "<code class="computeroutput"><span class="special">:</span></code>"
          is not a valid preprocessor token <code class="computeroutput"><span class="special">(</span><span class="identifier">inherit</span><span class="special">)</span></code>
          is used instead; also the inheritance access level, the <code class="computeroutput"><span class="keyword">public</span></code>
          keyword in this case, is not relevant and it is not repeated in <span class="emphasis"><em>signature-sequence</em></span>).
        </li>
<li>
          The <span class="bold"><strong><code class="literal">public</code></strong></span> access level
          of the <code class="computeroutput"><span class="identifier">push_back</span><span class="special">()</span></code>
          member function.
        </li>
<li>
          The <span class="bold"><strong><code class="literal">void</code></strong></span> return type.
        </li>
<li>
          The <span class="bold"><strong><code class="literal">push_back</code></strong></span> function
          name.
        </li>
<li>
          The parenthesis "<span class="bold"><strong><code class="literal">(</code></strong></span>"
          to open the function argument list.
        </li>
<li>
          The <span class="bold"><strong><code class="literal">const T&amp;</code></strong></span> function
          argument type.
        </li>
<li>
          The <span class="bold"><strong><code class="literal">element</code></strong></span> function
          argument name.
        </li>
<li>
          The parenthesis "<span class="bold"><strong><code class="literal">)</code></strong></span>"
          to close the function argument list.
        </li>
</ol></div>
<p>
        Wrapping all these tokens within parenthesis <code class="computeroutput"><span class="special">()</span></code>
        and listing them in the exact order as they appear in the function declaration,
        we obtain the <span class="emphasis"><em>signature-sequence</em></span> elements for this example.
        The parenthesis <code class="computeroutput"><span class="special">()</span></code> around the
        tokens are mandatory because they are the ones actually creating the <a href="http://www.boost.org/libs/preprocessor/doc/index.html" target="_top">Boost.Preprocessor</a>
        sequence. New lines and spaces do not matter within preprocessor sequences.
      </p>
<pre class="programlisting"><span class="special">(</span><span class="keyword">class</span><span class="special">)</span> <span class="special">(</span><span class="identifier">copyable</span><span class="special">)(</span><span class="identifier">myvector</span><span class="special">)</span> <span class="special">(</span><span class="identifier">inherit</span><span class="special">)(</span><span class="identifier">vector_interface</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;)</span>
<span class="special">(</span><span class="keyword">public</span><span class="special">)</span> <span class="special">(</span><span class="keyword">void</span><span class="special">)</span> <span class="special">(</span><span class="identifier">push_back</span><span class="special">)(</span> <span class="special">(</span><span class="keyword">const</span> <span class="identifier">T</span><span class="special">&amp;)(</span><span class="identifier">element</span><span class="special">)</span> <span class="special">)</span>
</pre>
<p>
        The <code class="computeroutput"><span class="identifier">myvector</span></code> class type is
        preceded by <code class="computeroutput"><span class="special">(</span><span class="identifier">copyable</span><span class="special">)</span></code> because, for this example, we wanted to
        access the old object value <code class="computeroutput"><span class="identifier">CONTRACT_OLDOF</span><span class="special">(</span><span class="keyword">this</span><span class="special">)</span></code>
        (as the object was before the function body execution) in the postconditions.
        Also any function argument type can be tagged copyable if the old value of
        the related argument is needed in the postconditions. In this example, <code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="identifier">T</span><span class="special">&amp;)(</span><span class="identifier">element</span><span class="special">)</span></code> could have been tagged copyable and specified
        in <span class="emphasis"><em>signature-sequence</em></span> as <code class="computeroutput"><span class="special">(</span><span class="identifier">copyable</span><span class="special">)(</span><span class="keyword">const</span> <span class="identifier">T</span><span class="special">&amp;)(</span><span class="identifier">element</span><span class="special">)</span></code> if the old value of the argument <code class="computeroutput"><span class="identifier">CONTRACT_OLDOF</span><span class="special">(</span><span class="identifier">element</span><span class="special">)</span></code>
        (as the argument was before the body execution) was needed in the postconditions.
      </p>
<p>
        Completing the example presented in the previous section, with the addition
        of subcontracting <code class="computeroutput"><span class="identifier">myvector</span><span class="special">::</span><span class="identifier">push_back</span><span class="special">()</span></code> from <code class="computeroutput"><span class="identifier">pushable</span><span class="special">::</span><span class="identifier">push_back</span><span class="special">()</span></code>, we have:
      </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">myvector</span><span class="special">:</span> <span class="keyword">public</span> <span class="identifier">pushable</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span> <span class="special">{</span>
    
    <span class="identifier">CONTRACT_INVARIANT</span><span class="special">(</span> <span class="special">({</span>
        <span class="identifier">CONTRACT_ASSERT</span><span class="special">(</span> <span class="special">(</span><span class="identifier">size</span><span class="special">()</span> <span class="special">==</span> <span class="number">0</span><span class="special">)</span> <span class="special">==</span> <span class="identifier">empty</span><span class="special">()</span> <span class="special">);</span>
    <span class="special">})</span> <span class="special">)</span>

<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">void</span> <span class="identifier">push_back</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">element</span><span class="special">)</span>
    <span class="identifier">CONTRACT_FUNCTION</span><span class="special">(</span> <span class="bold"><strong>(class) (copyable)(myvector)
            (inherit)(pushable&lt;T&gt;)
            (public) (void) (push_back)( (const T&amp;)(element) )</strong></span>
    <span class="special">(</span><span class="identifier">precondition</span><span class="special">)</span> <span class="special">({</span>
        <span class="identifier">CONTRACT_ASSERT</span><span class="special">(</span> <span class="identifier">size</span><span class="special">()</span> <span class="special">&lt;</span> <span class="identifier">max_size</span><span class="special">()</span> <span class="special">);</span>
    <span class="special">})</span>
    <span class="special">(</span><span class="identifier">postcondition</span><span class="special">)</span> <span class="special">({</span>
        <span class="identifier">CONTRACT_ASSERT</span><span class="special">(</span> <span class="identifier">size</span><span class="special">()</span> <span class="special">==</span> <span class="special">(</span><span class="identifier">CONTRACT_OLDOF</span><span class="special">(</span><span class="keyword">this</span><span class="special">)-&gt;</span><span class="identifier">size</span><span class="special">()</span> <span class="special">+</span> <span class="number">1</span><span class="special">)</span> <span class="special">);</span>
    <span class="special">})</span>
    <span class="special">(</span><span class="identifier">body</span><span class="special">)</span> <span class="special">({</span>
        <span class="identifier">vector_</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">element</span><span class="special">);</span>
    <span class="special">})</span> <span class="special">)</span>

    <span class="special">...</span> <span class="comment">// Rest of the class.
</span><span class="keyword">private</span><span class="special">:</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span> <span class="identifier">vector_</span><span class="special">;</span>        
<span class="special">};</span>
</pre>
<p>
        This is a fully working example assuming that:
      </p>
<div class="orderedlist"><ol type="1">
<li>
<code class="computeroutput"><span class="identifier">pushable</span><span class="special">::</span><span class="identifier">push_back</span><span class="special">()</span></code>
          also has a contract specified using this library since it is used for subcontracting
          (this library allows to specify contracts also for pure virtual functions,
          see below).
        </li>
<li>
<code class="computeroutput"><span class="identifier">myvector</span></code> has an accessible
          constant-correct
          <sup>[<a name="id2611416" href="#ftn.id2611416" class="footnote">10</a>]</sup>
          copy constructor since it was tagged <code class="computeroutput"><span class="special">(</span><span class="identifier">copyable</span><span class="special">)</span></code>
          (see <code class="computeroutput"><span class="identifier">contract</span><span class="special">::</span><a href="../contract/copy.html" target="_top">copy</a></code>):
        </li>
</ol></div>
<pre class="programlisting"><span class="comment">// Must be accessible and construct from a const&amp; parameter.
</span><span class="identifier">myvector</span><span class="special">::</span><span class="identifier">myvector</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">myvector</span><span class="special">&amp;</span> <span class="identifier">source</span><span class="special">)</span> <span class="special">{</span> <span class="special">...</span> <span class="special">}</span>
</pre>
<p>
        If either one of these conditions is not true, this library will generate
        a compile-time errors when attempting to compile the code above.
      </p>
<a name="contract__.tutorial.signature_sequence.full_syntax"></a><h6>
<a name="id2611547"></a>
        <a class="link" href="tutorial.html#contract__.tutorial.signature_sequence.full_syntax">Full Syntax</a>
      </h6>
<p>
        Generalizing this example to include <span class="emphasis"><em>all</em></span> possible syntactic
        elements that can be found in a C++ function declaration, we obtain the full
        syntax for <span class="emphasis"><em>signature-sequence</em></span>.
      </p>
<p>
        <span class="bold"><strong><span class="emphasis"><em>signature-sequence</em></span> syntax for
        <code class="computeroutput"><a href="../CONTRACT_FUNCTION.html" target="_top">CONTRACT_FUNCTION</a><span class="special">()</span></code>:</strong></span>
      </p>
<pre class="programlisting"><span class="emphasis"><em>{</em></span><span class="special">(</span><span class="keyword">class</span><span class="special">)</span> <span class="emphasis"><em>[</em></span><span class="special">(</span><span class="identifier">copyable</span><span class="special">)</span><span class="emphasis"><em>]</em></span><span class="special">(</span><span class="emphasis"><em>class-type</em></span><span class="special">)</span> <span class="emphasis"><em>{</em></span><span class="special">(</span><span class="identifier">inherit</span><span class="special">)(</span><span class="emphasis"><em>base-class-type</em></span><span class="special">)</span><span class="emphasis"><em>}*</em></span>
<span class="emphasis"><em>{</em></span><span class="special">(</span><span class="keyword">public</span><span class="special">)</span> <span class="emphasis"><em>||</em></span> <span class="special">(</span><span class="keyword">protected</span><span class="special">)</span> <span class="emphasis"><em>||</em></span> <span class="special">(</span><span class="keyword">private</span><span class="special">)</span><span class="emphasis"><em>}}::</em></span>
<span class="emphasis"><em>[</em></span><span class="special">(</span><span class="keyword">template</span><span class="special">)(</span> <span class="emphasis"><em>{</em></span><span class="special">(</span><span class="emphasis"><em>function-template-parameter-type</em></span><span class="special">)(</span><span class="emphasis"><em>function-template-parameter-name</em></span><span class="special">)</span><span class="emphasis"><em>}+</em></span> <span class="special">)</span><span class="emphasis"><em>]</em></span>
<span class="emphasis"><em>[</em></span><span class="special">(</span><span class="keyword">static</span><span class="special">)</span><span class="emphasis"><em>]</em></span> <span class="emphasis"><em>[</em></span><span class="special">(</span><span class="keyword">virtual</span><span class="special">)</span><span class="emphasis"><em>]</em></span>
<span class="special">(</span><span class="emphasis"><em>result-type</em></span><span class="special">)</span> <span class="special">(</span><span class="emphasis"><em>function-name</em></span><span class="special">)(</span> <span class="emphasis"><em>{</em></span><span class="special">(</span><span class="keyword">void</span><span class="special">)</span> <span class="emphasis"><em>||</em></span> <span class="emphasis"><em>{[</em></span><span class="special">(</span><span class="identifier">copyable</span><span class="special">)</span><span class="emphasis"><em>]</em></span><span class="special">(</span><span class="emphasis"><em>argument-type</em></span><span class="special">)(</span><span class="emphasis"><em>argument-name</em></span><span class="special">)</span><span class="emphasis"><em>}+}</em></span> <span class="special">)</span> <span class="emphasis"><em>[</em></span><span class="special">(</span><span class="keyword">const</span><span class="special">)</span><span class="emphasis"><em>]</em></span>
</pre>
<p>
        Where we have used the following conventions:
      </p>
<div class="itemizedlist"><ul type="disc">
<li>
<span class="emphasis"><em>[</em></span><code class="literal">item</code><span class="emphasis"><em>]</em></span> indicates
          an optional item.
        </li>
<li>
<code class="literal">item</code><span class="emphasis"><em>*</em></span> indicates an item repeated
          zero of more times.
        </li>
<li>
<code class="literal">item</code><span class="emphasis"><em>+</em></span> indicates an item repeated
          one of more times.
        </li>
<li>
<span class="emphasis"><em>{</em></span><code class="literal">item1 </code><span class="emphasis"><em>operation </em></span><code class="literal">item2 </code><span class="emphasis"><em>operation ...}</em></span> indicates
          the item resulting after evaluating the contents within the curly parenthesis.
        </li>
<li>
<code class="literal">item1</code><span class="emphasis"><em>|| </em></span><code class="literal">item2</code>
          indicates that either items can be specified.
        </li>
<li>
<span class="emphasis"><em>{</em></span><code class="literal">item</code><span class="emphasis"><em>}::</em></span> indicates
          that item is` specified only for member functions.
        </li>
</ul></div>
<p>
        For example:
      </p>
<div class="itemizedlist"><ul type="disc">
<li>
<span class="emphasis"><em>[</em></span><code class="computeroutput"><span class="special">(</span><span class="identifier">copyable</span><span class="special">)</span></code><span class="emphasis"><em>]</em></span> indicates that
          <code class="computeroutput"><span class="special">(</span><span class="identifier">copyable</span><span class="special">)</span></code> is optional (it will only be specified
          for variables with old values in postconditions).
        </li>
<li>
<span class="emphasis"><em>{</em></span><code class="computeroutput"><span class="special">(</span><span class="identifier">inherit</span><span class="special">)(</span></code><span class="emphasis"><em>base-class-type</em></span><code class="computeroutput"><span class="special">)</span></code><span class="emphasis"><em>}*</em></span> indicates that
          <code class="computeroutput"><span class="special">(</span><span class="identifier">inherit</span><span class="special">)(</span></code><span class="emphasis"><em>base-class-type</em></span><code class="computeroutput"><span class="special">)</span></code> can be repeated zero or more times (it
          can be omitted, it will only be specified when subcontracting, and when
          specified it can be repeated multiple times to support subcontracting from
          multiple base classes in case of multiple inheritance).
        </li>
<li>
<span class="emphasis"><em>{[</em></span><code class="computeroutput"><span class="special">(</span><span class="identifier">copyable</span><span class="special">)</span></code><span class="emphasis"><em>]</em></span><code class="computeroutput"><span class="special">(</span></code><span class="emphasis"><em>argument-type</em></span><code class="computeroutput"><span class="special">)(</span></code>argument-name<code class="computeroutput"><span class="special">)</span></code><span class="emphasis"><em>}+</em></span>
          indicates that the function arguments (when specified instead of <code class="computeroutput"><span class="special">(</span><span class="keyword">void</span><span class="special">)</span></code>)
          must be repeated one or more type (together with their optional <code class="computeroutput"><span class="special">(</span><span class="identifier">copyable</span><span class="special">)</span></code> tag).
        </li>
<li>
<span class="emphasis"><em>[</em></span><code class="computeroutput"><span class="special">(</span><span class="keyword">public</span><span class="special">)</span></code><span class="emphasis"><em>|| </em></span><code class="computeroutput"><span class="special">(</span><span class="keyword">protected</span><span class="special">)</span></code><span class="emphasis"><em>|| </em></span><code class="computeroutput"><span class="special">(</span><span class="keyword">private</span><span class="special">)</span></code><span class="emphasis"><em>]</em></span> indicates that the
          access level is optional but when specified it must be either <code class="computeroutput"><span class="special">(</span><span class="keyword">public</span><span class="special">)</span></code>, <code class="computeroutput"><span class="special">(</span><span class="keyword">protected</span><span class="special">)</span></code>,
          or <code class="computeroutput"><span class="special">(</span><span class="keyword">private</span><span class="special">)</span></code>.
        </li>
</ul></div>
<p>
        The usual C++ syntax constraints apply. For example, <code class="computeroutput"><span class="special">(</span><span class="keyword">static</span><span class="special">)</span></code> cannot
        be specified together with <code class="computeroutput"><span class="special">(</span><span class="keyword">virtual</span><span class="special">)</span></code> and
        they can only be specified for class members so when <code class="computeroutput"><span class="special">(</span><span class="keyword">class</span><span class="special">)</span></code> is
        also specified. The library will generate compile-time errors if <span class="emphasis"><em>signature-sequence</em></span>
        contains tokens combinations which are C++ syntactically invalid.
      </p>
<p>
        Note that within <span class="emphasis"><em>signature-sequence</em></span>, multiple function
        arguments (as well as function template parameters) are <span class="emphasis"><em>not</em></span>
        separated by commas (you can use a space or a new line instead):
      </p>
<pre class="programlisting"><span class="special">(</span><span class="emphasis"><em>function-name</em></span><span class="special">)(</span> <span class="special">(</span><span class="emphasis"><em>argument-type1</em></span><span class="special">)(</span><span class="emphasis"><em>argument-name1</em></span><span class="special">)</span>
        <span class="comment">/* no comma (a space or new line can be used instead) */</span>
        <span class="special">(</span><span class="emphasis"><em>argument-type2</em></span><span class="special">)(</span><span class="emphasis"><em>arguments-name2</em></span><span class="special">)</span>
        <span class="comment">/* no comma (a space or new line can be used instead) */</span>
        <span class="special">(</span><span class="emphasis"><em>argument-type3</em></span><span class="special">)(</span><span class="emphasis"><em>argument-name3</em></span><span class="special">)</span> <span class="emphasis"><em>...</em></span> <span class="special">)</span>
</pre>
<p>
        Furthermore, if the function has no arguments, the argument list must be
        specified <code class="computeroutput"><span class="keyword">void</span></code>:
      </p>
<pre class="programlisting"><span class="special">(</span><span class="emphasis"><em>function-name</em></span><span class="special">)(</span> <span class="special">(</span><span class="keyword">void</span><span class="special">)</span> <span class="special">)</span>
</pre>
<p>
        Note that <code class="computeroutput"><span class="special">(</span></code><span class="emphasis"><em>function-name</em></span><code class="computeroutput"><span class="special">)(</span> <span class="special">)</span></code> <span class="bold"><strong>cannot</strong></span> be used instead and it will generate a cryptic
        compile-time error.
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src=".././doc/html/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top">
<p>
          An empty function argument list cannot be represented simply by empty parenthesis
          <code class="computeroutput"><span class="special">()</span></code> as in <code class="computeroutput"><span class="special">(</span></code><span class="emphasis"><em>function-name</em></span><code class="computeroutput"><span class="special">)()</span></code> because the C++ standard does not allow
          to specify empty preprocessor sequence elements like <code class="computeroutput"><span class="special">()</span></code>
          thus <code class="computeroutput"><span class="special">(</span></code><span class="emphasis"><em>function-name</em></span><code class="computeroutput"><span class="special">)(</span> <span class="special">(</span><span class="keyword">void</span><span class="special">)</span> <span class="special">)</span></code> must
          be used instead. Note that the C++ standard allows to use <code class="computeroutput"><span class="keyword">void</span></code> to specify a function with no arguments
          <span class="emphasis"><em>function-name</em></span><code class="computeroutput"><span class="special">(</span><span class="keyword">void</span><span class="special">)</span></code> (this
          is the syntax used in all the examples of this documentations to be consistent
          with the relative <span class="emphasis"><em>signature-sequence</em></span> syntax requirement).
        </p>
<p>
          The C99 standard instead allows for empty preprocessor sequence elements
          <code class="computeroutput"><span class="special">()</span></code> (because it allows for
          empty macro parameters, see <a class="link" href="bibliography.html" title="Bibliography">[Nelson2004]</a>
          and <a href="http://www.boost.org/libs/preprocessor/doc/index.html" target="_top">Boost.Preprocessor</a>
          for details). C99 also defines deprecated the use of <code class="computeroutput"><span class="keyword">void</span></code>
          for functions with no arguments -- <span class="emphasis"><em>function-name</em></span><code class="computeroutput"><span class="special">(</span><span class="keyword">void</span><span class="special">)</span></code>
          is deprecated. Therefore, on C99 compilers <code class="computeroutput"><span class="special">(</span></code><span class="emphasis"><em>function-name</em></span><code class="computeroutput"><span class="special">)()</span></code> should be used in <span class="emphasis"><em>signature-sequence</em></span>
          for functions with no arguments instead of <code class="computeroutput"><span class="special">(</span></code><span class="emphasis"><em>function-name</em></span><code class="computeroutput"><span class="special">)(</span> <span class="special">(</span><span class="keyword">void</span><span class="special">)</span> <span class="special">)</span></code>.
        </p>
<p>
          This library supports both syntaxes <code class="computeroutput"><span class="special">(</span></code><span class="emphasis"><em>function-name</em></span><code class="computeroutput"><span class="special">)(</span> <span class="special">(</span><span class="keyword">void</span><span class="special">)</span> <span class="special">)</span></code> and
          <code class="computeroutput"><span class="special">(</span></code><span class="emphasis"><em>function-name</em></span><code class="computeroutput"><span class="special">)()</span></code> in <span class="emphasis"><em>signature-sequence</em></span>
          but the later syntax will only compile for C99 (so it is not recommended).
        </p>
<p>
          The same limitation applies to the <code class="computeroutput"><a href="../CONTRACT_INVARIANT.html" target="_top">CONTRACT_INVARIANT</a><span class="special">()</span></code> macro when the class has no invariant.
          Also in this case the library supports both syntaxes <code class="computeroutput"><a href="../CONTRACT_INVARIANT.html" target="_top">CONTRACT_INVARIANT</a><span class="special">(</span> <span class="special">({})</span> <span class="special">)</span></code> and <code class="computeroutput"><a href="../CONTRACT_INVARIANT.html" target="_top">CONTRACT_INVARIANT</a><span class="special">()</span></code> bu the later syntax will only compile
          for C99 (so it is not recommended).
        </p>
</td></tr>
</table></div>
<p>
        Finally, the syntaxes of <span class="emphasis"><em>signature-sequence</em></span> used by
        <code class="computeroutput"><a href="../CONTRACT_CONSTRUCTOR.html" target="_top">CONTRACT_CONSTRUCTOR</a><span class="special">()</span></code> and <code class="computeroutput"><a href="../CONTRACT_DESTRUCTOR.html" target="_top">CONTRACT_DESTRUCTOR</a><span class="special">()</span></code> are somewhat different because C++ uses
        different syntactic elements for constructor and destructor declarations
        than for member functions (constructors cannot be virtual, destructors cannot
        have function arguments, etc). However, the syntax for these <span class="emphasis"><em>signature-sequences</em></span>
        are still obtained applying the basic rule of listing the constructor and
        destructor signature tokens in the exact same order as they appear in the
        constructor and destructor declarations.
      </p>
<p>
        <span class="bold"><strong><span class="emphasis"><em>signature-sequence</em></span> syntax for
        <code class="computeroutput"><a href="../CONTRACT_CONSTRUCTOR.html" target="_top">CONTRACT_CONSTRUCTOR</a><span class="special">()</span></code>:</strong></span>
      </p>
<pre class="programlisting"><span class="special">(</span><span class="keyword">class</span><span class="special">)</span> <span class="special">(</span><span class="emphasis"><em>class-type</em></span><span class="special">)</span>
<span class="emphasis"><em>{</em></span><span class="special">(</span><span class="keyword">public</span><span class="special">)</span> <span class="emphasis"><em>||</em></span> <span class="special">(</span><span class="keyword">protected</span><span class="special">)</span> <span class="emphasis"><em>||</em></span> <span class="special">(</span><span class="keyword">private</span><span class="special">)</span><span class="emphasis"><em>}</em></span>
<span class="emphasis"><em>[</em></span><span class="special">(</span><span class="keyword">template</span><span class="special">)(</span> <span class="emphasis"><em>{</em></span><span class="special">(</span><span class="emphasis"><em>function-template-parameter-type</em></span><span class="special">)(</span><span class="emphasis"><em>function-template-parameter-name</em></span><span class="special">)</span><span class="emphasis"><em>}+</em></span> <span class="special">)</span><span class="emphasis"><em>]</em></span>
<span class="special">(</span><span class="emphasis"><em>class-name</em></span><span class="special">)(</span> <span class="emphasis"><em>{</em></span><span class="special">(</span><span class="keyword">void</span><span class="special">)</span> <span class="emphasis"><em>||</em></span> <span class="emphasis"><em>{[</em></span><span class="special">(</span><span class="identifier">copyable</span><span class="special">)</span><span class="emphasis"><em>]</em></span><span class="special">(</span><span class="emphasis"><em>argument-type</em></span><span class="special">)(</span><span class="emphasis"><em>argument-name</em></span><span class="special">)</span><span class="emphasis"><em>}+}</em></span> <span class="special">)</span>
</pre>
<p>
        Note that constructors are always class members so <code class="computeroutput"><span class="special">(</span><span class="keyword">class</span><span class="special">)</span></code> is
        not optional and it must always be specified.
      </p>
<p>
        <span class="bold"><strong><span class="emphasis"><em>signature-sequence</em></span> syntax for
        <code class="computeroutput"><a href="../CONTRACT_DESTRUCTOR.html" target="_top">CONTRACT_DESTRUCTOR</a><span class="special">()</span></code>:</strong></span>
      </p>
<pre class="programlisting"><span class="special">(</span><span class="keyword">class</span><span class="special">)</span> <span class="special">(</span><span class="emphasis"><em>class-type</em></span><span class="special">)</span>
<span class="emphasis"><em>{</em></span><span class="special">(</span><span class="keyword">public</span><span class="special">)</span> <span class="emphasis"><em>||</em></span> <span class="special">(</span><span class="keyword">protected</span><span class="special">)</span> <span class="emphasis"><em>||</em></span> <span class="special">(</span><span class="keyword">private</span><span class="special">)</span><span class="emphasis"><em>}</em></span>
(virtual) <span class="special">(</span><span class="emphasis"><em>class-name</em></span><span class="special">)(</span> <span class="special">(</span><span class="keyword">void</span><span class="special">)</span> <span class="special">)</span>
</pre>
<p>
        Note that <code class="computeroutput"><span class="string">"~"</span></code> is <span class="emphasis"><em>not</em></span>
        a valid preprocessor token so it is not used to name the destructor (just
        use the class name).
      </p>
<p>
        Also note that constructors and destructors do not directly subcontract (their
        <span class="emphasis"><em>signature-sequences</em></span> do not accept any <code class="computeroutput"><span class="special">(</span><span class="identifier">inherit</span><span class="special">)(</span></code><span class="emphasis"><em>base-class-type</em></span><code class="computeroutput"><span class="special">)</span></code> token). This is because the C++ object construction
        and destruction mechanism will automatically execute the code that checks
        the base class constructor and destructor contracts if present.
      </p>
<div class="warning"><table border="0" summary="Warning">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src=".././doc/html/images/warning.png"></td>
<th align="left">Warning</th>
</tr>
<tr><td align="left" valign="top">
<p>
          <span class="bold"><strong>Cryptic Preprocessing Errors</strong></span>
        </p>
<p>
          There is only a limited amount of compile-time error checking which the
          library can do on <span class="emphasis"><em>signature-sequence</em></span>. In some cases,
          and depending on the compiler used, an error in programming the <span class="emphasis"><em>signature-sequence</em></span>
          syntax will result in cryptic compiler errors.
        </p>
<p>
          These compiler errors might involve library internal templates and macros
          as well as <a href="http://www.boost.org/libs/preprocessor/doc/index.html" target="_top">Boost.Preprocessor</a>
          internal macros (<code class="computeroutput"><span class="identifier">BOOST_PP_</span><span class="special">...</span></code>). Furthermore, the error line number
          will only refer to the first line of code at which the contract macro appears
          (because new lines within macro parameters are removed by the preprocessor).
        </p>
<p>
          The best way to resolve these errors is usually to inspect the <span class="emphasis"><em>signature-sequence</em></span>
          by eye instead of trying to make sense of the compiler error messages.
          Also, try to compile with contracts turned off to make sure that the errors
          are actually in the contract code. Rarely, it might be useful to look at
          the code generated by the contract macro expansion after preprocessing
          using your compiler related options ("-E -P" on GCC, "/EP"
          on Microsoft Visual C++, etc).
        </p>
<p>
          While the C++ preprocessor imposes limits on the amount of error checking
          that can be performed on <span class="emphasis"><em>signature-sequence</em></span>, the current
          library implementation does <span class="emphasis"><em>not</em></span> implement the best
          possible preprocessor error detection and reporting strategy. This is an
          area of improvement for the library that is currently being worked on.
        </p>
<p>
          <span class="underline">Please report on the library <a href="http://sourceforge.net/projects/dbcpp/forums/forum/920163" target="_top">help
          website</a> the criptic preprocessing errors you experience in order
          to facilitate this process.</span>
        </p>
</td></tr>
</table></div>
<a name="contract__.tutorial.signature_sequence.inheritance"></a><h6>
<a name="id2613536"></a>
        <a class="link" href="tutorial.html#contract__.tutorial.signature_sequence.inheritance">Inheritance</a>
      </h6>
<p>
        The library supports subcontracting from multiple base classes in case of
        multiple inheritance.
      </p>
<p>
        <span class="bold"><strong>Multiple Inheritance</strong></span>
      </p>
<p>
        In case of multiple inheritance, it is possible to subcontract from multiple
        base classes by repeating <code class="computeroutput"><span class="special">(</span><span class="identifier">inherit</span><span class="special">)(</span></code><span class="emphasis"><em>base-class-type</em></span><code class="computeroutput"><span class="special">)</span></code> multiple times in <span class="emphasis"><em>signature-sequence</em></span>.
        For example, assuming <code class="computeroutput"><span class="identifier">myvector</span></code>
        is inheriting and subcontracting from <span class="emphasis"><em>both</em></span> the <code class="computeroutput"><span class="identifier">boundable</span></code> and the <code class="computeroutput"><span class="identifier">basic_begin</span></code>
        base classes:
      </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">myvector</span><span class="special">:</span>
        <span class="keyword">public</span> <span class="bold"><strong>boundable&lt;typename std::vector&lt;T&gt;::const_iterator&gt;</strong></span><span class="special">,</span>
        <span class="keyword">private</span> <span class="bold"><strong>basic_begin&lt;typename std::vector&lt;T&gt;::const_iterator&gt;</strong></span> <span class="special">{</span>
    <span class="special">...</span> <span class="comment">// Class invariants.
</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">typedef</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">const_iterator</span> <span class="identifier">const_iterator</span><span class="special">;</span>
    
    <span class="identifier">const_iterator</span> <span class="identifier">begin</span><span class="special">(</span><span class="keyword">void</span><span class="special">)</span> <span class="keyword">const</span>
    <span class="identifier">CONTRACT_FUNCTION</span><span class="special">(</span> <span class="special">(</span><span class="keyword">class</span><span class="special">)</span> <span class="special">(</span><span class="identifier">myvector</span><span class="special">)</span>
            <span class="comment">// Multiple inheritance.
</span>            <span class="bold"><strong>(inherit)(boundable&lt;const_iterator&gt;)</strong></span>
            <span class="bold"><strong>(inherit)(basic_begin&lt;const_iterator&gt;)</strong></span>
            <span class="special">(</span><span class="keyword">public</span><span class="special">)</span> <span class="special">(</span><span class="identifier">const_iterator</span><span class="special">)</span> <span class="special">(</span><span class="identifier">begin</span><span class="special">)(</span> <span class="special">(</span><span class="keyword">void</span><span class="special">)</span> <span class="special">)</span> <span class="special">(</span><span class="keyword">const</span><span class="special">)</span>
    <span class="comment">// No preconditions (omitted).
</span>    <span class="special">(</span><span class="identifier">postcondition</span><span class="special">)</span> <span class="special">(</span><span class="identifier">result</span><span class="special">)</span> <span class="special">({</span> <span class="comment">// Return value `result` in postconditions.
</span>        <span class="keyword">if</span> <span class="special">(</span><span class="identifier">empty</span><span class="special">())</span> <span class="identifier">CONTRACT_ASSERT</span><span class="special">(</span> <span class="identifier">result</span> <span class="special">==</span> <span class="identifier">end</span><span class="special">()</span> <span class="special">);</span>
    <span class="special">})</span>
    <span class="special">(</span><span class="identifier">body</span><span class="special">)</span> <span class="special">({</span>
        <span class="comment">// Must use CONTRACT_BODY() when calling the base function.
</span>        <span class="keyword">if</span> <span class="special">(</span><span class="identifier">basic_begin</span><span class="special">&lt;</span><span class="identifier">const_iterator</span><span class="special">&gt;::</span><span class="bold"><strong>CONTRACT_BODY</strong></span><span class="special">(</span><span class="identifier">begin</span><span class="special">)</span> <span class="special">==</span>
                <span class="identifier">const_iterator</span><span class="special">())</span> <span class="special">{</span>
            <span class="keyword">return</span> <span class="identifier">const_iterator</span><span class="special">();</span>
        <span class="special">}</span>
        <span class="keyword">return</span> <span class="identifier">vector_</span><span class="special">.</span><span class="identifier">begin</span><span class="special">();</span>
    <span class="special">})</span> <span class="special">)</span>

    <span class="special">...</span> <span class="comment">// Rest of the class.
</span><span class="keyword">private</span><span class="special">:</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span> <span class="identifier">vector_</span><span class="special">;</span>        
<span class="special">};</span>
</pre>
<p>
        The subcontracted contracts are checked in the order in which their <code class="computeroutput"><span class="special">(</span><span class="identifier">inherit</span><span class="special">)</span></code> tokens are listed in <span class="emphasis"><em>signature-sequence</em></span>
        and the derived class contracts are checked last.
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src=".././doc/html/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top">
<p>
          The above implies that if a derived class relaxes the precondition of an
          overridden function, all the base contract preconditions will have be checked
          first to fails before the relaxed preconditions of the overridden function
          are checked to pass.
        </p>
<p>
          In this case, it would appear more efficient to check the derived class
          contract first. However, the derived class invariants could be written
          assuming that the base class invariants hold true (for example the base
          class invariants could assert a pointer to be not null and thus the derived
          class invariants could deference the pointer without checking for nullity).
          In doing so, the derived class invariants assume that they are checked
          last in <span class="emphasis"><em>AND</em></span> with all base classes invariants. The
          same argument can be made for postconditions. Therefore, if derived class
          invariants (and postconditions) should be checked last in <span class="emphasis"><em>AND</em></span>
          with all base classes invariants (and postconditions). It is natural to
          follow the same policy and check derived class function preconditions last
          in the <span class="emphasis"><em>OR</em></span> with all base class function preconditions
          (even if this introduces the inefficiency to have to check and fail all
          the base class function preconditions when a derived class function if
          relaxing the base class function preconditions).
        </p>
</td></tr>
</table></div>
<p>
        <span class="bold"><strong>Base Function Call</strong></span>
      </p>
<p>
        When the derived class invokes the overridden function in the base class
        the <code class="computeroutput"><span class="identifier">CONTRACT_BODY</span><span class="special">()</span></code>
        macro must be used:
      </p>
<pre class="programlisting"><span class="emphasis"><em>base-class</em></span><span class="special">::</span><span class="identifier">CONTRACT_BODY</span><span class="special">(</span><span class="emphasis"><em>function-name</em></span><span class="special">)(...)</span>
</pre>
<p>
        as illustrated by the example above. The overriding function should <span class="bold"><strong>not</strong></span> call the overridden function directly without
        using the macro:
      </p>
<pre class="programlisting"><span class="emphasis"><em>base-class</em></span><span class="special">::</span><span class="emphasis"><em>function-name</em></span><span class="special">)(...)</span>
</pre>
<p>
        because this call will cause the contracts to executed infinite recursive
        calls (due to the dynamic binding of the contracted virtual base function
        <span class="emphasis"><em>base-class</em></span><code class="computeroutput"><span class="special">::</span></code><span class="emphasis"><em>function-name</em></span>).
        <sup>[<a name="id2614477" href="#ftn.id2614477" class="footnote">11</a>]</sup>
      </p>
<div class="warning"><table border="0" summary="Warning">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src=".././doc/html/images/warning.png"></td>
<th align="left">Warning</th>
</tr>
<tr><td align="left" valign="top">
<p>
          <span class="bold"><strong>Base Calls via CONTRACT_BODY()</strong></span>
        </p>
<p>
          Overriding functions must use <span class="emphasis"><em>base-class</em></span><code class="computeroutput"><span class="special">::</span><span class="identifier">CONTRACT_BODY</span><span class="special">(</span></code><span class="emphasis"><em>function-name</em></span><code class="computeroutput"><span class="special">)</span></code> and not just <span class="emphasis"><em>base-class</em></span><code class="computeroutput"><span class="special">::</span></code><span class="emphasis"><em>function-name</em></span> when
          calling the overridden functions (otherwise the contract calls will cause
          infinite recursion).
        </p>
</td></tr>
</table></div>
<a name="contract__.tutorial.signature_sequence.operators"></a><h6>
<a name="id2614662"></a>
        <a class="link" href="tutorial.html#contract__.tutorial.signature_sequence.operators">Operators</a>
      </h6>
<p>
        The library supports contracts for operators.
      </p>
<p>
        For operators, the <code class="computeroutput"><span class="special">(</span></code><span class="emphasis"><em>function-name</em></span><code class="computeroutput"><span class="special">)</span></code> token in <span class="emphasis"><em>signature-sequence</em></span>
        must contain both the operator symbol and the operator <span class="emphasis"><em>name</em></span>
        spelled out in words without using any special symbol (this is necessary
        because, in general, the operator special symbols (<code class="computeroutput"><span class="special">[]</span></code>,
        <code class="computeroutput"><span class="special">==</span></code>, <code class="computeroutput"><span class="special">&lt;&lt;</span></code>,
        etc) are not valid preprocessor tokens). For operators, <code class="computeroutput"><span class="special">(</span></code><span class="emphasis"><em>function-name</em></span><code class="computeroutput"><span class="special">)</span></code> takes the following form:
      </p>
<pre class="programlisting"><span class="special">(</span><span class="keyword">operator</span><span class="special">(</span><span class="emphasis"><em>symbol</em></span><span class="special">,</span> <span class="emphasis"><em>name</em></span><span class="special">))</span>
</pre>
<p>
        Note the necessary double closing parenthesis <code class="computeroutput"><span class="string">"))"</span></code>
        at the end. For example:
      </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">myvector</span> <span class="special">{</span>
    <span class="special">...</span> <span class="comment">// Class invariants.
</span>    
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">size_type</span> <span class="identifier">size_type</span><span class="special">;</span>
    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">const_reference</span> <span class="identifier">const_reference</span><span class="special">;</span>

    <span class="identifier">const_reference</span> <span class="bold"><strong>operator[]</strong></span><span class="special">(</span><span class="identifier">size_type</span> <span class="identifier">index</span><span class="special">)</span> <span class="keyword">const</span>
    <span class="identifier">CONTRACT_FUNCTION</span><span class="special">(</span> <span class="special">(</span><span class="keyword">class</span><span class="special">)</span> <span class="special">(</span><span class="identifier">myvector</span><span class="special">)</span>
            <span class="special">(</span><span class="keyword">public</span><span class="special">)</span> <span class="special">(</span><span class="identifier">const_reference</span><span class="special">)</span> <span class="bold"><strong>(operator([]</strong></span><span class="bold"><strong>, at))</strong></span><span class="special">(</span>
                    <span class="special">(</span><span class="identifier">size_type</span><span class="special">)(</span><span class="identifier">index</span><span class="special">)</span> <span class="special">)</span> <span class="special">(</span><span class="keyword">const</span><span class="special">)</span>
    <span class="special">(</span><span class="identifier">precondition</span><span class="special">)</span> <span class="special">({</span>
        <span class="identifier">CONTRACT_ASSERT</span><span class="special">(</span> <span class="identifier">index</span> <span class="special">&lt;</span> <span class="identifier">size</span><span class="special">()</span> <span class="special">);</span>
    <span class="special">})</span>
    <span class="comment">// No postconditions (omitted).
</span>    <span class="special">(</span><span class="identifier">body</span><span class="special">)</span> <span class="special">({</span>
        <span class="keyword">return</span> <span class="identifier">vector_</span><span class="special">[</span><span class="identifier">index</span><span class="special">];</span>
    <span class="special">})</span> <span class="special">)</span>

    <span class="special">...</span> <span class="comment">// Rest of the class.
</span><span class="keyword">private</span><span class="special">:</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span> <span class="identifier">vector_</span><span class="special">;</span> 
<span class="special">};</span>
</pre>
<p>
        The operator name, in this example <code class="computeroutput"><span class="string">"at"</span></code>,
        is arbitrary and any name without special symbols can been used.
      </p>
<a name="contract__.tutorial.signature_sequence.overloaded_functions"></a><h6>
<a name="id2615378"></a>
        <a class="link" href="tutorial.html#contract__.tutorial.signature_sequence.overloaded_functions">Overloaded
        Functions</a>
      </h6>
<p>
        The library supports contracts for overloaded functions.
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src=".././doc/html/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top">
<p>
          However, the library uses the argument <span class="bold"><strong>names</strong></span>
          to distinguish the overloaded function signatures whereas C++ uses the
          argument types (this is because, in general, the argument types, for example
          <code class="computeroutput"><span class="keyword">const</span> <span class="keyword">int</span><span class="special">&amp;</span></code>, are not valid preprocessor tokens).
        </p>
<p>
          If two functions share the same name, the same number of arguments, and
          the same <code class="computeroutput"><span class="keyword">const</span></code> qualifier then
          their argument names (and not just their types) must be different to allow
          the library to distinguish these two functions from each other. (This is
          usually not a significant limitation because different argument names can
          be given.)
        </p>
</td></tr>
</table></div>
<p>
        For example:
      </p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">number</span> <span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="comment">// Overloaded functions distinguished using argument names (not types) and const.
</span>    
    <span class="identifier">number</span> <span class="identifier">add</span><span class="special">(</span><span class="keyword">const</span> <span class="keyword">int</span><span class="special">&amp;</span> <span class="identifier">n</span><span class="special">)</span> <span class="comment">// (1)
</span>    <span class="identifier">CONTRACT_FUNCTION</span><span class="special">(...)</span>

    <span class="comment">// OK -- different from (1) because this is `const`.
</span>    <span class="identifier">number</span><span class="special">&amp;</span> <span class="identifier">add</span><span class="special">(</span><span class="keyword">const</span> <span class="keyword">int</span><span class="special">&amp;</span> <span class="identifier">n</span><span class="special">)</span> <span class="keyword">const</span>
    <span class="identifier">CONTRACT_FUNCTION</span><span class="special">(...)</span>

    <span class="comment">// OK -- different from (1) because argument named "d" instead of "n".
</span>    <span class="identifier">number</span> <span class="identifier">add</span><span class="special">(</span><span class="keyword">const</span> <span class="keyword">double</span><span class="special">&amp;</span> <span class="identifier">d</span><span class="special">)</span>
    <span class="identifier">CONTRACT_FUNCTION</span><span class="special">(...)</span>
    
    <span class="comment">// Error -- same as (1) because both non-const and with argument named "n" (even if different argument type).
</span>    <span class="identifier">number</span> <span class="identifier">add</span><span class="special">(</span><span class="keyword">const</span> <span class="keyword">double</span><span class="special">&amp;</span> <span class="identifier">n</span><span class="special">)</span>
    <span class="identifier">CONTRACT_FUNCTION</span><span class="special">(...)</span> <span class="comment">// Same as (1), error!
</span>    
    <span class="special">...</span>
<span class="special">};</span>
</pre>
<a name="contract__.tutorial.signature_sequence.function_templates"></a><h6>
<a name="id2615765"></a>
        <a class="link" href="tutorial.html#contract__.tutorial.signature_sequence.function_templates">Function
        Templates</a>
      </h6>
<p>
        The <code class="computeroutput"><span class="special">(</span><span class="keyword">template</span><span class="special">)</span></code> token is used in <span class="emphasis"><em>signature-sequence</em></span>
        to specify a function template listing the relative template parameters.
        The template parameters are specified using a syntax similar to the one of
        the function arguments.
      </p>
<p>
        For example:
      </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">myvector</span> <span class="special">{</span>
    <span class="special">...</span> <span class="comment">// Class invariants.
</span>    
<span class="keyword">private</span><span class="special">:</span>
    <span class="bold"><strong>template&lt;class Iter&gt;</strong></span>
    <span class="keyword">static</span> <span class="keyword">bool</span> <span class="identifier">all_equals</span><span class="special">(</span><span class="identifier">Iter</span> <span class="identifier">first</span><span class="special">,</span> <span class="identifier">Iter</span> <span class="identifier">last</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">element</span><span class="special">)</span>
    <span class="identifier">CONTRACT_FUNCTION</span><span class="special">(</span> <span class="special">(</span><span class="keyword">class</span><span class="special">)</span> <span class="special">(</span><span class="identifier">myvector</span><span class="special">)</span>
            <span class="special">(</span><span class="keyword">private</span><span class="special">)</span> <span class="bold"><strong>(template)( (class)(Iter) )</strong></span>
            <span class="special">(</span><span class="keyword">static</span><span class="special">)</span> <span class="special">(</span><span class="keyword">bool</span><span class="special">)</span> <span class="special">(</span><span class="identifier">all_equals</span><span class="special">)(</span>
                    <span class="special">(</span><span class="identifier">Iter</span><span class="special">)(</span><span class="identifier">first</span><span class="special">)</span> <span class="special">(</span><span class="identifier">Iter</span><span class="special">)(</span><span class="identifier">last</span><span class="special">)</span> <span class="special">(</span><span class="keyword">const</span> <span class="identifier">T</span><span class="special">&amp;)(</span><span class="identifier">element</span><span class="special">)</span> <span class="special">)</span>
    <span class="special">(</span><span class="identifier">precondition</span><span class="special">)</span> <span class="special">({</span>
        <span class="identifier">CONTRACT_ASSERT</span><span class="special">(</span> <span class="identifier">first</span> <span class="special">&lt;</span> <span class="identifier">last</span> <span class="special">);</span>
    <span class="special">})</span>
    <span class="special">(</span><span class="identifier">body</span><span class="special">)</span> <span class="special">({</span>
        <span class="keyword">for</span> <span class="special">(</span><span class="identifier">Iter</span> <span class="identifier">i</span> <span class="special">=</span> <span class="identifier">first</span><span class="special">;</span> <span class="identifier">i</span> <span class="special">&lt;</span> <span class="identifier">last</span><span class="special">;</span> <span class="special">++</span><span class="identifier">i</span><span class="special">)</span> <span class="special">{</span>
            <span class="keyword">if</span> <span class="special">(*</span><span class="identifier">i</span> <span class="special">!=</span> <span class="identifier">element</span><span class="special">)</span> <span class="keyword">return</span> <span class="keyword">false</span><span class="special">;</span>
        <span class="special">}</span>
        <span class="keyword">return</span> <span class="keyword">true</span><span class="special">;</span>
    <span class="special">})</span> <span class="special">)</span>
    
    <span class="special">...</span> <span class="comment">// Rest of the class.
</span><span class="special">};</span>
</pre>
<p>
        In this example, the function also happens to be a static member but any
        function (non-member, member, static member, constructor, etc) can be be
        declared a template function as usual in C++.
      </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="contract__.tutorial.deferring_the_body"></a><a class="link" href="tutorial.html#contract__.tutorial.deferring_the_body" title="Deferring the Body">Deferring the
      Body</a>
</h3></div></div></div>
<p>
        Class invariants, preconditions, and postconditions are part of the function
        specifications (indeed they <span class="emphasis"><em>assert</em></span> the function specifications).
        Therefore, this library requires contracts to be defined together with the
        function declarations. However, the function body (i.e., the function implementation)
        can be defined either together with the function declaration or separately.
      </p>
<p>
        In other words, the usual C++ feature that allows to separate a function
        definition from its declaration is retained by this library.
      </p>
<a name="contract__.tutorial.deferring_the_body.separating_declaration_and_definition"></a><h6>
<a name="id2616458"></a>
        <a class="link" href="tutorial.html#contract__.tutorial.deferring_the_body.separating_declaration_and_definition">Separating
        Declaration and Definition</a>
      </h6>
<p>
        When the function body is defined separately from the function declaration:
      </p>
<div class="itemizedlist"><ul type="disc">
<li>
          The <code class="computeroutput"><span class="special">(</span><span class="identifier">body</span><span class="special">)(;)</span></code> tokens are used to define the body
          in the macro parameter passed to <code class="computeroutput"><a href="../CONTRACT_FUNCTION.html" target="_top">CONTRACT_FUNCTION</a><span class="special">()</span></code>. The <code class="computeroutput"><span class="string">";"</span></code>
          symbol is the usual C++ symbol used to separate the function definition
          from its declaration.
        </li>
<li>
          The <code class="computeroutput"><a href="../CONTRACT_BODY.html" target="_top">CONTRACT_BODY</a><span class="special">(</span></code><span class="emphasis"><em>function-name</em></span><code class="computeroutput"><span class="special">)</span></code> macro is used to name the function where
          it is defined. Again, for operators <span class="emphasis"><em>function-name</em></span>
          must be specified as <code class="computeroutput"><span class="keyword">operator</span><span class="special">(</span></code><span class="emphasis"><em>symbol</em></span><code class="computeroutput"><span class="special">,</span> </code><span class="emphasis"><em>name</em></span><code class="computeroutput"><span class="special">)</span></code>.
        </li>
<li>
          Similarly, it is possible to separate constructor and destructor body definitions.
          In this case, the macros <code class="computeroutput"><a href="../CONTRACT_CONSTRUCTOR_BODY.html" target="_top">CONTRACT_CONSTRUCTOR_BODY</a><span class="special">(</span></code><span class="emphasis"><em>class-type</em></span><code class="computeroutput"><span class="special">,</span> </code><span class="emphasis"><em>class-name</em></span><code class="computeroutput"><span class="special">)</span></code> and <code class="computeroutput"><a href="../CONTRACT_DESTRUCTOR_BODY.html" target="_top">CONTRACT_DESTRUCTOR_BODY</a><span class="special">(</span></code><span class="emphasis"><em>class-type</em></span><code class="computeroutput"><span class="special">,</span> </code><span class="emphasis"><em>class-name</em></span><code class="computeroutput"><span class="special">)</span></code> should be used when the constructor and
          destructor are defined respectively (note again that <code class="computeroutput"><span class="string">"~"</span></code>
          is <span class="emphasis"><em>not</em></span> specified to name destructors, just use the
          class name instead).
        </li>
</ul></div>
<p>
        For example:
      </p>
<pre class="programlisting"><span class="comment">// Declarations (usually in header files).
</span>
<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">myvector</span><span class="special">:</span>
        <span class="keyword">public</span> <span class="identifier">boundable</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">const_iterator</span><span class="special">&gt;,</span>
        <span class="keyword">private</span> <span class="identifier">basic_begin</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">const_iterator</span><span class="special">&gt;</span> <span class="special">{</span>
    <span class="special">...</span> <span class="comment">// Class invariants.
</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">size_type</span> <span class="identifier">size_type</span><span class="special">;</span>
    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">const_reference</span> <span class="identifier">const_reference</span><span class="special">;</span>
    <span class="keyword">typedef</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">const_iterator</span> <span class="identifier">const_iterator</span><span class="special">;</span>

    <span class="identifier">myvector</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">myvector</span><span class="special">&amp;</span> <span class="identifier">right</span><span class="special">)</span>
    <span class="identifier">CONTRACT_CONSTRUCTOR</span><span class="special">(</span> <span class="special">(</span><span class="keyword">class</span><span class="special">)</span> <span class="special">(</span><span class="identifier">myvector</span><span class="special">)</span>
            <span class="special">(</span><span class="keyword">public</span><span class="special">)</span> <span class="special">(</span><span class="identifier">myvector</span><span class="special">)(</span> <span class="special">(</span><span class="keyword">const</span> <span class="identifier">myvector</span><span class="special">&amp;)(</span><span class="identifier">right</span><span class="special">)</span> <span class="special">)</span>
    <span class="special">(</span><span class="identifier">postcondition</span><span class="special">)</span> <span class="special">({</span>
        <span class="identifier">CONTRACT_ASSERT</span><span class="special">(</span> <span class="identifier">vector_</span> <span class="special">==</span> <span class="identifier">right</span><span class="special">.</span><span class="identifier">vector_</span> <span class="special">);</span>
    <span class="special">})</span>
    <span class="special">(</span><span class="identifier">body</span><span class="special">)</span> <span class="bold"><strong>(;)</strong></span> <span class="special">)</span> <span class="comment">// Deferres body definition.
</span>
    <span class="keyword">virtual</span> <span class="special">~</span><span class="identifier">myvector</span><span class="special">(</span><span class="keyword">void</span><span class="special">)</span>
    <span class="identifier">CONTRACT_DESTRUCTOR</span><span class="special">(</span>
            <span class="special">(</span><span class="keyword">class</span><span class="special">)</span> <span class="special">(</span><span class="identifier">myvector</span><span class="special">)</span>
            <span class="special">(</span><span class="keyword">public</span><span class="special">)</span> <span class="special">(</span><span class="keyword">virtual</span><span class="special">)</span> <span class="special">(</span><span class="identifier">myvector</span><span class="special">)(</span> <span class="special">(</span><span class="keyword">void</span><span class="special">)</span> <span class="special">)</span>
    <span class="special">(</span><span class="identifier">body</span><span class="special">)</span> <span class="bold"><strong>(;)</strong></span> <span class="special">)</span>
    
    <span class="identifier">const_iterator</span> <span class="identifier">begin</span><span class="special">(</span><span class="keyword">void</span><span class="special">)</span> <span class="keyword">const</span>
    <span class="identifier">CONTRACT_FUNCTION</span><span class="special">(</span> <span class="special">(</span><span class="keyword">class</span><span class="special">)</span> <span class="special">(</span><span class="identifier">myvector</span><span class="special">)</span>
            <span class="special">(</span><span class="identifier">inherit</span><span class="special">)(</span><span class="identifier">boundable</span><span class="special">&lt;</span><span class="identifier">const_iterator</span><span class="special">&gt;)</span>
            <span class="special">(</span><span class="identifier">inherit</span><span class="special">)(</span><span class="identifier">basic_begin</span><span class="special">&lt;</span><span class="identifier">const_iterator</span><span class="special">&gt;)</span>
            <span class="special">(</span><span class="keyword">public</span><span class="special">)</span> <span class="special">(</span><span class="identifier">const_iterator</span><span class="special">)</span> <span class="special">(</span><span class="identifier">begin</span><span class="special">)(</span> <span class="special">(</span><span class="keyword">void</span><span class="special">)</span> <span class="special">)</span> <span class="special">(</span><span class="keyword">const</span><span class="special">)</span>
    <span class="special">(</span><span class="identifier">postcondition</span><span class="special">)</span> <span class="special">(</span><span class="identifier">result</span><span class="special">)</span> <span class="special">({</span>
        <span class="keyword">if</span> <span class="special">(</span><span class="identifier">empty</span><span class="special">())</span> <span class="identifier">CONTRACT_ASSERT</span><span class="special">(</span> <span class="identifier">result</span> <span class="special">==</span> <span class="identifier">end</span><span class="special">()</span> <span class="special">);</span>
    <span class="special">})</span>
    <span class="special">(</span><span class="identifier">body</span><span class="special">)</span> <span class="bold"><strong>(;)</strong></span> <span class="special">)</span>

    <span class="identifier">const_reference</span> <span class="keyword">operator</span><span class="special">[](</span><span class="identifier">size_type</span> <span class="identifier">index</span><span class="special">)</span> <span class="keyword">const</span>
    <span class="identifier">CONTRACT_FUNCTION</span><span class="special">(</span> <span class="special">(</span><span class="keyword">class</span><span class="special">)</span> <span class="special">(</span><span class="identifier">myvector</span><span class="special">)</span>
            <span class="special">(</span><span class="keyword">public</span><span class="special">)</span> <span class="special">(</span><span class="identifier">const_reference</span><span class="special">)</span> <span class="special">(</span><span class="keyword">operator</span><span class="special">([],</span> <span class="identifier">at</span><span class="special">))(</span>
                    <span class="special">(</span><span class="identifier">size_type</span><span class="special">)(</span><span class="identifier">index</span><span class="special">)</span> <span class="special">)</span> <span class="special">(</span><span class="keyword">const</span><span class="special">)</span>
    <span class="special">(</span><span class="identifier">precondition</span><span class="special">)</span> <span class="special">({</span>
        <span class="identifier">CONTRACT_ASSERT</span><span class="special">(</span> <span class="identifier">index</span> <span class="special">&lt;</span> <span class="identifier">size</span><span class="special">()</span> <span class="special">);</span>
    <span class="special">})</span>
    <span class="special">(</span><span class="identifier">body</span><span class="special">)</span> <span class="bold"><strong>(;)</strong></span> <span class="special">)</span>

    <span class="special">...</span> <span class="comment">// Rest of the class.
</span><span class="keyword">private</span><span class="special">:</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span> <span class="identifier">vector_</span><span class="special">;</span>        
<span class="special">};</span>

<span class="comment">// Separated definitions (eventually in a different file).
</span>
<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="bold"><strong>CONTRACT_CONSTRUCTOR_BODY(myvector&lt;T&gt;, myvector)</strong></span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">myvector</span><span class="special">&amp;</span> <span class="identifier">right</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">vector_</span> <span class="special">=</span> <span class="identifier">right</span><span class="special">.</span><span class="identifier">vector_</span><span class="special">;</span>
<span class="special">}</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="bold"><strong>CONTRACT_DESTRUCTOR_BODY(myvector&lt;T&gt;, myvector)</strong></span><span class="special">(</span><span class="keyword">void</span><span class="special">)</span> <span class="special">{</span>
    <span class="comment">// Do nothing in this case.
</span><span class="special">}</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">typename</span> <span class="identifier">myvector</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">iterator</span> <span class="identifier">myvector</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="bold"><strong>CONTRACT_BODY(begin)</strong></span><span class="special">(</span><span class="keyword">void</span><span class="special">)</span> <span class="special">{</span>
    <span class="keyword">return</span> <span class="identifier">vector_</span><span class="special">.</span><span class="identifier">begin</span><span class="special">();</span>
<span class="special">}</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">typename</span> <span class="identifier">myvector</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">const_reference</span> <span class="identifier">myvector</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span>
        <span class="bold"><strong>CONTRACT_BODY(operator([]</strong></span><span class="bold"><strong>, at))</strong></span><span class="special">(</span><span class="identifier">size_type</span> <span class="identifier">index</span><span class="special">)</span> <span class="keyword">const</span> <span class="special">{</span>
    <span class="keyword">return</span> <span class="identifier">vector_</span><span class="special">[</span><span class="identifier">index</span><span class="special">];</span>
<span class="special">}</span>
</pre>
<p>
        In addition to the usual benefits of separating function definitions from
        their declarations (smaller and more readable header files, less recompilation
        needed, etc), this separation also improves the library compile-time error
        messages. When a function is defined together with its declaration, the function
        implementation code is passed as one single macro parameter <code class="computeroutput"><span class="special">(</span><span class="identifier">body</span><span class="special">)({</span>
        <span class="special">...</span> <span class="special">})</span></code>
        to the contract macros. Macro preprocessing removes all newline characters
        from within the macro parameters so the implementation code is compiled as
        if it were written on a single line. As a result, any compile-time error
        within the function body code will be reported having the same line number
        and it will be harder to track. Instead, if the body definition is separated
        from the function declaration, the definition code is not wrapped within
        a macro parameter and the compiler errors will indicate useful line numbers.
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src=".././doc/html/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
          It is recommended to separate the body definition from the function declaration
          so that line numbers in compiler errors retain their usual values.
        </p></td></tr>
</table></div>
<p>
        Finally, note how the <span class="emphasis"><em>signature-sequence</em></span> unusual syntax
        does <span class="emphasis"><em>not</em></span> propagate to the function definitions (only
        the function name is changed in the function definitions). Therefore, when
        definitions are separated from declarations, the files containing the definitions
        (usually the ".cpp" files) will not contain the unusual <span class="emphasis"><em>signature-sequence</em></span>
        syntax and they will be easier to read.
      </p>
<div class="warning"><table border="0" summary="Warning">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src=".././doc/html/images/warning.png"></td>
<th align="left">Warning</th>
</tr>
<tr><td align="left" valign="top">
<p>
          <span class="bold"><strong>Constructor Member Initialization List</strong></span>
        </p>
<p>
          Because of a library limitation, it is not possible to separate a constructor
          definition from its declaration when the constructor uses a member initialization
          list (see <code class="computeroutput"><a href="../CONTRACT_CONSTRUCTOR_BODY.html" target="_top">CONTRACT_CONSTRUCTOR_BODY</a><span class="special">()</span></code> macro for details and workarounds)
          <sup>[<a name="id2618694" href="#ftn.id2618694" class="footnote">12</a>]</sup>
          .
        </p>
</td></tr>
</table></div>
<a name="contract__.tutorial.deferring_the_body.pure_virtual_functions"></a><h6>
<a name="id2618726"></a>
        <a class="link" href="tutorial.html#contract__.tutorial.deferring_the_body.pure_virtual_functions">Pure
        Virtual Functions</a>
      </h6>
<p>
        The library also supports contracts for pure virtual functions.
      </p>
<p>
        In this case, the <code class="computeroutput"><span class="special">(</span><span class="identifier">body</span><span class="special">)(=</span> <span class="number">0</span><span class="special">;)</span></code>
        tokens are used to define the body in the macro parameter passed to <code class="computeroutput"><a href="../CONTRACT_FUNCTION.html" target="_top">CONTRACT_FUNCTION</a><span class="special">()</span></code>.
        The <code class="computeroutput"><span class="string">"= 0;"</span></code> symbol is
        the usual C++ symbol used to specify pure virtual functions.
      </p>
<p>
        For example:
      </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">pushable</span> <span class="special">{</span>
    <span class="special">...</span>

<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="identifier">push_back</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">element</span><span class="special">)</span>
    <span class="identifier">CONTRACT_FUNCTION</span><span class="special">(</span>
            <span class="special">(</span><span class="keyword">class</span><span class="special">)</span> <span class="special">(</span><span class="identifier">pushable</span><span class="special">)</span>
            <span class="special">(</span><span class="keyword">public</span><span class="special">)</span> <span class="special">(</span><span class="keyword">virtual</span><span class="special">)</span> <span class="special">(</span><span class="keyword">void</span><span class="special">)</span> <span class="special">(</span><span class="identifier">push_back</span><span class="special">)(</span> <span class="special">(</span><span class="keyword">const</span> <span class="identifier">T</span><span class="special">&amp;)(</span><span class="identifier">element</span><span class="special">)</span> <span class="special">)</span>
    <span class="special">(</span><span class="identifier">postcondition</span><span class="special">)</span> <span class="special">({</span>
        <span class="identifier">CONTRACT_ASSERT</span><span class="special">(</span> <span class="identifier">back</span><span class="special">()</span> <span class="special">==</span> <span class="identifier">element</span> <span class="special">);</span>
    <span class="special">})</span>
    <span class="special">(</span><span class="identifier">body</span><span class="special">)</span> <span class="special">(=</span> <span class="number">0</span><span class="special">;)</span> <span class="special">)</span> <span class="comment">// Pure virtual body.
</span><span class="special">};</span>
</pre>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="contract__.tutorial.blocks_and_loops"></a><a class="link" href="tutorial.html#contract__.tutorial.blocks_and_loops" title="Blocks and Loops">Blocks and Loops</a>
</h3></div></div></div>
<p>
        Block invariants <code class="computeroutput"><a href="../CONTRACT_ASSERT_BLOCK_INVARIANT.html" target="_top">CONTRACT_ASSERT_BLOCK_INVARIANT</a><span class="special">()</span></code> can be used to assert conditions anywhere
        within a code block (not just loops). When used within a loop, block invariants
        can be used to assert loop invariants.
      </p>
<p>
        Loop variants can be used to check the correctness of a loop, including its
        termination, as explained in detail in <a class="link" href="bibliography.html" title="Bibliography">[Meyer1997]</a>
        (and they can only appear within loops). At each loop iteration, the specified
        loop variant integer expression is automatically asserted to be positive
        (&gt; 0) and to decrease from the previous loop iteration. Loop variants
        can be used to assert loop correctness. Because the variant decreases and
        it cannot be zero or smaller than zero it is possible to guarantee loop termination.
        A loop can only have one variant.
      </p>
<p>
        When asserting loop variants using <code class="computeroutput"><a href="../CONTRACT_ASSERT_LOOP_VARIANT.html" target="_top">CONTRACT_ASSERT_LOOP_VARIANT</a><span class="special">()</span></code> it is necessary to first call <code class="computeroutput"><a href="../CONTRACT_INIT_LOOP_VARIANT.html" target="_top">CONTRACT_INIT_LOOP_VARIANT</a></code>
        once (and only once) within a code block that has same of higher scope level
        than the loop code block.
      </p>
<p>
        For example:
      </p>
<pre class="programlisting"><span class="keyword">double</span> <span class="identifier">abs_total</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">myvector</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;&amp;</span> <span class="identifier">vector</span><span class="special">)</span>
<span class="identifier">CONTRACT_FUNCTION</span><span class="special">(</span>
        <span class="special">(</span><span class="keyword">double</span><span class="special">)</span> <span class="special">(</span><span class="identifier">abs_total</span><span class="special">)(</span> <span class="special">(</span><span class="keyword">const</span> <span class="identifier">myvector</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;&amp;)(</span><span class="identifier">vector</span><span class="special">)</span> <span class="special">)</span>
<span class="special">(</span><span class="identifier">postcondition</span><span class="special">)</span> <span class="special">(</span><span class="identifier">total</span><span class="special">)</span> <span class="special">({</span> <span class="comment">// Result value named `total`.
</span>    <span class="identifier">CONTRACT_ASSERT</span><span class="special">(</span> <span class="identifier">total</span> <span class="special">&gt;=</span> <span class="number">0.0</span> <span class="special">);</span>
<span class="special">})</span>
<span class="special">(</span><span class="identifier">body</span><span class="special">)</span> <span class="special">({</span>
    <span class="keyword">double</span> <span class="identifier">total</span> <span class="special">=</span> <span class="number">0.0</span><span class="special">;</span>
    <span class="comment">// Block invariants can appear anywhere in code block.
</span>    <span class="bold"><strong>CONTRACT_ASSERT_BLOCK_INVARIANT( total == 0.0 );</strong></span>

    <span class="special">{</span> <span class="comment">// Variant initialized locally to its loop.
</span>        <span class="bold"><strong>CONTRACT_INIT_LOOP_VARIANT;</strong></span>
        <span class="keyword">for</span> <span class="special">(</span><span class="identifier">size_t</span> <span class="identifier">i</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span> <span class="identifier">i</span> <span class="special">&lt;</span> <span class="identifier">vector</span><span class="special">.</span><span class="identifier">size</span><span class="special">();</span> <span class="special">++</span><span class="identifier">i</span><span class="special">)</span> <span class="special">{</span>
            <span class="comment">// Block invariants used to assert loop invariants.
</span>            <span class="bold"><strong>CONTRACT_ASSERT_BLOCK_INVARIANT( i &lt; vector.size() );</strong></span>
            <span class="comment">// Loop variant (can only appear in loops).
</span>            <span class="bold"><strong>CONTRACT_ASSERT_LOOP_VARIANT( vector.size() - i );</strong></span>

            <span class="identifier">total</span> <span class="special">+=</span> <span class="identifier">vector</span><span class="special">[</span><span class="identifier">i</span><span class="special">];</span>
        <span class="special">}</span>
    <span class="special">}</span>
    <span class="keyword">return</span> <span class="identifier">total</span> <span class="special">&lt;</span> <span class="number">0.0</span> <span class="special">?</span> <span class="special">-</span><span class="identifier">total</span> <span class="special">:</span> <span class="identifier">total</span><span class="special">;</span>
<span class="special">})</span> <span class="special">)</span>
</pre>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="contract__.tutorial.commas_within_macro_parameters"></a><a class="link" href="tutorial.html#contract__.tutorial.commas_within_macro_parameters" title="Commas Within Macro Parameters">Commas
      Within Macro Parameters</a>
</h3></div></div></div>
<p>
        The C++ preprocessor only recognizes the <code class="computeroutput"><span class="special">()</span></code>
        parenthesis. It does not recognize any other parenthesis such as <code class="computeroutput"><span class="special">&lt;&gt;</span></code>, <code class="computeroutput"><span class="special">[]</span></code>,
        or <code class="computeroutput"><span class="special">{}</span></code>. As a consequence, any
        comma passed within a macro parameter that is not wrapped by the <code class="computeroutput"><span class="special">()</span></code> parenthesis will be interpreted by the
        preprocessor as a parameter separation token and will generate a preprocessing
        error. Also macro parameters passed as elements of <a href="http://www.boost.org/libs/preprocessor/doc/index.html" target="_top">Boost.Preprocessor</a>
        sequences cannot contain commas not wrapped by extra <code class="computeroutput"><span class="special">()</span></code>
        parenthesis (the preprocessor sequence <code class="computeroutput"><span class="special">()</span></code>
        parenthesis are not sufficient to wrap the commas).
      </p>
<p>
        Consider the following example:
      </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">K</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">map</span><span class="special">&lt;</span><span class="identifier">K</span><span class="special">,</span> <span class="identifier">T</span><span class="special">&gt;</span> <span class="identifier">fill</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">map</span><span class="special">&lt;</span><span class="identifier">K</span><span class="special">,</span> <span class="identifier">T</span><span class="special">&gt;&amp;</span> <span class="identifier">source</span><span class="special">,</span>
        <span class="keyword">const</span> <span class="identifier">K</span><span class="special">&amp;</span> <span class="identifier">key</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">element</span><span class="special">)</span>
<span class="identifier">CONTRACT_FUNCTION</span><span class="special">(</span>
        <span class="special">(</span><span class="keyword">template</span><span class="special">)(</span> <span class="special">(</span><span class="keyword">typename</span><span class="special">)(</span><span class="identifier">K</span><span class="special">)</span> <span class="special">(</span><span class="keyword">typename</span><span class="special">)(</span><span class="identifier">T</span><span class="special">)</span> <span class="special">)</span>
        <span class="comment">// Commas within another type expression.
</span>        <span class="bold"><strong>(std::map&lt;K, T&gt;)</strong></span> <span class="special">(</span><span class="identifier">set</span><span class="special">)(</span> 
                <span class="comment">// Commas within a type expression.
</span>                <span class="bold"><strong>(const std::map&lt;K, T&gt;&amp;)</strong></span><span class="special">(</span><span class="identifier">source</span><span class="special">)</span>
                <span class="special">(</span><span class="keyword">const</span> <span class="identifier">K</span><span class="special">&amp;)(</span><span class="identifier">key</span><span class="special">)</span> <span class="special">(</span><span class="keyword">const</span> <span class="identifier">T</span><span class="special">&amp;)(</span><span class="identifier">element</span><span class="special">)</span> <span class="special">)</span>
<span class="special">(</span><span class="identifier">precondition</span><span class="special">)</span> <span class="special">({</span>
    <span class="comment">// Commas within a value expression.
</span>    <span class="identifier">CONTRACT_ASSERT</span><span class="special">(</span> <span class="bold"><strong>std::map&lt;K, T&gt;().empty()</strong></span> <span class="special">);</span>
<span class="special">})</span>
<span class="special">(</span><span class="identifier">body</span><span class="special">)</span> <span class="special">({</span>
    <span class="special">...</span>
<span class="special">})</span> <span class="special">)</span>
</pre>
<a name="contract__.tutorial.commas_within_macro_parameters.value_expressions"></a><h6>
<a name="id2620396"></a>
        <a class="link" href="tutorial.html#contract__.tutorial.commas_within_macro_parameters.value_expressions">Value
        Expressions</a>
      </h6>
<p>
        The example above will <span class="emphasis"><em>not</em></span> compile because the preprocessor
        will interpret the expression:
      </p>
<pre class="programlisting"><span class="identifier">CONTRACT_ASSERT</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">map</span><span class="special">&lt;</span><span class="identifier">K</span><span class="special">,</span> <span class="identifier">T</span><span class="special">&gt;().</span><span class="identifier">empty</span><span class="special">()</span> <span class="special">);</span>
</pre>
<p>
        as a call to the macro <code class="computeroutput"><a href="../CONTRACT_ASSERT.html" target="_top">CONTRACT_ASSERT</a><span class="special">()</span></code> passing <span class="emphasis"><em>two</em></span> parameters
        separated by the comma:
      </p>
<pre class="programlisting"><span class="identifier">std</span><span class="special">::</span><span class="identifier">map</span><span class="special">&lt;</span><span class="identifier">K</span>    <span class="comment">// 1st macro parameter.
</span><span class="identifier">T</span><span class="special">&gt;().</span><span class="identifier">empty</span><span class="special">()</span>  <span class="comment">// 2nd macro parameter.
</span></pre>
<p>
        Because <code class="computeroutput"><a href="../CONTRACT_ASSERT.html" target="_top">CONTRACT_ASSERT</a><span class="special">()</span></code> takes only one parameter, the above code
        will generate a preprocessing error.
      </p>
<p>
        The expressions <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">map</span><span class="special">&lt;</span><span class="identifier">K</span><span class="special">,</span> <span class="identifier">T</span><span class="special">&gt;().</span><span class="identifier">empty</span><span class="special">()</span></code> is interpreted by the compiler as a value
        expression (it will be either be <code class="computeroutput"><span class="keyword">true</span></code>
        or <code class="computeroutput"><span class="keyword">false</span></code>). Value expressions
        can be wrapped by an extra set of parenthesis <code class="computeroutput"><span class="special">()</span></code>
        when passed as macro parameters. The following will compile:
      </p>
<pre class="programlisting"><span class="identifier">CONTRACT_ASSERT</span><span class="special">(</span> <span class="bold"><strong>(</strong></span><span class="identifier">std</span><span class="special">::</span><span class="identifier">map</span><span class="special">&lt;</span><span class="identifier">K</span><span class="special">,</span> <span class="identifier">T</span><span class="special">&gt;().</span><span class="identifier">empty</span><span class="special">()</span><span class="bold"><strong>)</strong></span> <span class="special">);</span>
</pre>
<a name="contract__.tutorial.commas_within_macro_parameters.type_expressions"></a><h6>
<a name="id2620770"></a>
        <a class="link" href="tutorial.html#contract__.tutorial.commas_within_macro_parameters.type_expressions">Type
        Expressions</a>
      </h6>
<p>
        A similar issue arises for the preprocessor sequence element:
      </p>
<pre class="programlisting"><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">map</span><span class="special">&lt;</span><span class="identifier">K</span><span class="special">,</span> <span class="identifier">T</span><span class="special">&gt;)</span>
</pre>
<p>
        which will be interpreted as composed of 2 parameters separated by the comma
        (i.e., as a <a href="http://www.boost.org/libs/preprocessor/doc/index.html" target="_top">Boost.Preprocessor</a>
        2-tuple instead than an element of a <a href="http://www.boost.org/libs/preprocessor/doc/index.html" target="_top">Boost.Preprocessor</a>
        sequence):
      </p>
<pre class="programlisting"><span class="identifier">std</span><span class="special">::</span><span class="identifier">map</span><span class="special">&lt;</span><span class="identifier">T</span>  <span class="comment">// 1st macro parameter.
</span><span class="identifier">T</span><span class="special">&gt;</span>          <span class="comment">// 2nd macro parameter.
</span></pre>
<p>
        However, in this case the expression <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">map</span><span class="special">&lt;</span><span class="identifier">K</span><span class="special">,</span> <span class="identifier">T</span><span class="special">&gt;</span></code> needs to be interpreted by the compiler
        as a type expression (indeed the type <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">map</span><span class="special">&lt;</span><span class="identifier">K</span><span class="special">,</span> <span class="identifier">T</span><span class="special">&gt;</span></code>) and it cannot be wrapped by the extra
        parenthesis <code class="computeroutput"><span class="special">()</span></code>. In fact, depending
        on the context where they are used, types wrapped within parenthesis can
        generate compiler-time syntactic errors.
      </p>
<p>
        In order to wrap the type expression within parenthesis <code class="computeroutput"><span class="special">()</span></code>
        that can be parsed correctly by the preprocessor and interpreted correctly
        the compiler, first we created a void-function type that contains the type
        expression as the function only argument type:
      </p>
<pre class="programlisting"><span class="keyword">void</span><span class="bold"><strong>(</strong></span><span class="identifier">std</span><span class="special">::</span><span class="identifier">map</span><span class="special">&lt;</span><span class="identifier">K</span><span class="special">,</span> <span class="identifier">T</span><span class="special">&gt;</span><span class="bold"><strong>)</strong></span>  <span class="comment">// Function type (wraps comma within parenthesis).
</span></pre>
<p>
        Then, we apply the library metafunction <code class="computeroutput"><span class="identifier">contract</span><span class="special">::</span><a href="../contract/wrap.html" target="_top">wrap</a></code>
        that returns the type of the first argument of the specified void-function
        type:
      </p>
<pre class="programlisting"><span class="identifier">contract</span><span class="special">::</span><span class="identifier">wrap</span><span class="special">&lt;</span><span class="keyword">void</span><span class="bold"><strong>(</strong></span><span class="identifier">std</span><span class="special">::</span><span class="identifier">map</span><span class="special">&lt;</span><span class="identifier">K</span><span class="special">,</span> <span class="identifier">T</span><span class="special">&gt;</span><span class="bold"><strong>)</strong></span><span class="special">&gt;::</span><span class="identifier">type</span>  <span class="comment">// Evaluates to the type `std::map&lt;K, T&gt;`.
</span></pre>
<p>
        For convenience, the library provides the macro <code class="computeroutput"><a href="../CONTRACT_WRAP_TYPE.html" target="_top">CONTRACT_WRAP_TYPE</a><span class="special">()</span></code> which expands to the code above:
      </p>
<pre class="programlisting"><span class="identifier">CONTRACT_WRAP_TYPE</span><span class="special">(</span> <span class="bold"><strong>(</strong></span><span class="identifier">std</span><span class="special">::</span><span class="identifier">macp</span><span class="special">&lt;</span><span class="identifier">K</span><span class="special">,</span> <span class="identifier">T</span><span class="special">&gt;</span><span class="bold"><strong>)</strong></span> <span class="special">)</span>
</pre>
<p>
        Note the extra parenthesis <code class="computeroutput"><span class="special">()</span></code>
        similar to what it was used for value expression.
      </p>
<a name="contract__.tutorial.commas_within_macro_parameters.body_code_block"></a><h6>
<a name="id2621322"></a>
        <a class="link" href="tutorial.html#contract__.tutorial.commas_within_macro_parameters.body_code_block">Body
        Code Block</a>
      </h6>
<p>
        Finally, both techniques are applied to eventual commas within code blocks
        depending if the code is a value or type expression.
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src=".././doc/html/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
          However, if the body definition is separated from the contract declaration
          then the body code does not appear within a macro parameter so there is
          no need to implement these workarounds in the body code.
        </p></td></tr>
</table></div>
<p>
        Applying these techniques to the example above, we obtain the following code
        which compiles:
      </p>
<p>
        </p>
<p>
          
</p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">K</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">map</span><span class="special">&lt;</span><span class="identifier">K</span><span class="special">,</span> <span class="identifier">T</span><span class="special">&gt;</span> <span class="identifier">fill</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">map</span><span class="special">&lt;</span><span class="identifier">K</span><span class="special">,</span> <span class="identifier">T</span><span class="special">&gt;&amp;</span> <span class="identifier">source</span><span class="special">,</span>
        <span class="keyword">const</span> <span class="identifier">K</span><span class="special">&amp;</span> <span class="identifier">key</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">element</span><span class="special">)</span>
<span class="identifier">CONTRACT_FUNCTION</span><span class="special">(</span>
        <span class="special">(</span><span class="keyword">template</span><span class="special">)(</span> <span class="special">(</span><span class="keyword">typename</span><span class="special">)(</span><span class="identifier">K</span><span class="special">)</span> <span class="special">(</span><span class="keyword">typename</span><span class="special">)(</span><span class="identifier">T</span><span class="special">)</span> <span class="special">)</span>
        <span class="comment">// Commas within type expression using the macro.
</span>        <span class="special">(</span><span class="keyword">typename</span> <span class="identifier">CONTRACT_WRAP_TYPE</span><span class="special">(</span> <span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">map</span><span class="special">&lt;</span><span class="identifier">K</span><span class="special">,</span> <span class="identifier">T</span><span class="special">&gt;)</span> <span class="special">))</span> <span class="special">(</span><span class="identifier">set</span><span class="special">)(</span> 
                <span class="comment">// Or equivalently, not using the macro.
</span>                <span class="special">(</span><span class="keyword">typename</span> <span class="identifier">contract</span><span class="special">::</span><span class="identifier">wrap</span><span class="special">&lt;</span><span class="keyword">void</span> 
                        <span class="special">(</span><span class="keyword">const</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">map</span><span class="special">&lt;</span><span class="identifier">K</span><span class="special">,</span> <span class="identifier">T</span><span class="special">&gt;&amp;)</span> <span class="special">&gt;::</span><span class="identifier">type</span><span class="special">)(</span><span class="identifier">source</span><span class="special">)</span>
                <span class="special">(</span><span class="keyword">const</span> <span class="identifier">K</span><span class="special">&amp;)(</span><span class="identifier">key</span><span class="special">)</span> <span class="special">(</span><span class="keyword">const</span> <span class="identifier">T</span><span class="special">&amp;)(</span><span class="identifier">element</span><span class="special">)</span> <span class="special">)</span>
<span class="special">(</span><span class="identifier">precondition</span><span class="special">)</span> <span class="special">({</span>
    <span class="comment">// Commas within value expressions must be wrapped by `()`.
</span>    <span class="identifier">CONTRACT_ASSERT</span><span class="special">(</span> <span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">map</span><span class="special">&lt;</span><span class="identifier">K</span><span class="special">,</span> <span class="identifier">T</span><span class="special">&gt;().</span><span class="identifier">empty</span><span class="special">())</span> <span class="special">);</span>
<span class="special">})</span>
<span class="special">(</span><span class="identifier">body</span><span class="special">)</span> <span class="special">({</span>
    <span class="comment">// Commas within code blocks use same workarounds as above
</span>    <span class="comment">// wrapping differently commas within type or value expressions. 
</span>    <span class="comment">// Or better, separate body definition so it is outside the macro.
</span>
    <span class="comment">// OK, commas already wrapped by function call `()`.
</span>    <span class="identifier">print</span><span class="special">(</span><span class="identifier">key</span><span class="special">,</span> <span class="identifier">element</span><span class="special">);</span>
    
    <span class="comment">// Commas within type expression wrapped using the macro.
</span>    <span class="keyword">typename</span> <span class="identifier">CONTRACT_WRAP_TYPE</span><span class="special">((</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">map</span><span class="special">&lt;</span><span class="identifier">K</span><span class="special">,</span> <span class="identifier">T</span><span class="special">&gt;))</span> <span class="identifier">m</span> <span class="special">=</span> <span class="identifier">source</span><span class="special">;</span>
    
    <span class="comment">// OK, commas already wrapped by if-statement `()`.
</span>    <span class="keyword">if</span> <span class="special">(</span><span class="number">0</span> <span class="special">==</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">map</span><span class="special">&lt;</span><span class="identifier">K</span><span class="special">,</span> <span class="identifier">T</span><span class="special">&gt;().</span><span class="identifier">empty</span><span class="special">())</span> <span class="identifier">m</span><span class="special">[</span><span class="identifier">key</span><span class="special">]</span> <span class="special">=</span> <span class="identifier">element</span><span class="special">;</span>
    
    <span class="keyword">return</span> <span class="identifier">m</span><span class="special">;</span>
<span class="special">})</span> <span class="special">)</span>

</pre>
<p>
        </p>
<p>
      </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="contract__.tutorial.a_fully_working_example"></a><a class="link" href="tutorial.html#contract__.tutorial.a_fully_working_example" title="A Fully Working Example">A Fully
      Working Example</a>
</h3></div></div></div>
<p>
        We conclude this section with a fully working example that can be compiled.
        This example illustrates how to use the library contract macros to program
        contracts in all the different library usages scenarios (constructor, destructors,
        member functions, non-member functions, template functions, etc).
      </p>
<p>
        For simplicity, this example only exposes a limited subset of the <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span></code>
        operations and it only programs simple contracts for them (see the STL Vector
        <a class="link" href="examples.html" title="Examples">Example</a> for complete contracts
        of all <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span></code> operations). Furthermore, the somewhat
        artificial base classes have been deliberately introduced to illustrate subcontracting
        and they will probably not be part of real code.
      </p>
<p>
        </p>
<p>
          
</p>
<pre class="programlisting"><span class="comment">// Base classes for subcontracting.
</span><span class="preprocessor">#include</span> <span class="string">"pushable.hpp"</span>
<span class="preprocessor">#include</span> <span class="string">"boundable.hpp"</span>
<span class="preprocessor">#include</span> <span class="string">"basic_begin.hpp"</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">contract</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span> <span class="comment">// This library.
</span><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">utility</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span> <span class="comment">// For `boost::prior()`.
</span><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">vector</span><span class="special">&gt;</span> <span class="comment">// STL vector.
</span>    
<span class="comment">// Wrapper that adds simple (not complete) contracts to C++ STL illustrating
</span><span class="comment">// most library usages. For simplicity, assume T is comparable and copyable.
</span><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">myvector</span><span class="special">:</span> <span class="keyword">public</span> <span class="identifier">pushable</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;,</span>
        <span class="keyword">public</span> <span class="identifier">boundable</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">const_iterator</span><span class="special">&gt;,</span>
        <span class="keyword">private</span> <span class="identifier">basic_begin</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">const_iterator</span><span class="special">&gt;</span> <span class="special">{</span>

    <span class="comment">// Class invariants (checked by any function with a contract).
</span>    <span class="identifier">CONTRACT_INVARIANT</span><span class="special">(</span>
    <span class="special">(</span><span class="keyword">static</span><span class="special">)({</span> <span class="comment">// Static invariants (optional).
</span>        <span class="comment">// Static class invariants `(static)({ ... })` are optional and they
</span>        <span class="comment">// could have been omitted since they assert nothing in this example.
</span>        <span class="comment">// When present, they can only access static members.
</span>    <span class="special">})</span> <span class="special">({</span> <span class="comment">// Non-static invariants (can access object).
</span>        <span class="identifier">CONTRACT_ASSERT</span><span class="special">(</span> <span class="special">(</span><span class="identifier">size</span><span class="special">()</span> <span class="special">==</span> <span class="number">0</span><span class="special">)</span> <span class="special">==</span> <span class="identifier">empty</span><span class="special">()</span> <span class="special">);</span>
        <span class="comment">// More invariants here...
</span>    <span class="special">})</span> <span class="special">)</span>

<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">size_type</span> <span class="identifier">size_type</span><span class="special">;</span>
    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">iterator</span> <span class="identifier">iterator</span><span class="special">;</span>
    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">const_iterator</span> <span class="identifier">const_iterator</span><span class="special">;</span>
    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">const_reference</span> <span class="identifier">const_reference</span><span class="special">;</span>

    <span class="comment">// Contract for constructor.
</span>    <span class="keyword">explicit</span> <span class="identifier">myvector</span><span class="special">(</span><span class="identifier">size_type</span> <span class="identifier">count</span><span class="special">):</span> <span class="identifier">vector_</span><span class="special">(</span><span class="identifier">count</span><span class="special">)</span>
    <span class="identifier">CONTRACT_CONSTRUCTOR</span><span class="special">(</span> <span class="comment">// Constructor contract macro.
</span>            <span class="special">(</span><span class="keyword">class</span><span class="special">)</span> <span class="special">(</span><span class="identifier">myvector</span><span class="special">)</span> <span class="comment">// Constructor signature.
</span>            <span class="special">(</span><span class="keyword">public</span><span class="special">)</span> <span class="special">(</span><span class="identifier">myvector</span><span class="special">)(</span> <span class="special">(</span><span class="identifier">size_type</span><span class="special">)(</span><span class="identifier">count</span><span class="special">)</span> <span class="special">)</span>
    <span class="comment">// Never object `this` in constructor preconditions.
</span>    <span class="special">(</span><span class="identifier">postcondition</span><span class="special">)</span> <span class="special">({</span>
        <span class="comment">// Never `CONTRACT_OLDOF(this)` in constructor postconditions.
</span>        <span class="identifier">CONTRACT_ASSERT</span><span class="special">(</span> <span class="identifier">size</span><span class="special">()</span> <span class="special">==</span> <span class="identifier">count</span> <span class="special">);</span>
    <span class="special">})</span>
    <span class="special">(</span><span class="identifier">body</span><span class="special">)</span> <span class="special">({</span>
        <span class="comment">// Do nothing in this case.
</span>    <span class="special">})</span> <span class="special">)</span>

    <span class="comment">// Contractor for overloaded member (resolved by argumnet name).
</span>    <span class="identifier">myvector</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">myvector</span><span class="special">&amp;</span> <span class="identifier">right</span><span class="special">)</span>
    <span class="identifier">CONTRACT_CONSTRUCTOR</span><span class="special">(</span> <span class="special">(</span><span class="keyword">class</span><span class="special">)</span> <span class="special">(</span><span class="identifier">myvector</span><span class="special">)</span>
            <span class="special">(</span><span class="keyword">public</span><span class="special">)</span> <span class="special">(</span><span class="identifier">myvector</span><span class="special">)(</span> <span class="special">(</span><span class="keyword">const</span> <span class="identifier">myvector</span><span class="special">&amp;)(</span><span class="identifier">right</span><span class="special">)</span> <span class="special">)</span>
    <span class="special">(</span><span class="identifier">postcondition</span><span class="special">)</span> <span class="special">({</span>
        <span class="identifier">CONTRACT_ASSERT</span><span class="special">(</span> <span class="identifier">vector_</span> <span class="special">==</span> <span class="identifier">right</span><span class="special">.</span><span class="identifier">vector_</span> <span class="special">);</span>
    <span class="special">})</span>
    <span class="special">(</span><span class="identifier">body</span><span class="special">)</span> <span class="special">(;)</span> <span class="special">)</span> <span class="comment">// Deferres body definition.
</span>
    <span class="comment">// Contract for destructor.
</span>    <span class="keyword">virtual</span> <span class="special">~</span><span class="identifier">myvector</span><span class="special">(</span><span class="keyword">void</span><span class="special">)</span>
    <span class="identifier">CONTRACT_DESTRUCTOR</span><span class="special">(</span> <span class="comment">// Destructor contract macro.
</span>            <span class="special">(</span><span class="keyword">class</span><span class="special">)</span> <span class="special">(</span><span class="identifier">myvector</span><span class="special">)</span> <span class="comment">// Destructor signature.
</span>            <span class="comment">// Must use `(void)` for no arguments.
</span>            <span class="special">(</span><span class="keyword">public</span><span class="special">)</span> <span class="special">(</span><span class="keyword">virtual</span><span class="special">)</span> <span class="special">(</span><span class="identifier">myvector</span><span class="special">)(</span> <span class="special">(</span><span class="keyword">void</span><span class="special">)</span> <span class="special">)</span>
    <span class="comment">// No preconditions allowed (no arguments).
</span>    <span class="comment">// No postconditions allowed (no object after destructor).
</span>    <span class="special">(</span><span class="identifier">body</span><span class="special">)</span> <span class="special">(;)</span> <span class="special">)</span>

    <span class="comment">// Contract for member function.
</span>    <span class="keyword">void</span> <span class="identifier">insert</span><span class="special">(</span><span class="identifier">iterator</span> <span class="identifier">where</span><span class="special">,</span> <span class="identifier">size_type</span> <span class="identifier">count</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">element</span><span class="special">)</span>
    <span class="identifier">CONTRACT_FUNCTION</span><span class="special">(</span> <span class="comment">// Function contract macro.
</span>            <span class="special">(</span><span class="keyword">class</span><span class="special">)</span> <span class="special">(</span><span class="identifier">copyable</span><span class="special">)(</span><span class="identifier">myvector</span><span class="special">)</span> <span class="comment">// Function signature.
</span>            <span class="comment">// Old values for object `this` and argument `where`.
</span>            <span class="special">(</span><span class="keyword">public</span><span class="special">)</span> <span class="special">(</span><span class="keyword">void</span><span class="special">)</span> <span class="special">(</span><span class="identifier">insert</span><span class="special">)(</span> <span class="special">(</span><span class="identifier">copyable</span><span class="special">)(</span><span class="identifier">iterator</span><span class="special">)(</span><span class="identifier">where</span><span class="special">)</span>
                    <span class="special">(</span><span class="identifier">size_type</span><span class="special">)(</span><span class="identifier">count</span><span class="special">)</span> <span class="special">(</span><span class="keyword">const</span> <span class="identifier">T</span><span class="special">&amp;)(</span><span class="identifier">element</span><span class="special">)</span> <span class="special">)</span>
    <span class="special">(</span><span class="identifier">precondition</span><span class="special">)</span> <span class="special">({</span> <span class="comment">// Function preconditions (optional).
</span>        <span class="identifier">CONTRACT_ASSERT</span><span class="special">(</span> <span class="special">(</span><span class="identifier">size</span><span class="special">()</span> <span class="special">+</span> <span class="identifier">count</span><span class="special">)</span> <span class="special">&lt;=</span> <span class="identifier">max_size</span><span class="special">()</span> <span class="special">);</span>
        <span class="comment">// More preconditions here...
</span>    <span class="special">})</span>
    <span class="special">(</span><span class="identifier">postcondition</span><span class="special">)</span> <span class="special">({</span> <span class="comment">// Function postconditions (optional).
</span>        <span class="comment">// Any C++ code allowed in contracts (but keep it simple).
</span>        <span class="comment">// Old values of types tagged copyable via `CONTRACT_OLDOF()`.
</span>        <span class="keyword">if</span> <span class="special">(</span><span class="identifier">capacity</span><span class="special">()</span> <span class="special">==</span> <span class="identifier">CONTRACT_OLDOF</span><span class="special">(</span><span class="keyword">this</span><span class="special">)-&gt;</span><span class="identifier">capacity</span><span class="special">())</span> <span class="special">{</span>
            <span class="identifier">CONTRACT_ASSERT</span><span class="special">(</span> <span class="identifier">all_equals</span><span class="special">(</span>
                    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">prior</span><span class="special">(</span><span class="identifier">CONTRACT_OLDOF</span><span class="special">(</span><span class="identifier">where</span><span class="special">)),</span>
                    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">prior</span><span class="special">(</span><span class="identifier">CONTRACT_OLDOF</span><span class="special">(</span><span class="identifier">where</span><span class="special">))</span> <span class="special">+</span> <span class="identifier">count</span><span class="special">,</span>
                    <span class="identifier">element</span><span class="special">)</span> <span class="special">);</span>
        <span class="special">}</span>
        <span class="comment">// More postconditions here...
</span>    <span class="special">})</span>
    <span class="special">(</span><span class="identifier">body</span><span class="special">)</span> <span class="special">({</span> <span class="comment">// Function body (mandatory).
</span>        <span class="identifier">vector_</span><span class="special">.</span><span class="identifier">insert</span><span class="special">(</span><span class="identifier">where</span><span class="special">,</span> <span class="identifier">count</span><span class="special">,</span> <span class="identifier">element</span><span class="special">);</span>
    <span class="special">})</span> <span class="special">)</span>

    <span class="comment">// Contract for constant member.
</span>    <span class="identifier">const_iterator</span> <span class="identifier">begin</span><span class="special">(</span><span class="keyword">void</span><span class="special">)</span> <span class="keyword">const</span>
    <span class="identifier">CONTRACT_FUNCTION</span><span class="special">(</span> <span class="special">(</span><span class="keyword">class</span><span class="special">)</span> <span class="special">(</span><span class="identifier">myvector</span><span class="special">)</span>
            <span class="comment">// Subcontracting for multiple inheritance.
</span>            <span class="special">(</span><span class="identifier">inherit</span><span class="special">)(</span><span class="identifier">boundable</span><span class="special">&lt;</span><span class="identifier">const_iterator</span><span class="special">&gt;)</span>
            <span class="special">(</span><span class="identifier">inherit</span><span class="special">)(</span><span class="identifier">basic_begin</span><span class="special">&lt;</span><span class="identifier">const_iterator</span><span class="special">&gt;)</span>
            <span class="special">(</span><span class="keyword">public</span><span class="special">)</span> <span class="special">(</span><span class="identifier">const_iterator</span><span class="special">)</span> <span class="comment">// Non-void result type.
</span>            <span class="special">(</span><span class="identifier">begin</span><span class="special">)(</span> <span class="special">(</span><span class="keyword">void</span><span class="special">)</span> <span class="special">)</span> <span class="special">(</span><span class="keyword">const</span><span class="special">)</span> <span class="comment">// Constant.
</span>    <span class="special">(</span><span class="identifier">postcondition</span><span class="special">)</span> <span class="special">(</span><span class="identifier">result</span><span class="special">)</span> <span class="special">({</span> <span class="comment">// Named result value.
</span>        <span class="keyword">if</span> <span class="special">(</span><span class="identifier">empty</span><span class="special">())</span> <span class="identifier">CONTRACT_ASSERT</span><span class="special">(</span> <span class="identifier">result</span> <span class="special">==</span> <span class="identifier">end</span><span class="special">()</span> <span class="special">);</span>
    <span class="special">})</span>
    <span class="special">(</span><span class="identifier">body</span><span class="special">)</span> <span class="special">({</span>
        <span class="keyword">return</span> <span class="identifier">vector_</span><span class="special">.</span><span class="identifier">begin</span><span class="special">();</span>
    <span class="special">})</span> <span class="special">)</span>
    
    <span class="comment">// Contract for overloaded member (resolved because not const).
</span>    <span class="identifier">iterator</span> <span class="identifier">begin</span><span class="special">(</span><span class="keyword">void</span><span class="special">)</span>
    <span class="identifier">CONTRACT_FUNCTION</span><span class="special">(</span> <span class="special">(</span><span class="keyword">class</span><span class="special">)</span> <span class="special">(</span><span class="identifier">myvector</span><span class="special">)</span> <span class="special">(</span><span class="keyword">public</span><span class="special">)</span>
            <span class="special">(</span><span class="identifier">iterator</span><span class="special">)</span> <span class="special">(</span><span class="identifier">begin</span><span class="special">)(</span> <span class="special">(</span><span class="keyword">void</span><span class="special">)</span> <span class="special">)</span>
    <span class="special">(</span><span class="identifier">postcondition</span><span class="special">)</span> <span class="special">(</span><span class="identifier">result</span><span class="special">)</span> <span class="special">({</span>
        <span class="keyword">if</span> <span class="special">(</span><span class="identifier">empty</span><span class="special">())</span> <span class="identifier">CONTRACT_ASSERT</span><span class="special">(</span> <span class="identifier">result</span> <span class="special">==</span> <span class="identifier">end</span><span class="special">()</span> <span class="special">);</span>
    <span class="special">})</span>
    <span class="special">(</span><span class="identifier">body</span><span class="special">)</span> <span class="special">(</span>
        <span class="special">;</span>
    <span class="special">)</span> <span class="special">)</span>
    
    <span class="comment">// Contract for operator.
</span>    <span class="identifier">const_reference</span> <span class="keyword">operator</span><span class="special">[](</span><span class="identifier">size_type</span> <span class="identifier">index</span><span class="special">)</span> <span class="keyword">const</span>
    <span class="identifier">CONTRACT_FUNCTION</span><span class="special">(</span> <span class="special">(</span><span class="keyword">class</span><span class="special">)</span> <span class="special">(</span><span class="identifier">myvector</span><span class="special">)</span>
            <span class="comment">// Must spell operator name also in words).
</span>            <span class="special">(</span><span class="keyword">public</span><span class="special">)</span> <span class="special">(</span><span class="identifier">const_reference</span><span class="special">)</span> <span class="special">(</span><span class="keyword">operator</span><span class="special">([],</span> <span class="identifier">at</span><span class="special">))(</span>
                    <span class="special">(</span><span class="identifier">size_type</span><span class="special">)(</span><span class="identifier">index</span><span class="special">)</span> <span class="special">)</span> <span class="special">(</span><span class="keyword">const</span><span class="special">)</span>
    <span class="special">(</span><span class="identifier">precondition</span><span class="special">)</span> <span class="special">({</span>
        <span class="identifier">CONTRACT_ASSERT</span><span class="special">(</span> <span class="identifier">index</span> <span class="special">&lt;</span> <span class="identifier">size</span><span class="special">()</span> <span class="special">);</span>
    <span class="special">})</span>
    <span class="special">(</span><span class="identifier">body</span><span class="special">)</span> <span class="special">(;)</span> <span class="special">)</span>

    <span class="comment">// Main function example used in documentation.
</span>    <span class="keyword">void</span> <span class="identifier">push_back</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">element</span><span class="special">)</span>
    <span class="identifier">CONTRACT_FUNCTION</span><span class="special">(</span>
            <span class="special">(</span><span class="keyword">class</span><span class="special">)</span> <span class="special">(</span><span class="identifier">copyable</span><span class="special">)(</span><span class="identifier">myvector</span><span class="special">)</span> <span class="special">(</span><span class="identifier">inherit</span><span class="special">)(</span><span class="identifier">pushable</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;)</span>
            <span class="special">(</span><span class="keyword">public</span><span class="special">)</span> <span class="special">(</span><span class="keyword">void</span><span class="special">)</span> <span class="special">(</span><span class="identifier">push_back</span><span class="special">)(</span> <span class="special">(</span><span class="keyword">const</span> <span class="identifier">T</span><span class="special">&amp;)(</span><span class="identifier">element</span><span class="special">)</span> <span class="special">)</span>
    <span class="special">(</span><span class="identifier">precondition</span><span class="special">)</span> <span class="special">({</span>
        <span class="identifier">CONTRACT_ASSERT</span><span class="special">(</span> <span class="identifier">size</span><span class="special">()</span> <span class="special">&lt;</span> <span class="identifier">max_size</span><span class="special">()</span> <span class="special">);</span>
    <span class="special">})</span>
    <span class="special">(</span><span class="identifier">postcondition</span><span class="special">)</span> <span class="special">({</span>
        <span class="identifier">CONTRACT_ASSERT</span><span class="special">(</span> <span class="identifier">size</span><span class="special">()</span> <span class="special">==</span> <span class="special">(</span><span class="identifier">CONTRACT_OLDOF</span><span class="special">(</span><span class="keyword">this</span><span class="special">)-&gt;</span><span class="identifier">size</span><span class="special">()</span> <span class="special">+</span> <span class="number">1</span><span class="special">)</span> <span class="special">);</span>
    <span class="special">})</span>
    <span class="special">(</span><span class="identifier">body</span><span class="special">)</span> <span class="special">({</span>
        <span class="identifier">vector_</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">element</span><span class="special">);</span>
    <span class="special">})</span> <span class="special">)</span>
    
    <span class="comment">// Contract for template plus static member function.
</span>    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Iter</span><span class="special">&gt;</span>
    <span class="keyword">static</span> <span class="keyword">bool</span> <span class="identifier">all_equals</span><span class="special">(</span><span class="identifier">Iter</span> <span class="identifier">first</span><span class="special">,</span> <span class="identifier">Iter</span> <span class="identifier">last</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">element</span><span class="special">)</span>
    <span class="identifier">CONTRACT_FUNCTION</span><span class="special">(</span> <span class="special">(</span><span class="keyword">class</span><span class="special">)</span> <span class="special">(</span><span class="identifier">myvector</span><span class="special">)</span>
            <span class="special">(</span><span class="keyword">public</span><span class="special">)</span> <span class="special">(</span><span class="keyword">template</span><span class="special">)(</span> <span class="special">(</span><span class="keyword">class</span><span class="special">)(</span><span class="identifier">Iter</span><span class="special">)</span> <span class="special">)</span> <span class="comment">// Function template.
</span>            <span class="special">(</span><span class="keyword">static</span><span class="special">)</span> <span class="special">(</span><span class="keyword">bool</span><span class="special">)</span> <span class="special">(</span><span class="identifier">all_equals</span><span class="special">)(</span> <span class="comment">// Static member.
</span>                    <span class="special">(</span><span class="identifier">Iter</span><span class="special">)(</span><span class="identifier">first</span><span class="special">)</span> <span class="special">(</span><span class="identifier">Iter</span><span class="special">)(</span><span class="identifier">last</span><span class="special">)</span> <span class="special">(</span><span class="keyword">const</span> <span class="identifier">T</span><span class="special">&amp;)(</span><span class="identifier">element</span><span class="special">)</span> <span class="special">)</span>
    <span class="special">(</span><span class="identifier">precondition</span><span class="special">)</span> <span class="special">({</span>
        <span class="identifier">CONTRACT_ASSERT</span><span class="special">(</span> <span class="identifier">first</span> <span class="special">&lt;</span> <span class="identifier">last</span> <span class="special">);</span>
    <span class="special">})</span>
    <span class="special">(</span><span class="identifier">body</span><span class="special">)</span> <span class="special">({</span>
        <span class="comment">// For simplicity, let's assume T can be compared.
</span>        <span class="keyword">for</span> <span class="special">(</span><span class="identifier">Iter</span> <span class="identifier">i</span> <span class="special">=</span> <span class="identifier">first</span><span class="special">;</span> <span class="identifier">i</span> <span class="special">&lt;</span> <span class="identifier">last</span><span class="special">;</span> <span class="special">++</span><span class="identifier">i</span><span class="special">)</span> <span class="special">{</span>
            <span class="keyword">if</span> <span class="special">(*</span><span class="identifier">i</span> <span class="special">!=</span> <span class="identifier">element</span><span class="special">)</span> <span class="keyword">return</span> <span class="keyword">false</span><span class="special">;</span>
        <span class="special">}</span>
        <span class="keyword">return</span> <span class="keyword">true</span><span class="special">;</span>
    <span class="special">})</span> <span class="special">)</span>

    <span class="comment">// Similarly, complete contracts sketched here and add contracts
</span>    <span class="comment">// for all other functions (see [Crowl2006] vector example).
</span>    <span class="keyword">bool</span> <span class="identifier">empty</span><span class="special">(</span><span class="keyword">void</span><span class="special">)</span> <span class="keyword">const</span> <span class="special">{</span> <span class="keyword">return</span> <span class="identifier">vector_</span><span class="special">.</span><span class="identifier">empty</span><span class="special">();</span> <span class="special">}</span>
    <span class="identifier">size_type</span> <span class="identifier">size</span><span class="special">(</span><span class="keyword">void</span><span class="special">)</span> <span class="keyword">const</span> <span class="special">{</span> <span class="keyword">return</span> <span class="identifier">vector_</span><span class="special">.</span><span class="identifier">size</span><span class="special">();</span> <span class="special">}</span>
    <span class="identifier">size_type</span> <span class="identifier">max_size</span><span class="special">(</span><span class="keyword">void</span><span class="special">)</span> <span class="keyword">const</span> <span class="special">{</span> <span class="keyword">return</span> <span class="identifier">vector_</span><span class="special">.</span><span class="identifier">max_size</span><span class="special">();</span> <span class="special">}</span>
    <span class="identifier">size_type</span> <span class="identifier">capacity</span><span class="special">(</span><span class="keyword">void</span><span class="special">)</span> <span class="keyword">const</span> <span class="special">{</span> <span class="keyword">return</span> <span class="identifier">vector_</span><span class="special">.</span><span class="identifier">capacity</span><span class="special">();</span> <span class="special">}</span>
    <span class="identifier">iterator</span> <span class="identifier">end</span><span class="special">(</span><span class="keyword">void</span><span class="special">)</span> <span class="special">{</span> <span class="keyword">return</span> <span class="identifier">vector_</span><span class="special">.</span><span class="identifier">end</span><span class="special">();</span> <span class="special">}</span>
    <span class="identifier">const_iterator</span> <span class="identifier">end</span><span class="special">(</span><span class="keyword">void</span><span class="special">)</span> <span class="keyword">const</span> <span class="special">{</span> <span class="keyword">return</span> <span class="identifier">vector_</span><span class="special">.</span><span class="identifier">end</span><span class="special">();</span> <span class="special">}</span>
    <span class="identifier">const_reference</span> <span class="identifier">back</span><span class="special">(</span><span class="keyword">void</span><span class="special">)</span> <span class="keyword">const</span> <span class="special">{</span> <span class="keyword">return</span> <span class="identifier">vector_</span><span class="special">.</span><span class="identifier">back</span><span class="special">();</span> <span class="special">}</span>

<span class="keyword">private</span><span class="special">:</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span> <span class="identifier">vector_</span><span class="special">;</span>
<span class="special">};</span>

<span class="comment">// Deferred constructor body definition.
</span><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="identifier">CONTRACT_CONSTRUCTOR_BODY</span><span class="special">(</span><span class="identifier">myvector</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;,</span> <span class="identifier">myvector</span><span class="special">)(</span>
        <span class="keyword">const</span> <span class="identifier">myvector</span><span class="special">&amp;</span> <span class="identifier">right</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">vector_</span> <span class="special">=</span> <span class="identifier">right</span><span class="special">.</span><span class="identifier">vector_</span><span class="special">;</span>
<span class="special">}</span>

<span class="comment">// Deferred destructor body definition.
</span><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="identifier">CONTRACT_DESTRUCTOR_BODY</span><span class="special">(</span><span class="identifier">myvector</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;,</span> <span class="identifier">myvector</span><span class="special">)(</span><span class="keyword">void</span><span class="special">)</span> <span class="special">{</span>
    <span class="comment">// Do nothing in this case.
</span><span class="special">}</span>

<span class="comment">// Deferred member function definition.
</span><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">typename</span> <span class="identifier">myvector</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">iterator</span> <span class="identifier">myvector</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">CONTRACT_BODY</span><span class="special">(</span><span class="identifier">begin</span><span class="special">)(</span>
        <span class="keyword">void</span><span class="special">)</span> <span class="special">{</span>
    <span class="keyword">return</span> <span class="identifier">vector_</span><span class="special">.</span><span class="identifier">begin</span><span class="special">();</span>
<span class="special">}</span>

<span class="comment">// Deferred member operator definition.
</span><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">typename</span> <span class="identifier">myvector</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">const_reference</span> <span class="identifier">myvector</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span>
        <span class="identifier">CONTRACT_BODY</span><span class="special">(</span><span class="keyword">operator</span><span class="special">([],</span> <span class="identifier">at</span><span class="special">))(</span>
        <span class="identifier">size_type</span> <span class="identifier">index</span><span class="special">)</span> <span class="keyword">const</span> <span class="special">{</span>
    <span class="keyword">return</span> <span class="identifier">vector_</span><span class="special">[</span><span class="identifier">index</span><span class="special">];</span>
<span class="special">}</span>

<span class="comment">// Contract for non-member function.
</span><span class="keyword">double</span> <span class="identifier">abs_total</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">myvector</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;&amp;</span> <span class="identifier">vector</span><span class="special">)</span>
<span class="identifier">CONTRACT_FUNCTION</span><span class="special">(</span>
        <span class="special">(</span><span class="keyword">double</span><span class="special">)</span> <span class="special">(</span><span class="identifier">abs_total</span><span class="special">)(</span> <span class="special">(</span><span class="keyword">const</span> <span class="identifier">myvector</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;&amp;)(</span><span class="identifier">vector</span><span class="special">)</span> <span class="special">)</span>
<span class="special">(</span><span class="identifier">postcondition</span><span class="special">)</span> <span class="special">(</span><span class="identifier">total</span><span class="special">)</span> <span class="special">({</span> <span class="comment">// Result value named `total`.
</span>    <span class="identifier">CONTRACT_ASSERT</span><span class="special">(</span> <span class="identifier">total</span> <span class="special">&gt;=</span> <span class="number">0.0</span> <span class="special">);</span>
<span class="special">})</span>
<span class="special">(</span><span class="identifier">body</span><span class="special">)</span> <span class="special">({</span>
    <span class="keyword">double</span> <span class="identifier">total</span> <span class="special">=</span> <span class="number">0.0</span><span class="special">;</span>
    <span class="comment">// Block invariants can appear anywhere in code block.
</span>    <span class="identifier">CONTRACT_ASSERT_BLOCK_INVARIANT</span><span class="special">(</span> <span class="identifier">total</span> <span class="special">==</span> <span class="number">0.0</span> <span class="special">);</span>

    <span class="special">{</span> <span class="comment">// Variant initialized locally to its loop.
</span>        <span class="identifier">CONTRACT_INIT_LOOP_VARIANT</span><span class="special">;</span>
        <span class="keyword">for</span> <span class="special">(</span><span class="identifier">size_t</span> <span class="identifier">i</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span> <span class="identifier">i</span> <span class="special">&lt;</span> <span class="identifier">vector</span><span class="special">.</span><span class="identifier">size</span><span class="special">();</span> <span class="special">++</span><span class="identifier">i</span><span class="special">)</span> <span class="special">{</span>
            <span class="comment">// Block invariants used to assert loop invariants.
</span>            <span class="identifier">CONTRACT_ASSERT_BLOCK_INVARIANT</span><span class="special">(</span> <span class="identifier">i</span> <span class="special">&lt;</span> <span class="identifier">vector</span><span class="special">.</span><span class="identifier">size</span><span class="special">()</span> <span class="special">);</span>
            <span class="comment">// Loop variant (can only appear in loops).
</span>            <span class="identifier">CONTRACT_ASSERT_LOOP_VARIANT</span><span class="special">(</span> <span class="identifier">vector</span><span class="special">.</span><span class="identifier">size</span><span class="special">()</span> <span class="special">-</span> <span class="identifier">i</span> <span class="special">);</span>

            <span class="identifier">total</span> <span class="special">+=</span> <span class="identifier">vector</span><span class="special">[</span><span class="identifier">i</span><span class="special">];</span>
        <span class="special">}</span>
    <span class="special">}</span>
    <span class="keyword">return</span> <span class="identifier">total</span> <span class="special">&lt;</span> <span class="number">0.0</span> <span class="special">?</span> <span class="special">-</span><span class="identifier">total</span> <span class="special">:</span> <span class="identifier">total</span><span class="special">;</span>
<span class="special">})</span> <span class="special">)</span>

</pre>
<p>
        </p>
<p>
        </p>
<p>
          
</p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">contract</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">pushable</span> <span class="special">{</span>

    <span class="identifier">CONTRACT_INVARIANT</span><span class="special">(</span> <span class="special">({})</span> <span class="special">)</span>

<span class="keyword">public</span><span class="special">:</span>
    <span class="comment">// Contract for pure virtual function.
</span>    <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="identifier">push_back</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">element</span><span class="special">)</span>
    <span class="identifier">CONTRACT_FUNCTION</span><span class="special">(</span>
            <span class="special">(</span><span class="keyword">class</span><span class="special">)</span> <span class="special">(</span><span class="identifier">pushable</span><span class="special">)</span>
            <span class="special">(</span><span class="keyword">public</span><span class="special">)</span> <span class="special">(</span><span class="keyword">virtual</span><span class="special">)</span> <span class="special">(</span><span class="keyword">void</span><span class="special">)</span> <span class="special">(</span><span class="identifier">push_back</span><span class="special">)(</span> <span class="special">(</span><span class="keyword">const</span> <span class="identifier">T</span><span class="special">&amp;)(</span><span class="identifier">element</span><span class="special">)</span> <span class="special">)</span>
    <span class="special">(</span><span class="identifier">postcondition</span><span class="special">)</span> <span class="special">({</span>
        <span class="identifier">CONTRACT_ASSERT</span><span class="special">(</span> <span class="identifier">back</span><span class="special">()</span> <span class="special">==</span> <span class="identifier">element</span> <span class="special">);</span>
    <span class="special">})</span>
    <span class="special">(</span><span class="identifier">body</span><span class="special">)</span> <span class="special">(=</span> <span class="number">0</span><span class="special">;)</span> <span class="special">)</span> <span class="comment">// Pure virtual body.
</span>
    <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">back</span><span class="special">()</span> <span class="keyword">const</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span>
<span class="special">};</span>

</pre>
<p>
        </p>
<p>
        </p>
<p>
          
</p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">contract</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">ConstIter</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">boundable</span> <span class="special">{</span>

    <span class="identifier">CONTRACT_INVARIANT</span><span class="special">(</span> <span class="special">({</span>
        <span class="identifier">CONTRACT_ASSERT</span><span class="special">(</span> <span class="identifier">begin</span><span class="special">()</span> <span class="special">&lt;=</span> <span class="identifier">end</span><span class="special">()</span> <span class="special">);</span>
    <span class="special">})</span> <span class="special">)</span>

<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">virtual</span> <span class="identifier">ConstIter</span> <span class="identifier">begin</span><span class="special">(</span><span class="keyword">void</span><span class="special">)</span> <span class="keyword">const</span>
    <span class="identifier">CONTRACT_FUNCTION</span><span class="special">(</span> <span class="special">(</span><span class="keyword">class</span><span class="special">)</span> <span class="special">(</span><span class="identifier">boundable</span><span class="special">)</span>
            <span class="special">(</span><span class="keyword">public</span><span class="special">)</span> <span class="special">(</span><span class="keyword">virtual</span><span class="special">)</span> <span class="special">(</span><span class="identifier">ConstIter</span><span class="special">)</span> <span class="special">(</span><span class="identifier">begin</span><span class="special">)(</span> <span class="special">(</span><span class="keyword">void</span><span class="special">)</span> <span class="special">)</span> <span class="special">(</span><span class="keyword">const</span><span class="special">)</span>
    <span class="special">(</span><span class="identifier">body</span><span class="special">)</span> <span class="special">(=</span> <span class="number">0</span><span class="special">;)</span> <span class="special">)</span>

    <span class="keyword">virtual</span> <span class="identifier">ConstIter</span> <span class="identifier">end</span><span class="special">(</span><span class="keyword">void</span><span class="special">)</span> <span class="keyword">const</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span>
<span class="special">};</span>

</pre>
<p>
        </p>
<p>
        </p>
<p>
          
</p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">contract</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">ConstIter</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">basic_begin</span> <span class="special">{</span>

    <span class="identifier">CONTRACT_INVARIANT</span><span class="special">(</span> <span class="special">({})</span> <span class="special">)</span>

<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">virtual</span> <span class="identifier">ConstIter</span> <span class="identifier">begin</span><span class="special">(</span><span class="keyword">void</span><span class="special">)</span> <span class="keyword">const</span>
    <span class="identifier">CONTRACT_FUNCTION</span><span class="special">(</span> <span class="special">(</span><span class="keyword">class</span><span class="special">)</span> <span class="special">(</span><span class="identifier">basic_begin</span><span class="special">)</span>
            <span class="special">(</span><span class="keyword">public</span><span class="special">)</span> <span class="special">(</span><span class="keyword">virtual</span><span class="special">)</span> <span class="special">(</span><span class="identifier">ConstIter</span><span class="special">)</span> <span class="special">(</span><span class="identifier">begin</span><span class="special">)(</span> <span class="special">(</span><span class="keyword">void</span><span class="special">)</span> <span class="special">)</span> <span class="special">(</span><span class="keyword">const</span><span class="special">)</span>
    <span class="special">(</span><span class="identifier">body</span><span class="special">)</span> <span class="special">({</span>
        <span class="keyword">return</span> <span class="identifier">ConstIter</span><span class="special">();</span> <span class="comment">// Dummy implementation (for example only).
</span>    <span class="special">})</span> <span class="special">)</span>
<span class="special">};</span>

</pre>
<p>
        </p>
<p>
      </p>
</div>
<div class="footnotes">
<br><hr width="100" align="left">
<div class="footnote"><p><sup>[<a name="ftn.id2605169" href="#id2605169" class="para">2</a>] </sup>
              Static member functions cannot be virtual so they cannot be overridden
              and they cannot subcontract.
            </p></div>
<div class="footnote"><p><sup>[<a name="ftn.id2605422" href="#id2605422" class="para">3</a>] </sup>
              However, the destructor body should be programmed to <span class="emphasis"><em>never</em></span>
              throw exceptions to comply with C++ STL exception safety requirements.
            </p></div>
<div class="footnote"><p><sup>[<a name="ftn.id2605838" href="#id2605838" class="para">4</a>] </sup>
            As usual in C++, constant-correctness can be enforced at compile-time
            only as long as programmers do not use <code class="computeroutput"><span class="keyword">const_cast</span></code>
            and <code class="computeroutput"><span class="keyword">mutable</span></code>.
          </p></div>
<div class="footnote"><p><sup>[<a name="ftn.id2605984" href="#id2605984" class="para">5</a>] </sup>
            To improve contract readability, it is recommended to configure your
            editor C++ syntax highlighting to highlight also the macros <code class="computeroutput"><span class="identifier">CONTRACT_INVARIANT</span></code>, <code class="computeroutput"><span class="identifier">CONTRACT_FUNCTION</span></code>,
            <code class="computeroutput"><span class="identifier">CONTRACT_CONSTRUCTOR</span></code>,
            <code class="computeroutput"><span class="identifier">CONTRACT_DESTRUCTOR</span></code>,
            <code class="computeroutput"><span class="identifier">CONTRACT_OLDOF</span></code>, <code class="computeroutput"><span class="identifier">CONTRACT_BODY</span></code>, <code class="computeroutput"><span class="identifier">CONTRACT_CONSTRUCTOR_BODY</span></code>,
            <code class="computeroutput"><span class="identifier">CONTRACT_DESTRUCTOR_BODY</span></code>,
            <code class="computeroutput"><span class="identifier">CONTRACT_ASSERT</span></code>, <code class="computeroutput"><span class="identifier">CONTRACT_ASSERT_MSG</span></code>, <code class="computeroutput"><span class="identifier">CONTRACT_ASSERT_BLOCK_INVARIANT</span></code>, <code class="computeroutput"><span class="identifier">CONTRACT_ASSERT_BLOCK_INVARIANT_MSG</span></code>,
            <code class="computeroutput"><span class="identifier">CONTRACT_ASSERT_LOOP_VARIANT</span></code>,
            <code class="computeroutput"><span class="identifier">CONTRACT_ASSERT_LOOP_VARIANT_MSG</span></code>,
            <code class="computeroutput"><span class="identifier">CONTRACT_INIT_LOOP_VARIANT</span></code>,
            and the sequence tokens <code class="computeroutput"><span class="identifier">precondition</span></code>,
            <code class="computeroutput"><span class="identifier">postcondition</span></code>, <code class="computeroutput"><span class="identifier">body</span></code>, <code class="computeroutput"><span class="identifier">copyable</span></code>,
            and <code class="computeroutput"><span class="identifier">inherit</span></code>. For example,
            this can be done in the Vi IMproved (VIM) editor by adding these symbols
            to the <code class="computeroutput"><span class="string">"cpp.vim"</span></code>
            file (usually in the VIM system configuration directory).
          </p></div>
<div class="footnote"><p><sup>[<a name="ftn.id2606276" href="#id2606276" class="para">6</a>] </sup>
              Some text editing programs might highlight curly brackets <code class="computeroutput"><span class="special">{}</span></code> within a macro parameter as a C++
              syntax error. This is incorrect as the ISO C++ standard allows for
              macro parameters to contain curly brackets and the editor might offer
              an option for disabling this incorrect syntax error highlighting. For
              example, when C++ syntax highlighting is turned on in the Vi IMproved
              (VIM) editor, curly brackets within macro parameters are highlighted
              as errors but that can be disabled by adding the line <code class="computeroutput"><span class="identifier">let</span> <span class="identifier">c_no_curly_error</span><span class="special">=</span><span class="number">1</span></code> in
              the <code class="computeroutput"><span class="string">".vimrc"</span></code>
              file (typically in your home directory).
            </p></div>
<div class="footnote"><p><sup>[<a name="ftn.id2607079" href="#id2607079" class="para">7</a>] </sup>
              However, this is the only sensible semantics for copying pointers as
              the pointer could of type <code class="computeroutput"><span class="keyword">void</span><span class="special">*</span></code> for which it is not possible to copy
              the pointed object, plus there might cases where the functions actually
              changed the pointer value so <code class="computeroutput"><a href="../CONTRACT_OLDOF.html" target="_top">CONTRACT_OLDOF</a><span class="special">()</span></code> needs to the return the old pointer
              value (and not the old pointed value), plus this the usual C++ pointer
              copy semantic.
            </p></div>
<div class="footnote"><p><sup>[<a name="ftn.id2552836" href="#id2552836" class="para">8</a>] </sup>
            <a class="link" href="bibliography.html" title="Bibliography">[Meyer1997]</a> argues preconditions
            asserted using non-public members are ill written thus the Eiffel programming
            language enforces this rule at compile-time. However, in C++ friend callers
            could still be able to fully check preconditions via the friendship even
            when non-public functions are used to assert them therefore this rule
            is left as a recommended practice for programmers to follow and it is
            not enforced by the library.
          </p></div>
<div class="footnote"><p><sup>[<a name="ftn.id2609836" href="#id2609836" class="para">9</a>] </sup>
            If two <a href="http://www.boost.org/libs/preprocessor/doc/index.html" target="_top">Boost.Preprocessor</a>
            sequences are specified one after the other then they are automatically
            concatenated into one larger sequence. For example let <code class="computeroutput"><span class="identifier">seq1</span></code> be <code class="computeroutput"><span class="special">(</span><span class="identifier">token1</span><span class="special">)</span> <span class="special">(</span><span class="identifier">token2</span><span class="special">)</span></code> and <code class="computeroutput"><span class="identifier">seq2</span></code>
            be <code class="computeroutput"><span class="special">(</span><span class="identifier">token3</span><span class="special">)</span> <span class="special">(</span><span class="identifier">token4</span><span class="special">)</span> <span class="special">(</span><span class="identifier">token5</span><span class="special">)</span></code> then <code class="computeroutput"><span class="identifier">seq1</span>
            <span class="identifier">seq2</span></code> is <code class="computeroutput"><span class="special">(</span><span class="identifier">token1</span><span class="special">)</span> <span class="special">(</span><span class="identifier">token2</span><span class="special">)</span> <span class="special">(</span><span class="identifier">token3</span><span class="special">)</span> <span class="special">(</span><span class="identifier">token4</span><span class="special">)</span> <span class="special">(</span><span class="identifier">token5</span><span class="special">)</span></code>.
          </p></div>
<div class="footnote"><p><sup>[<a name="ftn.id2611416" href="#id2611416" class="para">10</a>] </sup>
              A <span class="emphasis"><em>constant-correct copy constructor</em></span> constructs
              the object copying it from a constant-reference of the source object
              thus it cannot alter the state of the copied object.
            </p></div>
<div class="footnote"><p><sup>[<a name="ftn.id2614477" href="#id2614477" class="para">11</a>] </sup>
            Using the augmented object state the library could detect infinite recursion
            between overriding and overridden function. However, to break the recursion
            the base contract will have to call the base body function forcing static
            binding (otherwise using dynamic binding the overriding function will
            be called causing the infinite recursion). The contract itself cannot
            perform the static binding call (e.g., using static_cast&lt;&gt; to the
            object) because the object state is changed only if pointers or references
            to the objects are used to call the body, but if pointers or reference
            are used then C++ uses dynamic binding for the call. So the contract
            function could call a special method of the contract class which performs
            the static binding call but such a static binding call will raise a compiler
            error if the body function is pure virtual. The library does not know
            directly when a function is pure virtual (body is <code class="computeroutput"><span class="special">=</span>
            <span class="number">0</span><span class="special">;</span></code>)
            or not so the library will have to define the contract class static binding
            method also for pure virtual functions and in this case the static binding
            call <code class="computeroutput"><span class="identifier">B</span><span class="special">::</span><span class="identifier">f</span><span class="special">()</span></code>
            will raise a compile time error because the function called via static
            binding is pure virtual.
          </p></div>
<div class="footnote"><p><sup>[<a name="ftn.id2618694" href="#id2618694" class="para">12</a>] </sup>
              The library <span class="emphasis"><em>could</em></span> overcome this limitation if
              future versions of the C++ standard were to support delegating constructors
              (as proposed by <a class="link" href="bibliography.html" title="Bibliography">[Sutter2005]</a>).
            </p></div>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright  2009 -2010 Lorenzo Caminiti<p>
        Distributed under the Contract++ Software License, Version 1.0 (see accompanying
        file LICENSE_1_0.txt)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="getting_started.html"><img src=".././doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src=".././doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src=".././doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="without_the_macros.html"><img src=".././doc/html/images/next.png" alt="Next"></a>
</div>
</body>
</html>
