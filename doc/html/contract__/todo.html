<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>TODO</title>
<link rel="stylesheet" href="../doc/html/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.73.2">
<link rel="start" href="../index.html" title="Contract++ 0.3.490">
<link rel="up" href="../index.html" title="Contract++ 0.3.490">
<link rel="prev" href="release_history.html" title="Release History">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="spirit-nav">
<a accesskey="p" href="release_history.html"><img src=".././doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src=".././doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src=".././doc/html/images/home.png" alt="Home"></a>
</div>
<hr>
<div class="section" lang="en">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="contract__.todo"></a><a class="link" href="todo.html" title="TODO">TODO</a>
</h2></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="todo.html#contract__.todo.improve_contract_macros__sequence__error_detection_and_reporting">Improve
      contract macros <code class="computeroutput"><span class="identifier">sequence</span></code> error
      detection and reporting</a></span></dt>
<dt><span class="section"><a href="todo.html#contract__.todo.can_block_invariants_and_loop_variants_be_made_constant_correct_">Can
      block invariants and loop variants be made constant-correct?</a></span></dt>
<dt><span class="section"><a href="todo.html#contract__.todo.improve_compile_time_performances">Improve
      compile-time performances</a></span></dt>
<dt><span class="section"><a href="todo.html#contract__.todo.analyze_run_time_performances">Analyze
      run-time performances</a></span></dt>
<dt><span class="section"><a href="todo.html#contract__.todo.support_concurrency">Support concurrency</a></span></dt>
<dt><span class="section"><a href="todo.html#contract__.todo.can_constructor_member_initialization_list_limitation_be_removed_">Can
      constructor member initialization list limitation be removed?</a></span></dt>
<dt><span class="section"><a href="todo.html#contract__.todo.should_preconditions_be_checked_before_constructor_member_initialization_list_">Should
      preconditions be checked before constructor member initialization list?</a></span></dt>
<dt><span class="section"><a href="todo.html#contract__.todo.can_syntax_of_contract_macros_be_unified_with_other_boost_libraries_">Can
      syntax of contract macros be unified with other Boost libraries?</a></span></dt>
<dt><span class="section"><a href="todo.html#contract__.todo.consider_allowing_optional_contract_checking_based_on_assertion_importance_and_or_class_name">Consider
      allowing optional contract checking based on assertion importance and/or class
      name</a></span></dt>
<dt><span class="section"><a href="todo.html#contract__.todo.consider_adding_contracts_to_all_stl_classes_and_functions_in__contract__std___">Consider
      adding contracts to all STL classes and functions in <code class="computeroutput"><span class="identifier">contract</span><span class="special">::</span><span class="identifier">std</span><span class="special">::</span></code></a></span></dt>
</dl></div>
<p>
      This section lists open items under consideration for future development of
      this library. It is mainly intended as a memorandum for the library authors.
    </p>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="contract__.todo.improve_contract_macros__sequence__error_detection_and_reporting"></a><a class="link" href="todo.html#contract__.todo.improve_contract_macros__sequence__error_detection_and_reporting" title="Improve contract macros sequence error detection and reporting">Improve
      contract macros <code class="computeroutput"><span class="identifier">sequence</span></code> error
      detection and reporting</a>
</h3></div></div></div>
<p>
        The current implementation for syntax error detection and reporting for the
        <code class="computeroutput"><span class="identifier">sequence</span></code> parameter of the
        contract macros should be improved.
      </p>
<p>
        For example, if I forget the sequence element for the result type <code class="computeroutput"><span class="special">(</span><span class="identifier">result</span><span class="special">-</span><span class="identifier">type</span><span class="special">)</span></code>,
        the preprocessor gives a ton of errors most of which are about Boost.Preprocessor
        internal macros and make no sense to the user. While using the C++ preprocessor
        imposes some fundamental limitations on the amount of syntax checking I can
        implement for the <code class="computeroutput"><span class="identifier">sequence</span></code>
        macro parameter, I should be able to improve the current library implementation.
      </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="contract__.todo.can_block_invariants_and_loop_variants_be_made_constant_correct_"></a><a class="link" href="todo.html#contract__.todo.can_block_invariants_and_loop_variants_be_made_constant_correct_" title="Can block invariants and loop variants be made constant-correct?">Can
      block invariants and loop variants be made constant-correct?</a>
</h3></div></div></div>
<p>
        Currently block invariants and loop variants are <span class="emphasis"><em>not</em></span>
        constant-correct. Class invariants, preconditions, and postconditions instead
        are constant-correct so to ensure that the state of the system is not changed
        while checking the contract.
      </p>
<p>
        Can block invariants and loop variants be made constant-correct also?
      </p>
<p>
        This seems difficult because C++ does not allow to specify "constant-block":
      </p>
<pre class="programlisting"><span class="special">{</span> <span class="comment">// Some existing block.
</span>    <span class="keyword">const</span> <span class="special">{</span> <span class="comment">// A constant block -- BUT NOT SUPPORTED!!
</span>        <span class="comment">// Assert here block invariants and loop variants ensuring
</span>        <span class="comment">// const correctness.
</span>        <span class="special">...</span>
    <span class="special">}</span>
    <span class="special">...</span>
<span class="special">}</span>
</pre>
<p>
        Therefore, the code asserting block invariants and loop variants has the
        same constant constraints (possibly none!) on object, function arguments,
        result, etc as the enclosing code block... Is there a way around this? If
        not, shall I still provide block invariants and loop variants (documenting
        this limitation) or not?
      </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="contract__.todo.improve_compile_time_performances"></a><a class="link" href="todo.html#contract__.todo.improve_compile_time_performances" title="Improve compile-time performances">Improve
      compile-time performances</a>
</h3></div></div></div>
<p>
        The library significantly increases compile-time (and compiler memory usage)
        when compiling the code with contracts turned on, compared with compilation
        with contracts off. Investigate what is stressing compiler performances and
        see if the library implementation can be optimized to improve compile-time
        performances.
      </p>
<p>
        The baseline should be compilation with all contracts turned off. There might
        be different reasons for the increased compilation-time/memory:
      </p>
<div class="orderedlist"><ol type="1">
<li>
          Contract assertions are programmed in header files so they are recompiled
          for each translation unit. I can test the effect of this by disabling pre/postcondition
          compilation (so the library contract templates will still be compiled by
          the user contracts will compile much less code in the header files because
          there will be no pre/postcondition).
        </li>
<li>
          The preprocessing time needed for the contract macros expansion and to
          parse the <code class="computeroutput"><span class="identifier">sequence</span></code> macro
          parameter. I can check this by stopping compilation after preprocessing
          (<code class="computeroutput"><span class="special">-</span><span class="identifier">E</span></code>
          compiler option) and measure how long preprocessing takes compared with
          compilation.
        </li>
<li>
          The library uses quite a bit of template metaprogramming (metafunctions,
          etc). See how the compile-time effects of template metaprogramming were
          analyzed for the Boost.MSM library and performance a similar analysis for
          this library. Also study carefully the chapter on compile-time performances
          of the Boost.MPL book.
        </li>
<li>
          The library is intentionally making all the contract classes always templates
          (using the artificial <code class="computeroutput"><span class="identifier">ZERO</span></code>
          template argument so the library can internally use <code class="computeroutput"><span class="keyword">template</span><span class="special">/</span><span class="keyword">typename</span></code>
          keywords regardless of the template context). What is the compile-time
          effect of these extra contract template classes compared with the effect
          if they have not been made templates using <code class="computeroutput"><span class="identifier">ZERO</span></code>?
          <code class="computeroutput"><span class="identifier">ZERO</span></code> can be removed and
          contract classes (for non-template functions) can be made non-template
          but this comes at the cost of having the user specify <code class="computeroutput"><span class="special">(</span><span class="keyword">template</span><span class="special">)</span></code>
          instead of <code class="computeroutput"><span class="special">(</span><span class="keyword">class</span><span class="special">)</span></code> for template classes (this complicates
          the <code class="computeroutput"><span class="identifier">sequence</span></code> syntax) --
          so the <code class="computeroutput"><span class="identifier">ZERO</span></code> workaround
          should be removed only if there is evidence that it will help compile-time.
        </li>
<li>
          More?
        </li>
</ol></div>
<p>
        Ultimately, this analysis should be added to the documentation.
      </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="contract__.todo.analyze_run_time_performances"></a><a class="link" href="todo.html#contract__.todo.analyze_run_time_performances" title="Analyze run-time performances">Analyze
      run-time performances</a>
</h3></div></div></div>
<p>
        Provide some data to show run-time performances of contract checking -- the
        baseline should be run-time performance with all contracts turned off.
      </p>
<p>
        The library current implementation should be optimized to minimize run-time
        overhead of contract checking. Preliminary data shows that the library run-time
        performance impact (execution time, CPU usage, and memory usage) is acceptable.
        However, data should be systematically collected and analyzed to verify this
        (and then added to the documentation).
      </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="contract__.todo.support_concurrency"></a><a class="link" href="todo.html#contract__.todo.support_concurrency" title="Support concurrency">Support concurrency</a>
</h3></div></div></div>
<p>
        Understand what needs to be done to support concurrency.
      </p>
<p>
        <a class="link" href="bibliography.html" title="Bibliography">[Meyer1997]</a> discusses issues
        associated with Contract Programming and concurrency when, for example, a
        precondition is first checked true but then the sate of the object is changed
        asynchronously after the precondition check and before body execution so
        at the time the body executes the checked precondition is no longer true.
        Eiffel addresses this issue using the SCOOP concurrency model and implementing
        waiting contract conditions.
      </p>
<p>
        In general, it seems inappropriate for this library to force <span class="emphasis"><em>one</em></span>
        concurrency model for Contract Programming in C++ (SCOOP, or any other).
        Synchronization, including the one of contracts, might be best left up to
        programmers as usual in C++. However, currently it is not possible to lock
        a mutex at function entry and release it at function exit when using the
        contract macros. This is because programmers can only program the body so
        they can lock at body scope but not at the scope of the contracted function.
      </p>
<p>
        More in general, the library could provide a mechanism to:
      </p>
<div class="orderedlist"><ol type="1">
<li>
          Acquire resources (including a locks) at function entry.
        </li>
<li>
          Check invariants/preconditions, execute body, check invariants/postconditions
          via calling contract's <code class="computeroutput"><span class="identifier">call</span><span class="special">()</span></code>.
        </li>
<li>
          Release the acquired resources at function exit.
        </li>
</ol></div>
<p>
        For example:
      </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">f</span><span class="special">(</span><span class="keyword">void</span><span class="special">)</span>
<span class="identifier">CONTRACT_FUNCTION</span><span class="special">(</span> <span class="special">(</span><span class="keyword">void</span><span class="special">)</span> <span class="special">(</span><span class="identifier">f</span><span class="special">)(</span> <span class="special">(</span><span class="keyword">void</span><span class="special">)</span> <span class="special">)</span>
<span class="bold"><strong>(scoped)</strong></span> <span class="special">(</span> <span class="comment">// In general, no `{` parenthesis here.
</span>    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">recursive_mutex</span><span class="special">::</span><span class="identifier">scoped_lock</span> <span class="identifier">lock</span><span class="special">(</span><span class="identifier">mutex</span><span class="special">);</span>
    <span class="special">...</span> <span class="comment">// Eventually more here.
</span><span class="special">)</span>
<span class="special">(</span><span class="identifier">precondition</span><span class="special">)</span> <span class="special">({</span>
    <span class="special">...</span>
<span class="special">})</span>
<span class="special">(</span><span class="identifier">postcondition</span><span class="special">)</span> <span class="special">({</span>
    <span class="special">...</span>
<span class="special">})</span>
<span class="special">(</span><span class="identifier">body</span><span class="special">)</span> <span class="special">({</span>
    <span class="special">...</span>
<span class="special">})</span> <span class="special">)</span>

<span class="comment">// If contracts compilation on, expands to something like this:
</span><span class="keyword">void</span> <span class="identifier">f</span><span class="special">(</span><span class="keyword">void</span><span class="special">)</span>
<span class="special">{</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">recursive_mutex</span><span class="special">::</span><span class="identifier">scoped_lock</span> <span class="identifier">lock</span><span class="special">(</span><span class="identifier">mutex</span><span class="special">);</span> <span class="comment">// Scoped resources.
</span>    <span class="identifier">contract_f_</span><span class="special">().</span><span class="identifier">call</span><span class="special">();</span> <span class="comment">// Contract call.
</span><span class="special">}</span> <span class="comment">// Releases scoped resources via their destructors.
</span><span class="special">...</span>

<span class="comment">// If contracts compilation off, expands to something like this:
</span><span class="keyword">void</span> <span class="identifier">f</span><span class="special">(</span><span class="keyword">void</span><span class="special">)</span>
<span class="special">{</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">recursive_mutex</span><span class="special">::</span><span class="identifier">scoped_lock</span> <span class="identifier">lock</span><span class="special">(</span><span class="identifier">mutex</span><span class="special">);</span> <span class="comment">// Scoped resources.
</span>    <span class="special">...</span> <span class="comment">// Body code
</span><span class="special">}</span> <span class="comment">// Releases scoped resources via their destructors.
</span><span class="special">...</span>
</pre>
<p>
        Note:
      </p>
<div class="itemizedlist"><ul type="disc">
<li>
          Even when contract compilation is turned off, the scoped code should be
          part of the contract macro expansion together with the body code block.
        </li>
<li>
          In general, the scoped code is <span class="emphasis"><em>not</em></span> a code block <code class="computeroutput"><span class="special">{</span> <span class="special">...</span> <span class="special">}</span></code>
          (otherwise the acquired resources will be released at scope exit of the
          code block before calling <code class="computeroutput"><span class="identifier">call</span><span class="special">()</span></code>) but multiple instructions can still
          be specified.
        </li>
<li>
          Should this scoped code be enforced constant-correct? Maybe not, it should
          be contract-correct only if the contracted function is a <code class="computeroutput"><span class="keyword">const</span></code> member (same as for the body)... but
          think more about this.
        </li>
</ul></div>
<p>
        In addition:
      </p>
<div class="orderedlist"><ol type="1">
<li>
          The library uses a global variable to "globally disable assertion
          checking within assertion checking". This boolean variable should
          be synchronized by the library in a concurrent context. However, this will
          require a global lock... Can I implement "global disabling of assertion
          checking within assertion checking" without a global state?
        </li>
<li>
          The library uses the object member variable <code class="computeroutput"><span class="identifier">contract_state_</span></code>
          to disable assertions within nested function calls for a given object.
          This boolean member variable should be synchronized by the library in a
          concurrent context. This synchronization is between object member functions,
          it is not global, so it might be OK...
        </li>
<li>
          If implemented, both global and object synchronizations should be enabled
          only if a macro symbol <code class="computeroutput"><span class="identifier">CONTRACT_THREADING</span></code>
          is #defined (#undef by default).
        </li>
<li>
          Can I allow the user to configure how to synchronize global/object state?
          For example, I could use a configuration macro that by default uses <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">recursive_mutex</span><span class="special">::</span><span class="identifier">lock</span><span class="special">()</span></code>
          but it can be #redefined by the user...
        </li>
</ol></div>
<p>
        Most of these are open issues that need to be analysed in greater detail.
      </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="contract__.todo.can_constructor_member_initialization_list_limitation_be_removed_"></a><a class="link" href="todo.html#contract__.todo.can_constructor_member_initialization_list_limitation_be_removed_" title="Can constructor member initialization list limitation be removed?">Can
      constructor member initialization list limitation be removed?</a>
</h3></div></div></div>
<p>
        Can the contract macros overcome the constructor member initialization list
        limitation when separating constructor definition from declaration? See current
        workaround for this as documented in <code class="computeroutput"><span class="identifier">CONTRACT_CONSTRUCTOR_BODY</span><span class="special">()</span></code>.
      </p>
<p>
        However, this would have to work for all combinations of the followings
      </p>
<div class="orderedlist"><ol type="1">
<li>
          With and without contracts.
        </li>
<li>
          Definition together and separated from declaration.
        </li>
<li>
          With and without member initialization list.
        </li>
</ol></div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="contract__.todo.should_preconditions_be_checked_before_constructor_member_initialization_list_"></a><a class="link" href="todo.html#contract__.todo.should_preconditions_be_checked_before_constructor_member_initialization_list_" title="Should preconditions be checked before constructor member initialization list?">Should
      preconditions be checked before constructor member initialization list?</a>
</h3></div></div></div>
<p>
        The library checks constructor preconditions after executing the member initialization
        list: {Default AND Pre}Body{Post AND Inv} (Default is the member initialization
        list).
      </p>
<p>
        This is essentially what Eiffel does but constructors (and member initialization
        lists) are different in C++ than Eiffel. Is this what C++ should do or {Pre
        AND Default} is a better approach for C++? Why does Eiffel do {Default AND
        Pre}? Does any of the Contract Programming proposals for C++ mention this
        issue explicitly? Implementing {Pre AND Default} for this library might present
        similar challenges to separating constructor definition when member initialization
        list is specified (so it might not be possible given the lack of delegating
        constructors in C++...).
      </p>
<p>
        If {Pre AND Default} is a better approach, {Default AND Pre} should be documented
        as a library limitation. If {Default and Pre} is a better approach, I should
        document why.
      </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="contract__.todo.can_syntax_of_contract_macros_be_unified_with_other_boost_libraries_"></a><a class="link" href="todo.html#contract__.todo.can_syntax_of_contract_macros_be_unified_with_other_boost_libraries_" title="Can syntax of contract macros be unified with other Boost libraries?">Can
      syntax of contract macros be unified with other Boost libraries?</a>
</h3></div></div></div>
<p>
        Look if the contract macro <code class="computeroutput"><span class="identifier">sequence</span></code>
        syntax can be unified with the one of other Boost libraries.
      </p>
<p>
        Specifically, is this possible with respect to Boost.ConceptCheck and how
        concept checking interacts with this Contract Programming library? Same questions
        respect to Boost.Parameter. Any other Boost library I should study with respect
        to this issue?
      </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="contract__.todo.consider_allowing_optional_contract_checking_based_on_assertion_importance_and_or_class_name"></a><a class="link" href="todo.html#contract__.todo.consider_allowing_optional_contract_checking_based_on_assertion_importance_and_or_class_name" title="Consider allowing optional contract checking based on assertion importance and/or class name">Consider
      allowing optional contract checking based on assertion importance and/or class
      name</a>
</h3></div></div></div>
<p>
        Let's assume I have a template library that is well tested so I want to disable
        postcondition checking for it. However, this is a template library so it
        cannot be precompiled separately with postconditions off. I must compile
        it together with the rest of the code. Therefore, if the rest of the code
        needs to check postconditions, I must check postconditions for the well tested
        template library as well... The extra contract checking for the template
        library introduces both compile-time and run-time overhead.
      </p>
<div class="itemizedlist"><ul type="disc"><li>
          I could address this if the library allowed to disable contract checking
          (at least at run-time) based on class and function name.
        </li></ul></div>
<p>
        Moreover, there might be contract conditions which are very inefficient to
        test so I might want to turn off checking <span class="emphasis"><em>only</em></span> for the
        inefficient conditions. With respect to this issue, <a class="link" href="bibliography.html" title="Bibliography">[Mitchell2002]</a>
        recommends to only program preconditions in Eiffel that can be checked efficiently
        (as preconditions are usually left also in production code) and leave inefficient
        preconditions documented as code comments.
      </p>
<div class="itemizedlist"><ul type="disc"><li>
          I could address this by disabling contract checking (at least at run-time)
          based on some assertion <span class="emphasis"><em>importance ordering</em></span> (assertion
          importance ordering was removed from <a class="link" href="bibliography.html" title="Bibliography">[Crowl2006]</a>
          but is was present in [Crowl2005]).
        </li></ul></div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="contract__.todo.consider_adding_contracts_to_all_stl_classes_and_functions_in__contract__std___"></a><a class="link" href="todo.html#contract__.todo.consider_adding_contracts_to_all_stl_classes_and_functions_in__contract__std___" title="Consider adding contracts to all STL classes and functions in contract::std::">Consider
      adding contracts to all STL classes and functions in <code class="computeroutput"><span class="identifier">contract</span><span class="special">::</span><span class="identifier">std</span><span class="special">::</span></code></a>
</h3></div></div></div>
<p>
        All <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span></code>
        classes and functions could be wrapped by classes and functions in a namespace
        <code class="computeroutput"><span class="identifier">contract</span><span class="special">::</span><span class="identifier">std</span><span class="special">::</span></code> declaring
        contracts for all the STL classes and functions. The <code class="computeroutput"><span class="identifier">contract</span><span class="special">::</span><span class="identifier">std</span><span class="special">::</span></code>
        namespace should have the <span class="emphasis"><em>exact</em></span> same structure as <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span></code> (so
        it is easy to use for C++ programmers familiar with STL).
      </p>
<p>
        For example a <code class="computeroutput"><span class="identifier">contract</span><span class="special">::</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span></code>
        class can wrap <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span></code> providing the exact same API but
        adding contracts to it (similar to the STL Vector <a class="link" href="examples.html" title="Examples">Example</a>
        but int the <code class="computeroutput"><span class="identifier">contract</span><span class="special">::</span><span class="identifier">std</span><span class="special">::</span></code> namespace).
      </p>
<div class="itemizedlist"><ul type="disc">
<li>
          The contracts could assert all the STL standard guarantees.
        </li>
<li>
          Postcondition and invariant checking might not add much value given that
          STL implementations are usually well tested, documented, and work well.
        </li>
<li>
          Precondition checking might instead be valuable as they will check that
          the STL is not misused by the callers.
        </li>
</ul></div>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright © 2009 -2010 Lorenzo Caminiti<p>
        Distributed under the Contract++ Software License, Version 1.0 (see accompanying
        file LICENSE_1_0.txt)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="release_history.html"><img src=".././doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src=".././doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src=".././doc/html/images/home.png" alt="Home"></a>
</div>
</body>
</html>
