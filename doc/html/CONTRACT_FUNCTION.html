<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Macro CONTRACT_FUNCTION</title>
<link rel="stylesheet" href="doc/html/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.73.2">
<link rel="start" href="index.html" title="Contract++ 0.3.490">
<link rel="up" href="reference.html#header..home.lcaminiti.sandbox.dbcpp_sourceforge.boost-quickbook.doc.qbk.src.contract.macros_hpp" title="Header &lt;contract/macros.hpp&gt;">
<link rel="prev" href="CONTRACT_DESTRUCTOR.html" title="Macro CONTRACT_DESTRUCTOR">
<link rel="next" href="contract/nonmember_function.html" title="Class template nonmember_function">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="spirit-nav">
<a accesskey="p" href="CONTRACT_DESTRUCTOR.html"><img src="./doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="reference.html#header..home.lcaminiti.sandbox.dbcpp_sourceforge.boost-quickbook.doc.qbk.src.contract.macros_hpp"><img src="./doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="index.html"><img src="./doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="contract/nonmember_function.html"><img src="./doc/html/images/next.png" alt="Next"></a>
</div>
<hr>
<div class="refentry" lang="en">
<a name="CONTRACT_FUNCTION"></a><div class="titlepage"></div>
<div class="refnamediv">
<h2><span class="refentrytitle">Macro CONTRACT_FUNCTION</span></h2>
<p>CONTRACT_FUNCTION</p>
</div>
<h2 xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="refsynopsisdiv-title">Synopsis</h2>
<div xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="refsynopsisdiv"><pre class="synopsis"><span class="emphasis"><em>// In header: &lt;<a class="link" href="reference.html#header..home.lcaminiti.sandbox.dbcpp_sourceforge.boost-quickbook.doc.qbk.src.contract.macros_hpp" title="Header &lt;contract/macros.hpp&gt;">contract/macros.hpp</a>&gt;

</em></span>CONTRACT_FUNCTION(sequence)</pre></div>
<div class="refsect1" lang="en">
<a name="id2664326"></a><h2>Description</h2>
<p>Macro used to write contracts for functions (non-static members, static members, and non-members but not for constructors and destructors).</p>
<p>This macro must be used right after the member function declaration. There is no need for a trailing <code class="computeroutput">";"</code> after the macro closing parenthesis <code class="computeroutput">")"</code>.</p>
<p>For example (see the Tutorial section for more information): </p>
<pre class="programlisting">    template&lt;typename T&gt;
    class myvector {
        ... // Invariants.
        
    public:
        void push_back(const T&amp; element) // Function declaration.
        CONTRACT_FUNCTION( (class) (copyable)(myvector)
                (public) (void) (push_back)( (const T&amp;)(element) )
        (precondition) ({
            ... // Assert function preconditions.
        })
        (postcondition) ({
            ... // Assert function postconditions.
        })
        (body) ({
            ... // Actual function implementation.
        }) ) // No need for ";" after macro closing parenthesis ")".

        ... // Rest of the class.
    };
</pre>
<p><span class="bold"><strong>Parameters:</strong></span> </p>
<div class="informaltable"><table class="table">
<colgroup>
<col>
<col>
</colgroup>
<tbody><tr>
<td><span class="bold"><strong><code class="computeroutput">sequence</code></strong></span></td>
<td>A Boost.Preprocessor sequence of tokens <code class="computeroutput">(1st-token)(2nd-token)...(last-token)</code> that repeats the function signature syntactic elements and specifies the contract.<div class="itemizedlist"><ul type="disc">
<li><p>The signature tokens are needed by the library to generate the contract code with the function name, the argument types and names, etc as explained in the the Without the Macros section (e.g., the argument names are needed to actually name the arguments for the precondition and postcondition functions).</p></li>
<li><p>The extra parenthesis <code class="computeroutput">()</code> around the tokens are mandatory (they are the ones making the preprocessor sequence).</p></li>
<li><p>It is recommended to use <code class="computeroutput">CONTRACT_ASSERT()</code> to assert preconditions and postconditions within the relative code blocks.</p></li>
<li><p>Within the postcondition code block, <code class="computeroutput">CONTRACT_OLDOF(this)</code> is a constant pointer to the object old value (as it was before body execution) but only if class-type was tagged <code class="computeroutput">(copyable)</code> in <code class="computeroutput">sequence</code>. Similarly, <code class="computeroutput">CONTRACT_OLDOF(</code>argument-name<code class="computeroutput">)</code> is a constant reference to the related old argument value (as is was before body execution) but only if the argument-type was tagged <code class="computeroutput">(copyable)</code> in <code class="computeroutput">sequence</code>.</p></li>
<li><p>Within the postcondition code block, result-name (with the actual name specified in <code class="computeroutput">sequence</code>) is a constant reference to the value being returned but only when result-type is specified different from <code class="computeroutput">void</code> in <code class="computeroutput">sequence</code>.</p></li>
<li><p>For the body block, <code class="computeroutput">";"</code> can be used to separate the constructor definition from its declaration (see <code class="computeroutput">CONTRACT_CONSTRUCTOR_BODY()</code>). Also, <code class="computeroutput">"= 0;"</code> can be specified when writing contracts for pure virtual member functions.</p></li>
<li><p>As explained in the Tutorial section, the tokens in <code class="computeroutput">sequence</code> appear in the exact same order as they appear in the member function declaration followed by the optional preconditions, optional postconditions, and mandatory body.</p></li>
<li><p>The function <code class="computeroutput">sequence</code> syntax is as follows ([] for optional tokens, {} tokens resulting from parenthesis contents evaluation, || one token or the other, * tokens repeated 0 or more times, + tokens repeated 1 or more times, {}:: tokens specified only for member functions, {}? tokens specified only for non-void functions):</p></li>
</ul></div>
<code class="computeroutput"> {[(template)] [(copyable)](class-type) {(inherit)(base-class-type)}* {(public) || (protected) || (private)}}:: [(template)( {(function-template-parameter-type)(function-template-parameter-name)}+ )] [{(static) || (virtual)}] (result-type) (function-name)( {(void) || {[(copyable)](argument-type)(argument-name)}+} ) [(const)] [(precondition) ({ ... })] [(postcondition) {(result-name)}? ({ ... })] (body) ({ ... }) </code>  </td>
</tr></tbody>
</table></div>
<p>
</p>
<p><span class="bold"><strong>Returns:</strong></span> See Without the Macro section for examples of the code generated by this macro expansion. </p>
<div class="itemizedlist"><ul type="disc">
<li><p>If contract compilation is turned on, this macro expands to the function contract (see the Without the Macros section). </p></li>
<li><p>Otherwise, if contract compilation is turned off, this macro expands to just the function body using <code class="computeroutput">body_code_block</code> (and no contract overhead is added).</p></li>
</ul></div>
<p>
The usual C++ restrictions on the function signature apply. For example, static member functions cannot be <code class="computeroutput">virtual</code> or <code class="computeroutput">const</code>, plus they cannot subcontract so <code class="computeroutput">(inherit)</code> cannot be specified. The library will generate compile-time errors if <code class="computeroutput">sequence</code> violates these constraints.</p>
<p>For <span class="bold"><strong>operators</strong></span>, the operator name must also be spelled out in words and passed as <code class="computeroutput">(operator(symbol, word))</code> (this is because operator names usually contain symbols, like <code class="computeroutput">"[]"</code>, that are not valid preprocessor token so they cannot be used by this library). The spelled out operator name is arbitrary but it cannot contain operator special symbols (see the Tutorial for more information). For example, for <code class="computeroutput">operator[]</code> the function name passed to <code class="computeroutput">sequence</code> could be <code class="computeroutput">(operator([], at))</code>.</p>
<p><span class="bold"><strong>Overloaded</strong></span> functions, with same number of arguments and constant qualifier, must have different argument names (and not just different argument types). This is necessary otherwise this library will not be able to distinguish the contract of the overloaded functions from each other and it will generate a compile-time error. (C++ uses the argument types and not their names to distinguish overloaded functions from each other but this library cannot use the argument types because, in general, they are not valid preprocessor tokens -- see the Tutorial for more information on this topic.)</p>
<p><span class="bold"><strong>Note:</strong></span> For functions with no argument <code class="computeroutput">(function-name)( (void) )</code>, and not just <code class="computeroutput">(function-name)( )</code>, must be used to specify the empty argument list within <code class="computeroutput">sequence</code>. This is because ISO standard C++ does not allow for empty macro parameters (this library also supports <code class="computeroutput">(function-name)( )</code> but this will only compile on C99 so its use is not recommended -- see the Tutorial section for more information).</p>
<p><span class="bold"><strong>Warning:</strong></span> While there is only a limited amount of compile-time error checking that the library can do on <code class="computeroutput">sequence</code>, the current library implementation does not uses the best possible error detection and reporting mechanism for missuses of the <code class="computeroutput">sequence</code> syntax. In some cases, and depending on the compiler used, an error in programming <code class="computeroutput">sequence</code> might result in cryptic compiler errors (involving library internal templates and preprocessor macros, Boost.Preprocessor internal macros <code class="computeroutput">BOOST_PP_...</code>, and only referring to the contract macro first line number). The best way to resolve these errors is usually to inspect the <code class="computeroutput">sequence</code> by eye instead of trying to make sense of the compiler error messages. Also, try first to compile with contracts turned off so to make sure that the errors are actually in the contract code. Rarely, it might be useful to look at the code generated by the contract macro expansion after preprocessing using your compiler related options ("-E -P" on GCC, "\EP" on Microsoft Visual C++, etc).</p>
<p><span class="bold"><strong>See:</strong></span> <code class="computeroutput">CONTRACT_ASSERT()</code>, <code class="computeroutput">CONTRACT_INVARIANT()</code>, <code class="computeroutput">CONTRACT_CONSTRUCTOR()</code>, <code class="computeroutput">CONTRACT_DESTRUCTOR()</code> </p>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright © 2009 -2010 Lorenzo Caminiti<p>
        Distributed under the Contract++ Software License, Version 1.0 (see accompanying
        file LICENSE_1_0.txt)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="CONTRACT_DESTRUCTOR.html"><img src="./doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="reference.html#header..home.lcaminiti.sandbox.dbcpp_sourceforge.boost-quickbook.doc.qbk.src.contract.macros_hpp"><img src="./doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="index.html"><img src="./doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="contract/nonmember_function.html"><img src="./doc/html/images/next.png" alt="Next"></a>
</div>
</body>
</html>
